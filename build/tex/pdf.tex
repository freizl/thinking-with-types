% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
  11pt,
]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Thinking with Types},
  pdfauthor={Sandy Maguire},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[top=25mm,left=30mm,right=30mm,bottom=25mm]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.50,0.19,0.50}{\textit{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\makeatletter
\@ifpackageloaded{subfig}{}{\usepackage{subfig}}
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\captionsetup[subfloat]{margin=0.5em}
\AtBeginDocument{%
\renewcommand*\figurename{Figure}
\renewcommand*\tablename{Table}
}
\AtBeginDocument{%
\renewcommand*\listfigurename{List of Figures}
\renewcommand*\listtablename{List of Tables}
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother

\title{Thinking with Types}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Type-Level Programming in Haskell}
\author{Sandy Maguire}
\date{}


% NOTE(sandy): here is where my stuff lives

\newenvironment{EqnBox}[1]{\begin{tcolorbox}[arc=0mm,colback=gray!5,colframe=gray!75!black,fonttitle=\bfseries,before skip=20pt plus 2pt,after skip=20pt plus 2pt,title={Law: \lawname{#1}}]}{\vspace{-0.5cm}\end{tcolorbox}}

\usepackage{ragged2e}
\usepackage{fvextra}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}

\usepackage{tcolorbox}
\usepackage{pdfpages}

\newlength\longest

\let\oldShaded\Shaded
\let\oldendShaded\endShaded
\def\Shaded{\vspace{1em}\oldShaded}
\def\endShaded{\oldendShaded\vspace{1em}}

% workaround for https://github.com/jgm/pandoc/issues/5801
\renewcommand{\linethickness}{0.05em}

\DeclareFontFamily{U}{skulls}{}
\DeclareFontShape{U}{skulls}{m}{n}{ <-> skull }{}
\newcommand{\skull}{\text{\usefont{U}{skulls}{m}{n}\symbol{'101}}}


\usepackage{manyfoot}
\DeclareNewFootnote{Death}[arabic]
\newcommand{\DeathNote}[1]{\footnoteDeath{#1}}
\renewcommand\thefootnoteDeath{\skull\arabic{footnoteDeath}}

\usepackage{fancyhdr}
\usepackage{fontspec}
\usepackage{newunicodechar}
\usepackage[Latin,Greek]{ucharclasses}
\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage[thmmarks, amsmath, thref]{ntheorem}
% \newfontface{\libertinus}{FreeSans}
% \newfontface{\monospacefont}{Inconsolata}

\newunicodechar{∀}{%
  \begingroup
  \normalfont\libertinus ∀%
  \endgroup
}

\newunicodechar{⋆}{%
  \begingroup
  \normalfont\libertinus ⋆%
  \endgroup
}

\newfontfamily\suitfont{DejaVu Sans}


\newunicodechar{♥}{\begingroup\normalfont\suitfont♥\endgroup}
\newunicodechar{♦}{\begingroup\normalfont\suitfont♦\endgroup}
\newunicodechar{♣}{\begingroup\normalfont\suitfont♣\endgroup}
\newunicodechar{♠}{\begingroup\normalfont\suitfont♠\endgroup}
\newunicodechar{⊗}{\begingroup\normalfont\suitfont⊗\endgroup}


\newfontfamily{\substitutefont}[Scale=MatchLowercase]{Noto Sans}
\setTransitionsForGreek{\begingroup\substitutefont}{\endgroup}



\pagestyle{fancy}
\setlength{\headheight}{13.6pt}
% \renewcommand{\headrulewidth}{0pt}
% \renewcommand{\footrulewidth}{0pt}
\fancyhead[LE]{\thepage}
\fancyhead[LO]{\rightmark}
\fancyhead[RO]{\thepage}
% \fancyfoot[C]{\footnotesize revision \texttt{\input{.current-revision}}}
\fancyfoot[C]{}


\newcommand{\anncirc}[1]{\raisebox{-0.5mm}{\tikz\node[text=white,
font=\sffamily\bfseries,minimum size=2mm,inner sep=0mm,draw,circle,fill=black]
{\small #1};}}

\newcommand{\ann}[1]{\hspace{1.5mm}\anncirc{#1}\hspace{1.5mm}}
\newcommand{\annotate}[1]{\Dotfill\quad\anncirc{#1}\qquad}
\newcommand{\reducevia}[1]{\Dotfill\quad\via{#1}\qquad}
\newcommand{\via}[1]{(via \lawname{#1})}
\newcommand{\lawname}[1]{"#1"\normalfont}
% \newcommand{\lawname}[1]{\fontspec{Lobster}[Scale=0.80]"#1"\normalfont}
\newcommand{\deflaw}[1]{\Dotfill\quad\lawname{#1}\qquad}

\makeatletter{}
\newcommand{\Dotfill}{\leavevmode \cleaders \hb@xt@.85em{\ensuremath{\hss
\cdot\hss}}
\hfill \kern \z@}

\newcommand{\Lawfill}{\leavevmode \cleaders \hb@xt@2em{\hss}
\hfill \kern \z@}
\makeatother{}


\theoremprework{%
\setlength\theorempreskipamount{1ex}\setlength\theorempostskipamount{2ex}
}

\theoremstyle{nonumberplain}
\theoremheaderfont{\itshape}
\theorembodyfont{\upshape}
\theoremseparator{.}
\theoremsymbol{\ensuremath{\square}}
\newtheorem{exercise}{Exercise}

\usepackage{etoolbox}
\usepackage{xstring}
% \setlength{\aboverulesep}{0pt}
% \setlength{\belowrulesep}{0pt}
\renewcommand{\arraystretch}{1.3}
\makeatletter
\patchcmd{\LT@array}{\@mkpream{#2}}{%
\StrGobbleLeft{#2}{2}[\pream]%
\StrGobbleRight{\pream}{2}[\pream]%
\StrSubstitute{\pream}{l}{|l}[\pream]%
\StrSubstitute{\pream}{c}{|c}[\pream]%
\StrSubstitute{\pream}{r}{|r}[\pream]%
\@mkpream{@{}\pream|@{}}%
}{}{}
\makeatother

\usepackage{float}
\floatplacement{figure}{H}

\begin{document}
\frontmatter
\maketitle


% TODO(sandy): beginning of frontmatter stuff

\newcommand{\spaceMyBox}{\par\addvspace{8mm}}

\newcommand{\bigQuote}[2]{
\centering
\parbox{\longest}{%
  \raggedright{\Large%
   #2\par\bigskip
  }
  \raggedleft\Large\MakeUppercase{#1}\par%
}
}

\thispagestyle{empty}
\null\vfill

\raggedright

Copyright \textcopyright 2020, Sandy Maguire

All rights reserved.
\spaceMyBox
Version 1.1.3

\justify


\clearpage
\thispagestyle{empty}
\quad
\clearpage


\thispagestyle{empty}

\clearpage
\newcommand{\dedicationname}{Dedication}
\pdfbookmark{\dedicationname}{dedication}
\thispagestyle{empty}
\null\vfill

\settowidth\longest{\Large all those wonderful facilities of your so-called}
\bigQuote{Edsger W. Dijkstra}{
  Are you quite sure\\
  that all those bells and whistles,\\
  all those wonderful facilities of your so-called\\
  ``powerful'' programming languages,\\
  belong to the solution set\\
  rather than to the problem set?
}

\justify

\vfill\vfill

% TODO(sandy): end

{
\setcounter{tocdepth}{2}
\tableofcontents
}
\mainmatter
\hypertarget{preface.}{%
\chapter{Preface\{.\}}\label{preface.}}

Thinking with Types started, as so many of my projects do, accidentally.
I was unemployed, bored, and starting to get tired of answering the same
questions over and over again in Haskell chat-rooms. And so I started a
quick document, jotting down a bunch of type-level programming topics I
thought it'd be fun to write blog posts about.

This document rather quickly turned into an outline of what those blog
posts might look like, but as I was about to tease it apart into
separate files I stopped myself. Why not turn it into a book instead?

I approached some friends to see if anyone was interested in writing it
with me. A few nibbles, but nobody had time they wanted to dedicate to
such a thing. My excitement subsequently burned out, and the idea lay
dormant on the back-burner for a few months.

But I was still unemployed, and I was still bored, and I found myself
slowly fleshing out chapters regardless. My enthusiasm for \emph{writing
a book} had died down, but I still felt the urge to \emph{write.} A
friend caught me writing one day, and dared me to publish what I had. I
acquiesced.

And so on July 8th, 2018, I posted a 37 page document to reddit, gauging
if there was any interest from the community in such a book. To my
continual surprise, there was. The response was about 100x bigger than I
was expecting. Kind words and letters of support rolled in, many of whom
promised to pay me in order to continue writing it.

That was enough for me. I put together a Patreon, started selling early
access to the book, and was off to the races. The promise was to publish
weekly updates, which---combined with not wanting to commit fraud---kept
me extremely motivated to get this book finished. It's a powerful
technique to stay focused, and I'd strongly recommend it to anyone who
is better at starting projects than finishing them.

It sounds cliche, but this book couldn't have happened without the
overwhelming support of the Haskell community. It's particularly telling
that every day I learn new things from them about this marvelous
language, even after five years.

Written with love by Sandy Maguire. 2018.

\hypertarget{acknowledgments.}{%
\chapter{Acknowledgments\{.\}}\label{acknowledgments.}}

This book couldn't have happened without the support of many, many
fantastic people. I'd like to thank everyone for their support, their
patronage and their enthusiasm. Some of the exceptionally instrumental
people, however, require further accolades. In particular:

\emph{Fintan Halpenny,} for his everlasting gusto. My unofficial editor,
publicist, and second pair of eyes. The only person I know who's
actually done all of the exercises.

\emph{Irene Papakonstantinou,} for her untiring support, who first
encouraged me to publish this book, who bullied me into staying on
schedule, and for putting her money where her mouth was.

\emph{Jessie Natasha,} for patiently answering my non-stop design
questions. For time and time again offering me her sense of style, and
spending long hours with me helping make the book look as good as it
does.

\emph{Anushervon Saidmuradov,} whose support for me greatly exceeds his
interest in Haskell.

Furthermore, this book wouldn't have been possible without the financial
support of \emph{Habito}, \emph{Mirzhan Irkegulov}, \emph{Michael
Koloberdin}, and \emph{Chris Double}.

\hypertarget{introduction.}{%
\chapter{Introduction\{.\}}\label{introduction.}}

Type-level programming is an uncommon calling. While most programmers
are concerned with getting more of their code to compile, we type-level
programmers are trying our best to \emph{prevent} code from compiling.

Strictly speaking, the job of types is twinfold---they prevent (wrong)
things from compiling, and in doing so, they help guide us towards more
elegant solutions. For example, if there are ten solutions to a problem,
and nine of them be poorly-typed, then we need not look very hard for
the right answer.

But make no mistake---this book is primarily about reducing the
circumstances under which a program compiles. If you're a beginner
Haskell programmer who feels like GHC argues with you too often, who
often finds type errors inscrutable, then this book is probably not for
you. Not yet.

So whom is this book for? The target audience I've been trying to write
for are intermediate-to-proficient with the language. They're capable of
solving real problems in Haskell, and doing it without too much hassle.
They need not have strong opinions on \texttt{ExceptT} vs throwing
exceptions in \texttt{IO}, nor do they need to know how to inspect
generated Core to find performance bottlenecks.

But the target reader should have a healthy sense of unease about the
programs they write. They should look at their comments saying ``don't
call this function with \(n=5\) because it will crash,'' and wonder if
there's some way to teach the compiler about that. The reader should
nervously eyeball their calls to \VERB|\FunctionTok{error}| that they're
convinced can't possibly happen, but are required to make the
type-checker happy.

In short, the reader should be looking for opportunities to make
\emph{less} code compile. This is not out of a sense of masochism,
anarchy, or any such thing. Rather, this desire comes from a place of
benevolence---a little frustration with the type-checker now is
preferable to a hard-to-find bug making its way into production.

Type-level programming, like anything, is best in moderation. It comes
with its own costs in terms of complexity, and as such should be wielded
with care. While it's pretty crucial that your financial application
handling billions of dollars a day runs smoothly, it's a little less
critical if your hobbyist video game draws a single frame of gameplay
incorrectly. In the first case, it's probably worthwhile to use whatever
tools you have in order to prevent things from going wrong. In the
second, these techniques are likely too heavy-handed.

Style is a notoriously difficult thing to teach---in a very real sense,
style seems to be what's left after we've extracted from a subject all
of the things we know how to teach. Unfortunately, when to use
type-level programming is largely a matter of style. It's easy to take
the ball and run with it, but discretion is divine.

When in doubt, err on the side of \emph{not} doing it at the type-level.
Save these techniques for the cases where it'd be catastrophic to get
things wrong, for the cases where a little type-level stuff goes a long
way, and for the cases where it will drastically improve the API. If
your use-case isn't obviously one of these, it's a good bet that there
is a cleaner and easier means of doing it with values.

But let's talk more about types themselves.

As a group, I think it's fair to say that Haskellers are contrarians.
Most of us, I'd suspect, have spent at least one evening trying to extol
the virtues of a strong type system to a dynamically typed colleague.
They'll say things along the lines of ``I like Ruby because the types
don't get in my way.'' Though our first instinct, as proponents of
strongly typed systems, might be to forcibly connect our head to the
table, I think this is a criticism worth keeping in mind.

As Haskellers, we certainly have strong opinions about the value of
types. They \emph{are} useful, and they \emph{do} carry their weight in
gold when coding, debugging and refactoring. While we can dismiss our
colleague's complaints with a wave of the hand and the justification
that they've never seen a ``real'' type system before, we are doing them
and ourselves a disservice both. Such a flippant response is to ignore
the spirit of their unhappiness---types \emph{often do} get in the way.
We've just learned to blind ourselves to these shortcomings, rather than
to bite the bullet and entertain that maybe types aren't always the
solution to every problem.

Simon Peyton Jones, one of the primary authors of Haskell, is quick to
acknowledge the fact that there are plenty of error-free programs ruled
out by a type system. Consider, for example, the following program which
has a type-error, but never actually evaluates it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{fst}\NormalTok{ (}\StringTok{"no problems"}\NormalTok{, }\DataTypeTok{True} \OperatorTok{\textless{}\textgreater{}} \DecValTok{17}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Because the type error gets ignored lazily by \VERB|\FunctionTok{fst}|,
evaluation of such an expression will happily produce
\VERB|\StringTok{"no problems"}| at runtime. Despite the fact that we
consider it to be ill-typed, it is in fact, well-behaved. The usefulness
of such an example is admittedly low, but the point stands; types often
do get in the way of perfectly reasonable programs.

Sometimes such an obstruction comes under the guise of ``it's not clear
what type this thing should have.'' One particularly poignant case of
this is C's \VERB|\NormalTok{printf}| function:

\VERB|\DataTypeTok{int}\NormalTok{ printf (}\AttributeTok{const} \DataTypeTok{char}\NormalTok{ *format, ...)}|

If you've never before had the pleasure of using
\VERB|\NormalTok{printf}|, it works like this: it parses the
\VERB|\NormalTok{format}| parameter, and uses its structure to pop
additional arguments off of the call-stack. You see, it's the shape of
\VERB|\NormalTok{format}| that decides what parameters should fill in
the \VERB|\NormalTok{...}| above.

For example, the format string
\VERB|\StringTok{"hello }\ErrorTok{\textbackslash{}\%}\StringTok{s"}|
takes an additional string and interpolates it in place of the
\VERB|\NormalTok{\textbackslash{}\%s}|. Likewise, the specifier
\VERB|\NormalTok{\textbackslash{}\%d}| describes interpolation of a
signed decimal integer.

The following calls to \VERB|\NormalTok{printf}| are all valid:

\begin{itemize}
\tightlist
\item
  \VERB|\NormalTok{printf(}\StringTok{"hello }\ErrorTok{\textbackslash{}\%}\StringTok{s"}\NormalTok{, }\StringTok{"world"}\NormalTok{)}|,
  producing ``hello world'',

  \begin{itemize}
  \tightlist
  \item
    \VERB|\NormalTok{printf(}\StringTok{"}\ErrorTok{\textbackslash{}\%}\StringTok{d + }\ErrorTok{\textbackslash{}\%}\StringTok{d = }\ErrorTok{\textbackslash{}\%}\StringTok{s"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\StringTok{"three"}\NormalTok{)}|,
    producing ``1 + 2 = three'',
  \item
    \VERB|\NormalTok{printf(}\StringTok{"no specifiers"}\NormalTok{)}|,
    producing ``no specifiers''.
  \end{itemize}
\end{itemize}

Notice that, as written, it seems impossible to assign a Haskell-esque
type signature to \VERB|\NormalTok{printf}|. The additional parameters
denoted by its ellipsis are given types by the value of its first
parameter---a string. Such a pattern is common in dynamically typed
languages, and in the case of \VERB|\NormalTok{printf}|, it's inarguably
useful.

The documentation for \VERB|\NormalTok{printf}| is quick to mention that
the format string must not be provided by the user---doing so opens up
vulnerabilities in which an attacker can corrupt memory and gain access
to the system. Indeed, this is hugely widespread problem---and crafting
such a string is often the first homework in any university lecture on
software security.

To be clear, the vulnerabilities in \VERB|\NormalTok{printf}| occur when
the format string's specifiers do not align with the additional
arguments given. The following, innocuous-looking calls to
\VERB|\NormalTok{printf}| are both malicious.

\begin{itemize}
\tightlist
\item
  \VERB|\NormalTok{printf(}\StringTok{"}\ErrorTok{\textbackslash{}\%}\StringTok{d"}\NormalTok{)}|,
  which will probably corrupt the stack,

  \begin{itemize}
  \tightlist
  \item
    \VERB|\NormalTok{printf(}\StringTok{"}\ErrorTok{\textbackslash{}\%}\StringTok{s"}\NormalTok{, }\DecValTok{1}\NormalTok{)}|,
    which will read an arbitrary amount of memory.
  \end{itemize}
\end{itemize}

C's type system is insufficiently expressive to describe
\VERB|\NormalTok{printf}|. But because \VERB|\NormalTok{printf}| is such
a useful function, this is not a persuasive-enough reason to exclude it
from the language. Thus, type-checking is effectively turned off for
calls to \VERB|\NormalTok{printf}| so as to have ones cake and eat it
too. However, this opens a hole through which type errors can make it
all the way to runtime---in the form of undefined behavior and security
issues.

My opinion is that preventing security holes is a much more important
aspect of the types, over ``\texttt{null} is the billion dollar
mistake'' or whichever other arguments are in vogue today. We will
return to the problem of \VERB|\NormalTok{printf}| in chapter 9.

With very few exceptions, the prevalent attitude of Haskellers has been
to dismiss the usefulness of ill-typed programs. The alternative is an
uncomfortable truth: that our favorite language can't do something
useful that other languages can.

But all is not lost. Indeed, Haskell \emph{is} capable of expressing
things as oddly-typed as \VERB|\NormalTok{printf}|, for those of us
willing to put in the effort to learn how. This book aims to be
\emph{the} comprehensive manual for getting you from here to there, from
a competent Haskell programmer to one who convinces the compiler to do
their work for them.

\hypertarget{the-algebra-behind-types}{%
\chapter{The Algebra Behind Types}\label{the-algebra-behind-types}}

\hypertarget{isomorphisms-and-cardinalities}{%
\section{Isomorphisms and
Cardinalities}\label{isomorphisms-and-cardinalities}}

One of functional programming's killer features is pattern matching, as
made possible by algebraic data types. But this term isn't just a catchy
title for things that we can pattern match on. As their name suggests,
there is in fact an \emph{algebra} behind algebraic data types.

Being comfortable understanding and manipulating this algebra is a
mighty superpower---it allows us to analyze types, find more convenient
forms for them, and determine which operations (eg. typeclasses) are
possible to implement.

To start, we can associate each finite type with its cardinality---the
number of inhabitants it has, ignoring bottoms. Consider the following
simple type definitions:

\href{Snip}{code/Algebra.hs:Void} \href{Snip}{code/Algebra.hs:Unit}
\href{Snip}{code/Algebra.hs:Bool}

\texttt{Void} has zero inhabitants, and so it is assigned cardinality 0.
The unit type \texttt{()} has one inhabitant---thus its cardinality is
1. Not to belabor the point, but \texttt{Bool} has cardinality 2,
corresponding to its constructors \VERB|\DataTypeTok{True}| and
\VERB|\DataTypeTok{False}|.

We can write these statements about cardinality more formally:

\begin{verbatim}
  `cardinality:Void` &= 0

  `cardinality:()` &= 1

  `cardinality:Bool` &= 2
\end{verbatim}

Any two finite types that have the same cardinality will always be
isomorphic to one another. An isomorphism between types \texttt{s} and
\texttt{t} is defined as a pair of functions \VERB|\NormalTok{to}| and
\VERB|\NormalTok{from}|:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{to   ::}\NormalTok{ s }\OtherTok{{-}\textgreater{}}\NormalTok{ t}
\OtherTok{from ::}\NormalTok{ t }\OtherTok{{-}\textgreater{}}\NormalTok{ s}
\end{Highlighting}
\end{Shaded}

\noindent such that composing either after the other gets you back where
you started. In other words, such that:

\begin{verbatim}
  `to .\spaceJob{}from = id`{.haskell}

  `from .\spaceJob{}to = id`{.haskell}
\end{verbatim}

We sometimes write an isomorphism between types \texttt{s} and
\texttt{t} as \texttt{s} ≅ \texttt{t}.

If two types have the same cardinality, any one-to-one mapping between
their elements is exactly these \VERB|\NormalTok{to}| and
\VERB|\NormalTok{from}| functions. But where does such a mapping come
from? Anywhere---it doesn't really matter! Just pick an arbitrary
ordering on each type---not necessarily corresponding to an \texttt{Ord}
instance---and then map the first element under one ordering to the
first element under the other. Rinse and repeat.

For example, we can define a new type that also has cardinality 2.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Spin} \OtherTok{=} \DataTypeTok{Up} \OperatorTok{|} \DataTypeTok{Down}
\end{Highlighting}
\end{Shaded}

By the argument above, we should expect \texttt{Spin} to be isomorphic
to \texttt{Bool}. Indeed it is:

\href{Snip}{code/Algebra.hs:boolToSpin1}
\href{Snip}{code/Algebra.hs:spinToBool1}

However, note that there is another isomorphism between \texttt{Spin}
and \texttt{Bool}:

\href{Snip}{code/Algebra.hs:boolToSpin2}
\href{Snip}{code/Algebra.hs:spinToBool2}

Which of the two isomorphisms should we prefer? Does it matter?

In general, for any two types with cardinality \(n\), there are \(n!\)
unique isomorphisms between them. As far as the math goes, any of these
is just as good as any other---and for most purposes, knowing that an
isomorphism \emph{exists} is enough.

An isomorphism between types \texttt{s} and \texttt{t} is a proof that
\emph{for all intents and purposes,} \texttt{s} and \texttt{t} \emph{are
the same thing.} They might have different instances available, but this
is more a statement about Haskell's typeclass machinery than it is about
the equivalence of \texttt{s} and \texttt{t}.

Isomorphisms are a particularly powerful concept in the algebra of
types. Throughout this book we shall reason via isomorphism, so it's
best to get comfortable with the idea now.

\hypertarget{sum-product-and-exponential-types}{%
\section{Sum, Product and Exponential
Types}\label{sum-product-and-exponential-types}}

In the language of cardinalities, sum types correspond to addition. The
canonical example of these is \texttt{Either\ a\ b}, which is
\emph{either} an \texttt{a} or a \texttt{b}. As a result, the
cardinality (remember, the number of inhabitants) of
\texttt{Either\ a\ b} is the cardinality of \texttt{a} plus the
cardinality of \texttt{b}.

\[
`cardinality:Either a b` = `cardinality:a` + `cardinality:b`
\]

As you might expect, this is why such things are called \emph{sum}
types. The intuition behind adding generalizes to any datatype with
multiple constructors---the cardinality of a type is always the sum of
the cardinalities of its constructors.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Deal}\NormalTok{ a b}
  \OtherTok{=} \DataTypeTok{This}\NormalTok{ a}
  \OperatorTok{|} \DataTypeTok{That}\NormalTok{ b}
  \OperatorTok{|} \DataTypeTok{TheOther} \DataTypeTok{Bool}
\end{Highlighting}
\end{Shaded}

We can analyze \texttt{Deal}'s cardinality;

\begin{verbatim}
  `cardinality:Deal a b` &= `cardinality:a` + `cardinality:b` + `cardinality:Bool`

  &= `cardinality:a` + `cardinality:b` + 2
\end{verbatim}

We can also look at the cardinality of \texttt{Maybe\ a}. Because
nullary data constructors are uninteresting to construct---there is only
one \VERB|\DataTypeTok{Nothing}|---the cardinality of \texttt{Maybe\ a}
can be expressed as follows;

\[
`cardinality:Maybe a` = 1 + `cardinality:a`
\]

Dual to sum types are the so-called product types. Again, we will look
at the canonical example first---the pair type \texttt{(a,\ b)}.
Analogously, the cardinality of a product type is the \emph{product} of
their cardinalities.

\[
`cardinality:(a, b)` = `cardinality:a` \times `cardinality:b`
\]

To give an illustration, consider mixed fractions of the form
\(5\frac{1}{2}\). We can represent these in Haskell via a product type;

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{MixedFraction}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Fraction}
\NormalTok{  \{}\OtherTok{ mixedBit    ::} \DataTypeTok{Word8}
\NormalTok{  ,}\OtherTok{ numerator   ::}\NormalTok{ a}
\NormalTok{  ,}\OtherTok{ denominator ::}\NormalTok{ a}
\NormalTok{  \}}
\end{Highlighting}
\end{Shaded}

And perform its cardinality analysis as follows:

\[
`cardinality:MixedFraction a` = `cardinality:Word8` \times `cardinality:a` \times `cardinality:a` = 256
\times `cardinality:a` \times `cardinality:a`
\]

An interesting consequence of all of this cardinality stuff is that we
find ourselves able to express \emph{mathematical truths in terms of
types}. For example, we can prove that \(a \times 1 = a\) by showing an
isomorphism between \texttt{(a,\ ())} and \texttt{a}.

\href{Snip}{code/Algebra.hs:prodUnitTo}
\href{Snip}{code/Algebra.hs:prodUnitFrom}

Here, we can think of the unit type as being a monoidal identity for
product types---in the sense that ``sticking it in doesn't change
anything.'' Because \(a \times 1 = a\), we can pair with as many unit
types as we want.

Likewise, \texttt{Void} acts as a monoidal unit for sum types. To
convince ourselves of this, the trivial statement \(a+0 = a\) can be
witnessed as an isomorphism between \texttt{Either\ a\ Void} and
\texttt{a}.

\href{Snip}{code/Algebra.hs:sumUnitTo}
\href{Snip}{code/Algebra.hs:sumUnitFrom}

The function \VERB|\NormalTok{absurd}| at \ann{1} has the type
\texttt{Void\ -\textgreater{}\ a}. It's a sort of bluff saying ``if you
give me a \texttt{Void} I can give you anything you want.'' This is a
promise that can never be fulfilled, but because there are no
\texttt{Void}s to be had in the first place, we can't disprove such a
claim.

Function types also have an encoding as statements about
cardinality---they correspond to exponentialization. To give an example,
there are exactly four (\(2^2\)) inhabitants of the type
\texttt{Bool\ -\textgreater{}\ Bool}. These functions are
\VERB|\FunctionTok{id}|, \VERB|\FunctionTok{not}|,
\VERB|\FunctionTok{const} \DataTypeTok{True}| and
\VERB|\FunctionTok{const} \DataTypeTok{False}|. Try as hard as you can,
but you won't find any other pure functions between \texttt{Bool}s!

More generally, the type \texttt{a\ -\textgreater{}\ b} has cardinality
\(`cardinality:b`^{`cardinality:a`}\). While this might be surprising at
first---it always seems backwards to me---the argument is
straightforward. For every value of \texttt{a} in the domain, we need to
give back a \texttt{b}. But we can choose any value of \texttt{b} for
every value of \texttt{a}---resulting in the following equality.

\[
`cardinality:a -> b` = \underbrace{`cardinality:b` \times `cardinality:b` \times \cdots \times
`cardinality:b`}_{`cardinality:a` \text{times}} = `cardinality:b`^{`cardinality:a`}
\]

\begin{verbatim}
Determine the cardinality of `Either Bool (Bool, Maybe Bool) -> Bool`.
\end{verbatim}

\begin{verbatim}
```align
  &  `cardinality:Either Bool (Bool, Maybe Bool) -> Bool`

  &= `cardinality:Bool`^{`cardinality:Either Bool (Bool, Maybe Bool)`}

  &= `cardinality:Bool`^{`cardinality:Bool`+`cardinality:Bool`\times`cardinality:Maybe Bool`}

  &= `cardinality:Bool`^{`cardinality:Bool`+`cardinality:Bool`\times(`cardinality:Bool`+1)}

  &= 2^{2+2\times(2+1)}

  &= 2^{2+2\times 3}

  &= 2^{2+6}

  &= 2^{8}

  &= 256
\end{verbatim}

\begin{verbatim}

The inquisitive reader might wonder whether subtraction, division and other
mathematical operations have meaning when applied to types. Indeed they do, but
such things are hard, if not impossible, to express in Haskell. Subtraction
corresponds to types with particular values removed, while division of a type
makes some of its values equal (in the sense of being defined equally---rather
than having an `Eq` instance which equates them.)

In fact, even the notion of differentiation in calculus has meaning in the
domain of types. Though we will not discuss it further, the interested reader is
encouraged to refer to Conor McBride's paper "The Derivative of a Regular Type
is its Type of One-Hole Contexts."@cite:one-hole.


### Example: Tic-Tac-Toe

I said earlier that being able to manipulate the algebra behind types is a
mighty superpower. Let's prove it.

Imagine we wanted to write a game of tic-tac-toe. The standard tic-tac-toe board
has nine spaces, which we could naively implement like this:

[code/Algebra.hs:TicTacToe](Snip)

While such a thing works, it's rather unwieldy to program against. If we wanted
to construct an empty board for example, there's quite a lot to fill in.

[code/Algebra.hs:emptyBoard](Snip)

Writing functions like `checkWinner`{.haskell} turn out to be even more involved.

Rather than going through all of this trouble, we can use our knowledge of the
algebra of types to help. The first step is to perform a cardinality analysis on
`TicTacToe`;

```align
  `cardinality:TicTacToe a` &= \underbrace{`cardinality:a` \times `cardinality:a` \times \cdots
  \times `cardinality:a`}_{9 \text{ times}}

    &= `cardinality:a`^{9}

    &= `cardinality:a`^{3\times 3}
\end{verbatim}

When written like this, we see that \texttt{TicTacToe} is isomorphic to
a function \texttt{(Three,\ Three)\ -\textgreater{}\ a}, or in its
curried form:
\texttt{Three\ -\textgreater{}\ Three\ -\textgreater{}\ a}. Of course,
\texttt{Three} is any type with three inhabitants; perhaps it looks like
this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Three} \OtherTok{=} \DataTypeTok{One} \OperatorTok{|} \DataTypeTok{Two} \OperatorTok{|} \DataTypeTok{Three}
  \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Eq}\NormalTok{, }\DataTypeTok{Ord}\NormalTok{, }\DataTypeTok{Enum}\NormalTok{, }\DataTypeTok{Bounded}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Due to this isomorphism, we can instead represent \texttt{TicTacToe} in
this form:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{TicTacToe2}\NormalTok{ a }\OtherTok{=} \DataTypeTok{TicTacToe2}
\NormalTok{  \{}\OtherTok{ board ::} \DataTypeTok{Three} \OtherTok{{-}\textgreater{}} \DataTypeTok{Three} \OtherTok{{-}\textgreater{}}\NormalTok{ a}
\NormalTok{  \}}
\end{Highlighting}
\end{Shaded}

And thus simplify our implementation of \VERB|\NormalTok{emptyBoard}|:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{emptyBoard2 ::} \DataTypeTok{TicTacToe2}\NormalTok{ (}\DataTypeTok{Maybe} \DataTypeTok{Bool}\NormalTok{)}
\NormalTok{emptyBoard2 }\OtherTok{=}
  \DataTypeTok{TicTacToe2} \OperatorTok{$} \FunctionTok{const} \OperatorTok{$} \FunctionTok{const} \DataTypeTok{Nothing}
\end{Highlighting}
\end{Shaded}

Such a transformation doesn't let us do anything we couldn't have done
otherwise, but it does drastically improve the ergonomics. By making
this change, we are rewarded with the entire toolbox of combinators for
working with functions; we gain better compositionality and have to pay
less of a cognitive burden.

Let us not forget that programming is primarily a human endeavor, and
ergonomics are indeed a worthwhile pursuit. Your colleagues and
collaborators will thank you later!

\hypertarget{the-curryhoward-isomorphism}{%
\section{The Curry--Howard
Isomorphism}\label{the-curryhoward-isomorphism}}

Our previous discussion of the algebraic relationships between types and
their cardinalities can be summarized in the following table.

**Algebra\#\#

**Logic\#\#

**Types\#\#

\(a + b\)

\(a \vee b\)

\texttt{Either\ a\ b}

\(a \times b\)

\(a \wedge b\)

\texttt{(a,\ b)}

\(b^a\)

\(a \implies b\)

\texttt{a\ -\textgreater{}\ b}

\(a=b\)

\(a \iff b\)

\emph{isomorphism}

0

\(\bot\)

\texttt{Void}

1

\(\top\)

\texttt{()}

This table itself forms a more-general isomorphism between mathematics
and types. It's known as the Curry--Howard isomorphism---loosely stating
that every statement in logic is equivalent to some computer program,
and vice versa.

The Curry--Howard isomorphism is a profound insight about our universe.
It allows us to analyze mathematical theorems through the lens of
functional programming. What's better is that often even ``boring''
mathematical theorems are interesting when expressed as types.

To illustrate, consider the theorem \(a^1 = a\). When viewed through
Curry--Howard, it describes an isomorphism between
\texttt{()\ -\textgreater{}\ a} and \texttt{a}. Said another way, this
theorem shows that there is no essential distinction between having a
value and having a (pure) program that computes that value. This insight
is the core principle behind why writing Haskell is such a joy compared
with other programming languages.

\begin{verbatim}
  Use Curry--Howard to prove that $(a^b)^c = a^{b\times c}$. That is, provide a
  function of type `(b -> c -> a) -> (b, c) -> a`, and one of `((b, c) ->
  a) -> b -> c -> a`. Make sure they satisfy the equalities `to . from = id`{.haskell}
  and `from . to = id`{.haskell}. Do these functions remind you of anything from
  `Prelude`?
\end{verbatim}

\begin{verbatim}
[code/Algebra.hs:curry](Snip)
[code/Algebra.hs:uncurry](Snip)

  Both of these functions already exist in `Prelude`.
\end{verbatim}

\begin{verbatim}
Give a proof of the exponent law that $a^b \times a^c = a^{b+c}$.
\end{verbatim}

\begin{verbatim}
[code/Algebra.hs:productRule1To](Snip)
[code/Algebra.hs:productRule1From](Snip)

  Notice that `productRule1To`{.haskell} is the familiar `either`{.haskell} function from `Prelude`.
\end{verbatim}

\begin{verbatim}
Prove $(a\times b)^c = a^c \times b^c$.
\end{verbatim}

\begin{verbatim}
[code/Algebra.hs:productRule2To](Snip)
[code/Algebra.hs:productRule2From](Snip)
\end{verbatim}

\hypertarget{canonical-representations}{%
\section{Canonical Representations}\label{canonical-representations}}

A direct corollary that any two types with the same cardinality are
isomorphic, is that there are multiple ways to represent any given type.
Although you shouldn't necessarily let it change the way you model
types, it's good to keep in mind that you have a choice.

Due to the isomorphism, all of these representations of a type are
``just as good'' as any other. However, as we'll see
Chapter~\ref{sec:ghc.generics}, it's often useful to have a conventional
form when working with types generically. This canonical representation
is known as a sum of products, and refers to any type \texttt{t} of the
form,

\[
{t = \sum_{m}^{}{\prod_{n}^{}{t_{m,n}}}}
\]

The big \(\Sigma\) means addition, and the \(\Pi\) means
multiplication---so we can read this as ``addition on the outside and
multiplication on the inside.'' We also make the stipulation that all
additions must be represented via \texttt{Either}, and that
multiplications via \texttt{(,)}. Don't worry, writing out the rules
like this makes it seem much more complicated than it really is.

All of this is to say that each of following types is in its canonical
representation:

\begin{itemize}
\tightlist
\item
  \texttt{()}

  \begin{itemize}
  \tightlist
  \item
    \texttt{Either\ a\ b}
  \item
    \texttt{Either\ (a,\ b)\ (c,\ d)}
  \item
    \texttt{Either\ a\ (Either\ b\ (c,\ d))}
  \item
    \texttt{a\ -\textgreater{}\ b}
  \item
    \texttt{(a,\ b)}
  \item
    \texttt{(a,\ Int)}---we make an exception to the rule for numeric
    types, as it would be too much work to express them as sums.
  \end{itemize}
\end{itemize}

But neither of the following types are in their canonical
representation;

\begin{itemize}
\tightlist
\item
  \texttt{(a,\ Bool)}

  \begin{itemize}
  \tightlist
  \item
    \texttt{(a,\ Either\ b\ c)}
  \end{itemize}
\end{itemize}

As an example, the canonical representation of \texttt{Maybe\ a} is
\texttt{Either\ a\ ()}. To reiterate, this doesn't mean you should
prefer using \texttt{Either\ a\ ()} over \texttt{Maybe\ a}. For now it's
enough to know that the two types are equivalent. We shall return to
canonical forms in chapter 13.

\hypertarget{terms-types-and-kinds}{%
\chapter{Terms, Types and Kinds}\label{terms-types-and-kinds}}

\hypertarget{the-kind-system}{%
\section{The Kind System}\label{the-kind-system}}

In everyday Haskell programming, the fundamental building blocks are
those of terms and \emph{types}. Terms are the values you can
manipulate---the things that exist at runtime. Types, however, are
little more than sanity-checks: proofs to the compiler (and ourselves)
that the programs we're trying to write make some amount of sense.

Completely analogously, the fundamental building blocks for type-level
programming are \emph{types} and \emph{kinds}. The types now become the
things to manipulate, and the kinds become the proofs we use to keep
ourselves honest.

The kind system, if you're unfamiliar with it, can be reasonably
described as ``the type system for types.'' By that line of reasoning,
then, kinds are loosely ``the types of types.''

Consider the numbers \VERB|\DecValTok{4}| and \VERB|\DecValTok{5}|, both
of type \texttt{Int}. As far as the compiler is concerned, we could
replace every instance of \VERB|\DecValTok{4}| with \VERB|\DecValTok{5}|
in our program, and the whole thing would continue to compile. The
program itself might do something different, but by virtue of both being
of type \texttt{Int}, \VERB|\DecValTok{4}| and \VERB|\DecValTok{5}| are
interchangeable---at least as far as the type checker is concerned.

\hypertarget{the-kind-of-types}{%
\subsection{The Kind of ``Types''}\label{the-kind-of-types}}

Before continuing our discussion, we must sidestep a potential point of
confusion. Rather perplexingly, there are several, related meanings that
fall under the word ``type.'' We will need to differentiate between two
of them.

The word ``type'' can be used to describe anything that exists at the
type level, which is to say, anything that is neither a term nor a kind.

However, we can also refer to \texttt{Type}s, which is the \emph{kind}
of types that have inhabitants. Historically \texttt{Type} has been
written as \(\star\), but this older notation is slated for deprecation
in the latest versions of GHC. \texttt{Type} is the kind of things like
\texttt{Int} and \texttt{Maybe\ Bool}---it classifies the sorts of
things that exist at runtime. Some things which \emph{aren't} of kind
\texttt{Type} are \texttt{Maybe} (without a type parameter), and
\texttt{Show}.

Sometimes we call the sorts of things which have kind \texttt{Type}
value types.

In this book, we will typeset kinds in \texttt{SmallCaps} in order to
differentiate them from regular types. Note that this is merely a
convention of the printing process---the kind \texttt{Type} should be
still written as \VERB|\DataTypeTok{Type}| in a Haskell source file.

\hypertarget{arrow-kinds}{%
\subsection{Arrow Kinds}\label{arrow-kinds}}

This book assumes you already have a working knowledge of the standard
Haskell kinds, \texttt{Type} and \texttt{(-\textgreater{})}. As such, we
will not dally here any more than is strictly necessary.

Higher-kinded types (HKTs) are those which have type variables. Fully
saturated HKTs in everyday Haskell always have kind \texttt{Type}, which
means that their type constructors \emph{do not.}

Let's consider \texttt{Maybe}. Because it takes a single \texttt{Type}
parameter, we say that \texttt{Maybe} has kind
\texttt{Type\ -\textgreater{}\ Type}---it takes a \texttt{Type} and
gives you back one. \texttt{Either} takes two parameters, and so its
kind is \texttt{Type\ -\textgreater{}\ Type\ -\textgreater{}\ Type}.

But more interesting higher-kinded types are possible too. What about
the monad transformer \texttt{MaybeT}? It also takes two parameters, but
unlike \texttt{Either}, one of those parameters must be a
\texttt{Monad}. Because monads are always of kind
\texttt{Type\ -\textgreater{}\ Type}, we are left with the inescapable
conclusion that \texttt{MaybeT} must have kind
\texttt{(Type\ -\textgreater{}\ Type)\ -\textgreater{}\ Type\ -\textgreater{}\ Type}.

If you're not already familiar with this stuff, it will soon come to you
just as naturally as the type checking rules do.

\hypertarget{constraint-kinds}{%
\subsection{Constraint Kinds}\label{constraint-kinds}}

However, kinds apply to everything at the type-level, not just the
things we traditionally think of as ``types.'' For example, the type of
\VERB|\FunctionTok{show}| is
\texttt{Show\ a\ =\textgreater{}\ a\ -\textgreater{}\ String}. This
\texttt{Show} thing exists as part of the type signature, even though
it's clearly not a \texttt{Type}. Does \texttt{Show\ a} also have a
kind?

Yes! Its kind is \texttt{Constraint}. More generally,
\texttt{Constraint} is the kind of any fully-saturated typeclass.

\begin{verbatim}
If `Show Int` has kind `Constraint`, what's the kind of
`Show`?
\end{verbatim}

\begin{verbatim}
  `Type -> Constraint`
\end{verbatim}

\begin{verbatim}
What is the kind of `Functor`?
\end{verbatim}

\begin{verbatim}
  `(Type -> Type) -> Constraint`
\end{verbatim}

\begin{verbatim}
What is the kind of `Monad`?
\end{verbatim}

\begin{verbatim}
  `(Type -> Type) -> Constraint`
\end{verbatim}

\begin{verbatim}
What is the kind of `MonadTrans`?
\end{verbatim}

\begin{verbatim}
  `((Type -> Type) -> Type -> Type) -> Constraint`
\end{verbatim}

We will discuss the \texttt{Constraint} kind in much further detail
later Chapter~\ref{sec:constraints}.

Without further language extensions, this is the extent of the
expressiveness of Haskell's kind system. As you can see, it's actually
quite limited---we have no notion of polymorphism, of being able to
define our own kinds, or of being able to write functions.

Fortunately, those things are the subject matter of the remainder of
this book---techniques, tools and understanding for Haskell's more
esoteric language extensions.

\hypertarget{data-kinds}{%
\section{Data Kinds}\label{data-kinds}}

By enabling the \texttt{-XDataKinds} extension, we gain the ability to
talk about kinds other than \texttt{Type}, \texttt{Constraint}, and
their arrow derivatives. In particular, \texttt{-XDataKinds} lifts data
constructors into \emph{type constructors} and types into \emph{kinds.}

What does that mean? As an example, let's look at a familiar type
definition:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Bool}
  \OtherTok{=} \DataTypeTok{True}
  \OperatorTok{|} \DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

When \texttt{-XDataKinds} is enabled, the above \emph{type} definition
of \texttt{Bool} \emph{also} gives us the following \emph{kind}
definition---though note that this is not legal Haskell syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{kind }\DataTypeTok{Bool}
  \OtherTok{=} \DataTypeTok{\textquotesingle{}True}
  \OperatorTok{|} \DataTypeTok{\textquotesingle{}False}
\end{Highlighting}
\end{Shaded}

In other words, via \texttt{-XDataKinds} we have now declared the types
\texttt{\textquotesingle{}True} and
\texttt{\textquotesingle{}False}---both of kind \texttt{Bool}. We call
\texttt{\textquotesingle{}True} and \texttt{\textquotesingle{}False}
promoted data constructors. To be clear the
\VERB|\KeywordTok{data} \DataTypeTok{Bool}| definition above introduces
the following things into scope (as usual):

\begin{itemize}
\tightlist
\item
  A type constructor \texttt{Bool} of kind \texttt{Type}

  \begin{itemize}
  \tightlist
  \item
    A data constructor \VERB|\DataTypeTok{True}| of type \texttt{Bool}
  \item
    A data constructor \VERB|\DataTypeTok{False}| of type \texttt{Bool}
  \end{itemize}
\end{itemize}

However, when \texttt{-XDataKinds} is enabled, our definition of
\texttt{Bool} also introduces the following into scope:

\begin{itemize}
\tightlist
\item
  A new kind: \texttt{Bool}

  \begin{itemize}
  \tightlist
  \item
    A promoted data constructor \texttt{\textquotesingle{}True} of kind
    \texttt{Bool}
  \item
    A promoted data constructor \texttt{\textquotesingle{}False} of kind
    \texttt{Bool}
  \end{itemize}
\end{itemize}

The apostrophes on \texttt{\textquotesingle{}True} and
\texttt{\textquotesingle{}False} are known as ticks, and are used to
distinguish promoted data constructors from everyday type constructors.
Because promoted data constructors exist in the same namespace as type
constructors, these ticks aid in differentiating the two. Strictly
speaking, the ticks aren't always necessary, but consider the common
case of a type with a single data constructor:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Unit} \OtherTok{=} \DataTypeTok{Unit}
\end{Highlighting}
\end{Shaded}

In this example, it's very important to differentiate between the
\emph{type constructor} \texttt{Unit} (of kind \texttt{Type}), and the
\emph{promoted data constructor} \texttt{\textquotesingle{}Unit} (of
kind \texttt{Unit}.) This is a subtle point, and can often lead to
inscrutable compiler errors; while it's fine to ask for values of type
\texttt{Maybe\ Unit}, it's a \emph{kind error} to ask for
\texttt{Maybe\ \textquotesingle{}Unit}---because
\texttt{\textquotesingle{}Unit} is the wrong kind!

Let's return to the question of the importance of data kinds. Type-level
programming in Haskell without them is equivalent to programming in a
dynamically typed language. By default, having every kind you manipulate
be \texttt{Type} is a lot like having all of your terms be of the same
type.

While types don't let you do anything you couldn't otherwise, they sure
make it easier to reason about your program! Data kinds are exactly the
same---as we write more and more interesting type-level programs, we'll
use kind signatures to restrict the sorts of types we can be dealing
with.

Promoted data constructors are of the wrong kind to ever exist at
runtime, which raises the question ``what good are they?'' It's a little
too soon to answer this in full glory, but without any other fancy
type-level machinery, we can use them as phantom parameters.

Imagine an application for managing sensitive data, which has built-in
administrator functionality. Because it would be particularly bad if we
accidentally leaked admin functionality to non-admins, we decide to turn
a business logic error into a type error and ask the type system for
help.

We can provide a \texttt{UserType} type, whose only purpose is to give
us access to its promoted data constructors.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{UserType}
  \OtherTok{=} \DataTypeTok{User}
  \OperatorTok{|} \DataTypeTok{Admin}
\end{Highlighting}
\end{Shaded}

Then, we can change our \texttt{User} type so that each user potentially
has an administration token:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{User} \OtherTok{=} \DataTypeTok{User}
\NormalTok{  \{}\OtherTok{ userAdminToken ::} \DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{Proxy} \DataTypeTok{\textquotesingle{}Admin}\NormalTok{)}
\NormalTok{  , }\OperatorTok{...}
\NormalTok{  \}}
\end{Highlighting}
\end{Shaded}

And finally, we make the sensitive operations require a copy of this
administration token.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{doSensitiveThings ::} \DataTypeTok{Proxy} \DataTypeTok{\textquotesingle{}Admin} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{doSensitiveThings }\OtherTok{=} \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

This minor change will cause a type error whenever
\VERB|\NormalTok{doSensitiveThings}| is called without an administration
token. Such an approach makes it much harder to accidentally call
\VERB|\NormalTok{doSensitiveThings}|. More refined techniques (such as
the ST trick, discussed Chapter~\ref{sec:ST} trick) can be used to
prevent programmers from simply conjuring up an admin token whenever
they might like---requiring \VERB|\NormalTok{doSensitiveThings}| to be
called on behalf of an actual administrator \texttt{User}.

\hypertarget{promotion-of-built-in-types}{%
\section{Promotion of Built-In
Types}\label{promotion-of-built-in-types}}

\begin{verbatim}
[code/Kinds.hs:typelits](Snip)
\end{verbatim}

With \texttt{-XDataKinds} enabled, almost all types automatically
promote to kinds, including the built-in ones. Since built-in types
(strings, numbers, lists and tuples) are special at the term-level---at
least in terms of syntax---we should expect them to behave oddly at the
type-level as well.

When playing with promoted built-in types, it's necessary to first
import the \texttt{GHC.TypeLits} module. \texttt{GHC.TypeLits} defines
the kinds themselves, as well as all of the useful type families for
manipulating them. We'll cover this idea in more detail soon.

\hypertarget{symbols}{%
\subsection{Symbols}\label{symbols}}

The promoted version of a \texttt{String} is called a \texttt{Symbol}.
\texttt{Symbol}s are not lists of characters. Symbol type literals can
be written by just using a string literal in a place where a type is
expected. For example:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{set }\OperatorTok{{-}}\DataTypeTok{XDataKinds}
\StringTok{"hello"}\OtherTok{ ::} \DataTypeTok{Symbol}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind }\StringTok{"hello"}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

It's somewhat frustrating that \texttt{Symbol}s are not merely lists of
promoted characters; it means that \texttt{Symbol}s are no longer
inductive types. It's impossible to deconstruct a \texttt{Symbol},
although we are capable of concatenating them via a magic
\texttt{AppendSymbol} primitive provided in \texttt{GHC.TypeLits}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{set }\OperatorTok{{-}}\DataTypeTok{XDataKinds}
\DataTypeTok{AppendSymbol}\OtherTok{ ::} \DataTypeTok{Symbol} \OtherTok{{-}\textgreater{}} \DataTypeTok{Symbol} \OtherTok{{-}\textgreater{}} \DataTypeTok{Symbol}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind }\DataTypeTok{AppendSymbol}
\DataTypeTok{AppendSymbol} \StringTok{"thinking"} \StringTok{" with types"}\OtherTok{ ::} \DataTypeTok{Symbol}
\OtherTok{=} \StringTok{"thinking with types"}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{AppendSymbol} \StringTok{"thinking"} \StringTok{" with types"}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

Additionally, we are capable of comparing \texttt{Symbol}s via the
\texttt{CmpSymbol} primitive.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{@}\KeywordTok{import} \DataTypeTok{Prelude}
\DataTypeTok{CmpSymbol}\OtherTok{ ::} \DataTypeTok{Symbol} \OtherTok{{-}\textgreater{}} \DataTypeTok{Symbol} \OtherTok{{-}\textgreater{}}\NormalTok{ ghc}\OperatorTok{{-}}\NormalTok{prim}\OperatorTok{{-}}\FloatTok{0.5}\OperatorTok{.}\DecValTok{3}\OperatorTok{:}\DataTypeTok{GHC.Types.Ordering}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind }\DataTypeTok{CmpSymbol}
\DataTypeTok{CmpSymbol} \StringTok{"sandy"} \StringTok{"sandy"}\OtherTok{ ::}\NormalTok{ ghc}\OperatorTok{{-}}\NormalTok{prim}\OperatorTok{{-}}\FloatTok{0.5}\OperatorTok{.}\DecValTok{3}\OperatorTok{:}\DataTypeTok{GHC.Types.Ordering}
\OtherTok{=} \CharTok{\textquotesingle{}ghc{-}prim{-}0.5.3:GHC.Types.EQ}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{CmpSymbol} \StringTok{"sandy"} \StringTok{"sandy"}
\DataTypeTok{CmpSymbol} \StringTok{"sandy"} \StringTok{"batman"}\OtherTok{ ::}\NormalTok{ ghc}\OperatorTok{{-}}\NormalTok{prim}\OperatorTok{{-}}\FloatTok{0.5}\OperatorTok{.}\DecValTok{3}\OperatorTok{:}\DataTypeTok{GHC.Types.Ordering}
\OtherTok{=} \CharTok{\textquotesingle{}ghc{-}prim{-}0.5.3:GHC.Types.GT}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{CmpSymbol} \StringTok{"sandy"} \StringTok{"batman"}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

Notice that \texttt{CmpSymbol} is of kind
\texttt{Symbol\ -\textgreater{}\ Symbol\ -\textgreater{}\ Ordering}.
This \texttt{Ordering} is just the \texttt{-XDataKinds} promoted version
of the standard \texttt{Ordering} type from \texttt{Prelude}.

\hypertarget{natural-numbers}{%
\subsection{Natural Numbers}\label{natural-numbers}}

The promotion of numbers is a little more odd. Only the natural numbers
(\(0, 1, 2, \ldots\)) can be promoted---there are no negative,
fractional nor floating type-level numeric literals. These natural
numbers, naturally enough, are of kind \texttt{Nat}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind }\DecValTok{5085072209}
\DecValTok{5085072209}\OtherTok{ ::} \DataTypeTok{Nat}
\end{Highlighting}
\end{Shaded}

\texttt{GHC.TypeLits} defines primitives for performing arithmetic on
\texttt{Nat}s, with exactly the same symbolic identifiers you'd expect
them to have. Using them will require enabling \texttt{-XTypeOperators}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{set }\OperatorTok{{-}}\DataTypeTok{XTypeOperators}
\NormalTok{(}\DecValTok{1} \OperatorTok{+} \DecValTok{17}\NormalTok{) }\OperatorTok{*} \DecValTok{3}\OtherTok{ ::} \DataTypeTok{Nat}
\OtherTok{=} \DecValTok{54}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!}\NormalTok{ (}\DecValTok{1} \OperatorTok{+} \DecValTok{17}\NormalTok{) }\OperatorTok{*} \DecValTok{3}
\NormalTok{(}\DecValTok{128} \OtherTok{\textasciigrave{}Div\textasciigrave{}} \DecValTok{8}\NormalTok{) }\OperatorTok{\^{}} \DecValTok{2}\OtherTok{ ::} \DataTypeTok{Nat}
\OtherTok{=} \DecValTok{256}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!}\NormalTok{ (}\DecValTok{128} \OtherTok{\textasciigrave{}Div\textasciigrave{}} \DecValTok{8}\NormalTok{) }\OperatorTok{\^{}} \DecValTok{2}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

\hypertarget{lists}{%
\subsection{Lists}\label{lists}}

Imagine lists were defined as library code, without any special syntax.
They'd have the definition

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{ [a]}
  \OtherTok{=}\NormalTok{ []}
  \OperatorTok{|}\NormalTok{ a }\OperatorTok{:}\NormalTok{ [a]}
\end{Highlighting}
\end{Shaded}

And in fact, this is exactly what the promoted data constructors of
lists look like. When \texttt{-XDataKinds} is enabled, we get the
following promoted data constructors in scope:

\begin{itemize}
\tightlist
\item
  \texttt{\textquotesingle{}{[}{]}} of kind \texttt{{[}a{]}}

  \begin{itemize}
  \tightlist
  \item
    \texttt{\textquotesingle{}(:)} of kind
    \texttt{a\ -\textgreater{}\ {[}a{]}\ -\textgreater{}\ {[}a{]}}; used
    infix as \texttt{x\ \textquotesingle{}:\ xs}
  \end{itemize}
\end{itemize}

Note that although we haven't yet talked about kind-level polymorphism
(things of kind \texttt{a}), it is meaningful and corresponds exactly to
your intuition about how polymorphism should behave.

When compared against the data constructors of lists,
\VERB|\NormalTok{[]}\OtherTok{ ::}\NormalTok{ [a]}| and
\VERB|\OtherTok{(:) ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ [a]}|,
with a little concentration, the promoted data constructors should make
sense. Because lists' data constructors have symbolic names, they also
require \texttt{-XTypeOperators} enabled to be used. Don't worry though,
GHC will helpfully remind you if you forget.

There is another subtle point to be noted when dealing with list-kinds.
While \texttt{{[}Bool{]}} is of kind \texttt{Type} and describes a
term-level list of booleans, the type
\texttt{\textquotesingle{}{[}Bool{]}} is of kind \texttt{{[}Type{]}} and
describes a type-level list with one element (namely, the type
\texttt{Bool}.) Compare:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind [}\DataTypeTok{Bool}\NormalTok{]}
\NormalTok{[}\DataTypeTok{Bool}\NormalTok{]}\OtherTok{ ::} \DataTypeTok{Type}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind }\CharTok{\textquotesingle{}[Bool]}
\CharTok{\textquotesingle{}[Bool] :: [Type]}
\end{Highlighting}
\end{Shaded}

Further care should be taken when constructing a promoted list; due to
the way GHC's lexer parses character literals
(\VERB|\CharTok{\textquotesingle{}a\textquotesingle{}}|), make sure you
add a space after starting a promoted list. While
\texttt{\textquotesingle{}{[}\ \textquotesingle{}True\ {]}} is fine,
\texttt{\textquotesingle{}{[}\textquotesingle{}True{]}} is unfortunately
a parse error.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind }\CharTok{\textquotesingle{}[ \textquotesingle{}}\DataTypeTok{True}\NormalTok{ ]}
\CharTok{\textquotesingle{}[ \textquotesingle{}}\DataTypeTok{True}\NormalTok{ ]}\OtherTok{ ::}\NormalTok{ [}\DataTypeTok{Bool}\NormalTok{]}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind }\CharTok{\textquotesingle{}[\textquotesingle{}}\DataTypeTok{True}\NormalTok{]}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

This quirk of the lexer often bites beginners---if you get an unexpected
syntax error when dealing with type-level literals, it's likely caused
by this.

\hypertarget{tuples}{%
\subsection{Tuples}\label{tuples}}

Tuples also promote in a straightforward way, via the
\texttt{\textquotesingle{}(,)} constructor.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind }\CharTok{\textquotesingle{}(2, "tuple")}
\CharTok{\textquotesingle{}(2, "tuple") :: (Nat, Symbol)}
\end{Highlighting}
\end{Shaded}

Tuples are promoted with a leading tick. The aforementioned parsing
gotcha applies here as well, so be careful.

\hypertarget{type-level-functions}{%
\section{Type-Level Functions}\label{type-level-functions}}

Where \texttt{-XDataKinds} really begins to shine, however, is through
the introduction of closed type families. You can think of closed type
families as \emph{functions at the type-level.} In fact, we've looked at
quite a few in this chapter already. Each of those ``primitives'' I
mentioned earlier---\texttt{CmpSymbol}, \texttt{Div}, and etc.---are all
closed type families.

The ability to write closed type families isn't merely one bestowed upon
GHC developers, however. We are capable of writing our own too! But
first, compare the regular, term-level function \VERB|\FunctionTok{or}|,
which computes the boolean OR of two \texttt{Bool}s:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{or}\OtherTok{ ::} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\FunctionTok{or} \DataTypeTok{True}\NormalTok{  \_ }\OtherTok{=} \DataTypeTok{True}
\FunctionTok{or} \DataTypeTok{False}\NormalTok{ y }\OtherTok{=}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}

Unlike data constructors, we're unfortunately unable to automatically
promote term-level functions into type-level ones. However, after
enabling \texttt{-XTypeFamilies}, we can instead ``promote''
\VERB|\FunctionTok{or}| by explicitly duplicating this logic and writing
a completely separate, closed type family.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{family} \DataTypeTok{Or}\NormalTok{ (}\OtherTok{x ::} \DataTypeTok{Bool}\NormalTok{) (}\OtherTok{y ::} \DataTypeTok{Bool}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{Bool} \KeywordTok{where}
  \DataTypeTok{Or} \DataTypeTok{\textquotesingle{}True}\NormalTok{  y }\OtherTok{=} \DataTypeTok{\textquotesingle{}True}
  \DataTypeTok{Or} \DataTypeTok{\textquotesingle{}False}\NormalTok{ y }\OtherTok{=}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}

Line for line, \VERB|\FunctionTok{or}| and \texttt{Or} are analogous.
The closed type family \texttt{Or} requires a capital letter for the
beginning of its name, because it exists at the type-level, and besides
having a more verbose kind signature, the two definitions proceed almost
exactly in lockstep.

\begin{verbatim}
Write a closed type family to compute `Not`.
\end{verbatim}

\begin{verbatim}
  [code/Kinds.hs:Not](Snip)
\end{verbatim}

While the metaphor between type families and functions is enticing, it
isn't entirely \emph{correct.} The analogues break down in several ways,
but the most important one is that \emph{type families must be
saturated.} Another way of saying this is that all of a type family's
parameters must be specified simultaneously; there is no currying
available.

Recall the \VERB|\FunctionTok{map}| function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{map}\OtherTok{ ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ [b]}
\FunctionTok{map}\NormalTok{ \_ []       }\OtherTok{=}\NormalTok{ []}
\FunctionTok{map}\NormalTok{ f (a }\OperatorTok{:}\NormalTok{ as) }\OtherTok{=}\NormalTok{ f a }\OperatorTok{:} \FunctionTok{map}\NormalTok{ f as}
\end{Highlighting}
\end{Shaded}

We're capable of promoting \VERB|\FunctionTok{map}| to the type-level:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{family} \DataTypeTok{Map}\NormalTok{ (}\OtherTok{x ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) (}\OtherTok{i ::}\NormalTok{ [a])}\OtherTok{ ::}\NormalTok{ [b] }\KeywordTok{where}
  \DataTypeTok{Map}\NormalTok{ f }\CharTok{\textquotesingle{}[]       = \textquotesingle{}}\NormalTok{[]}
  \DataTypeTok{Map}\NormalTok{ f (x }\CharTok{\textquotesingle{}: xs) = f x \textquotesingle{}}\OperatorTok{:} \DataTypeTok{Map}\NormalTok{ f xs}
\end{Highlighting}
\end{Shaded}

But because we're unable to partially apply closed type families,
\texttt{Map} doesn't turn out to be particularly useful.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{@}\KeywordTok{import} \DataTypeTok{Data.Proxy}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

This error is trying to tell us is that we used the \texttt{Or} closed
type-family without first saturating it---we only passed it one
parameter instead of the two it requires, and so unfortunately GHC
refuses to compile this program.

There is nothing preventing us from writing \texttt{Map}, but its
usefulness in this form is severely limited. We are simply unable to
curry closed type families, and so we can't use \texttt{Map} to perform
any interesting type-level computations for us. We will later explore
some techniques for working around this unfortunate limitation when we
discuss \emph{first class families} in chapter 10.

Before leaving this topic, let's look again at our definition of
\texttt{Or}. Pay close attention to its kind signature. We write it as
\texttt{Or\ (x\ ::}Bool\texttt{)\ (y\ ::}Bool\texttt{)\ ::}Bool\texttt{,\ rather\ than\ \textasciigrave{}Or\ x\ y\ ::\ \textasciigrave{}Bool\ -\textgreater{}\ Bool\ -\textgreater{}\ Bool}.
The kinds of type families are tricky beasts; the kind you write after
the \texttt{::} is the kind of the type \emph{returned} by the type
family, \emph{not} the kind of the type family itself.

\href{Snip}{code/Kinds.hs:Foo} \href{Snip}{code/Kinds.hs:Bar}

Take a moment to think about the kinds of \texttt{Foo} and \texttt{Bar}.
While \texttt{Foo} has kind
\texttt{Bool\ -\textgreater{}\ Bool\ -\textgreater{}\ Bool},
\texttt{Bar} has kind
\texttt{Type\ -\textgreater{}\ Type\ -\textgreater{}\ Bool\ -\textgreater{}\ Bool\ -\textgreater{}\ Bool}.
GHCi agrees with our assessment:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind }\DataTypeTok{Foo}
\DataTypeTok{Foo}\OtherTok{ ::} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind }\DataTypeTok{Bar}
\DataTypeTok{Bar}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\end{Highlighting}
\end{Shaded}

We will discuss type families in more generality in a later chapter; for
now it's sufficient to think of closed type families as type-level
functions.

\hypertarget{variance}{%
\chapter{Variance}\label{variance}}

Consider the following type declarations. Which of them have viable
\texttt{Functor} instances?

\href{Snip}{code/PosNeg.hs:T1} \href{Snip}{code/PosNeg.hs:T2}
\href{Snip}{code/PosNeg.hs:T3} \href{Snip}{code/PosNeg.hs:T4}
\href{Snip}{code/PosNeg.hs:T5}

\begin{verbatim}
Which of these types are `Functor`s? Give instances for the ones that are.
\end{verbatim}

\begin{verbatim}
  Only `T1` and `T5` are `Functor`s.

[code/PosNeg.hs:FunctorT1](Snip)
[code/PosNeg.hs:FunctorT5](Snip)
\end{verbatim}

Despite all of their similarities, only \texttt{T1} and \texttt{T5} are
\texttt{Functor}s. The reason behind this is one of variance: if we can
transform an \texttt{a} into a \texttt{b}, does that mean we can
necessarily transform a \texttt{T\ a} into a \texttt{T\ b}?

As it happens, we can sometimes do this, but it has a great deal to do
with what \texttt{T} looks like. Depending on the shape of \texttt{T}
(of kind \texttt{Type\ -\textgreater{}\ Type}) there are three
possibilities for \texttt{T}'s variance:

\begin{itemize}
\tightlist
\item
  Covariant: Any function \texttt{a\ -\textgreater{}\ b} can be lifted
  into a function \texttt{T\ a\ -\textgreater{}\ T\ b}.

  \begin{itemize}
  \tightlist
  \item
    Contravariant: Any function \texttt{a\ -\textgreater{}\ b} can be
    lifted into a function \texttt{T\ b\ -\textgreater{}\ T\ a}.
  \item
    Invariant: In general, functions \texttt{a\ -\textgreater{}\ b}
    cannot be lifted into a function over \texttt{T\ a}.
  \end{itemize}
\end{itemize}

Covariance is the sort we're most familiar with---it corresponds
directly to \texttt{Functor}s. And in fact, the type of
\VERB|\FunctionTok{fmap}| is exactly witness to this ``lifting'' motion
\texttt{(a\ -\textgreater{}\ b)\ -\textgreater{}\ T\ a\ -\textgreater{}\ T\ b}.
A type \texttt{T} is a \texttt{Functor} if and only if it is covariant.

Before we get to when is a type covariant, let's first look at
contravariance and invariance.

The \texttt{contravariant}({\textbf{???}}) and
\texttt{invariant}({\textbf{???}}) packages, both by Ed Kmett, give us
access to the \texttt{Contravariant} and \texttt{Invariant} classes.
These classes are to their sorts of variance as \texttt{Functor} is to
covariance.

A contravariant type allows you to map a function \emph{backwards}
across its type constructor.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Contravariant}\NormalTok{ f }\KeywordTok{where}
\OtherTok{  contramap ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f b }\OtherTok{{-}\textgreater{}}\NormalTok{ f a}
\end{Highlighting}
\end{Shaded}

On the other hand, an invariant type \texttt{T} allows you to map from
\texttt{a} to \texttt{b} if and only if \texttt{a} and \texttt{b} are
isomorphic. In a very real sense, this isn't an interesting
property---an isomorphism between \texttt{a} and \texttt{b} means
they're already the same thing to begin with.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Invariant}\NormalTok{ f }\KeywordTok{where}
\OtherTok{  invmap ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ (b }\OtherTok{{-}\textgreater{}}\NormalTok{ a) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}
\end{Highlighting}
\end{Shaded}

The variance of a type \texttt{T\ a} with respect to its type variable
\texttt{a} is fully specified by whether \texttt{a} appears solely in
positive position, solely in negative position or in a mix of both.

Type variables which appear exclusively in positive position are
covariant. Those exclusively in negative position are contravariant. And
type variables which find themselves in both become invariant.

But what \emph{is} a positive or negative position? Recall that all
types have a canonical representation expressed as some combination of
\texttt{(,)}, \texttt{Either} and \texttt{(-\textgreater{})}. We can
therefore define positive and negative positions in terms of these
fundamental building blocks, and develop our intuition afterwards.

Type

Position of

\texttt{a}

\texttt{b}

\texttt{Either\ a\ b}

\(+\)

\(+\)

\texttt{(a,\ b)}

\(+\)

\(+\)

\texttt{a\ -\textgreater{}\ b}

\(-\)

\(+\)

The conclusion is clear---our only means of introducing type variables
in negative position is to put them on the left-side of an arrow. This
should correspond to your intuition that the type of a function goes
``backwards'' when pre-composed with another function.

In the following example, pre-composing with
\VERB|\FunctionTok{show}\OtherTok{ ::} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{String}|
transforms a type \texttt{String\ -\textgreater{}\ {[}String{]}} into
\texttt{Bool\ -\textgreater{}\ {[}String{]}}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\FunctionTok{words}
\FunctionTok{words}\OtherTok{ ::} \DataTypeTok{String} \OtherTok{{-}\textgreater{}}\NormalTok{ [}\DataTypeTok{String}\NormalTok{]}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t}\OtherTok{ show ::} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{String}
\FunctionTok{show}\OtherTok{ ::} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{String}\OtherTok{ ::} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{String}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\FunctionTok{words} \OperatorTok{.}\NormalTok{ (}\FunctionTok{show}\OtherTok{ ::} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{String}\NormalTok{)}
\FunctionTok{words} \OperatorTok{.}\NormalTok{ (}\FunctionTok{show}\OtherTok{ ::} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{String}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}}\NormalTok{ [}\DataTypeTok{String}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Mathematically, things are often called ``positive'' and ``negative'' if
their signs follow the usual laws of multiplication. That is to say, a
positive multiplied by a positive remains positive, a negative
multiplied with a positive is a negative, and so on.

Variances are no different. To illustrate, consider the type
\texttt{(a,\ Bool)\ -\textgreater{}\ Int}. The \texttt{a} in the subtype
\texttt{(a,\ Bool)} is in positive position, but \texttt{(a,\ Bool)} is
in negative position relative to
\texttt{(a,\ Bool)\ -\textgreater{}\ Int}. As we remember from early
arithmetic in school, a positive times a negative is negative, and so
\texttt{(a,\ Bool)\ -\textgreater{}\ Int} is contravariant with respect
to \texttt{a}.

This relationship can be expressed with a simple table---but again, note
that the mnemonic suggested by the name of positive and negative
positions should be enough to commit this table to memory.

\texttt{a}

\texttt{b}

\(`a` \circ `b`\)

\(+\)

\(+\)

\(+\)

\(+\)

\(-\)

\(-\)

\(-\)

\(+\)

\(-\)

\(-\)

\(-\)

\(+\)

We can use this knowledge to convince ourselves why \texttt{Functor}
instances exist only for the \texttt{T1} and \texttt{T5} types defined
above.

\begin{verbatim}
  `T1`  &\cong  `Int -> `\posp{`a`} & \possym &= \possym
  `T2`  &\cong  \negp{`a`}` -> Int` & \negsym &= \negsym
  `T3`  &\cong  \negp{`a`}` -> `\posp{`a`} & \pmsym &= \pmsym
  `T4`  &\cong  \negp{`(Int -> `\posp{`a`}`)`}` -> Int` & \negsym\circ\possym &= \negsym
  `T5`  &\cong  \negp{`(`\negp{`a`}` -> Int)`}` -> Int` & \negsym\circ\negsym &= \possym
\end{verbatim}

This analysis also shows us that \texttt{T2} and \texttt{T4} have
\texttt{Contravariant} instances, and \texttt{T3} has an
\texttt{Invariant} one.

A type's variance also has a more concrete interpretation: variables in
positive position are \emph{produced} or \emph{owned}, while those in
negative position are \emph{consumed}. Products, sums and the right-side
of an arrow are all pieces of data that already exist or are produced,
but the type on the left-side of an arrow is indeed consumed.

There are some special names for types with multiple type variables. A
type that is covariant in two arguments (like \texttt{Either} and
\texttt{(,)}) is called a bifunctor. A type that is contravariant in its
first argument, but covariant in its second (like
\texttt{(-\textgreater{})}) is known as a profunctor. As you might
imagine, Ed Kmett has packages which provide both of these
typeclasses---although \texttt{Bifunctor} now exists in \texttt{base}.

Positional analysis like this is a powerful tool---it's quick to
eyeball, and lets you know at a glance which class instances you need to
provide. Better yet, it's impressive as hell to anyone who doesn't know
the trick.

\hypertarget{working-with-types}{%
\chapter{Working with Types}\label{working-with-types}}

\hypertarget{type-scoping}{%
\section{Type Scoping}\label{type-scoping}}

Haskell uses (a generalization of) the Hindley--Milner type system. One
of Hindley--Milner's greatest contributions is its ability to infer the
types of programs---without needing any explicit annotations. The result
is that term-level Haskell programmers rarely need to pay much attention
to types. It's often enough to just annotate the top-level declarations.
And even then, this is done more for our benefit than the compiler's.

This state of affairs is ubiquitous and the message it sends is loud and
clear: ``types are something we need not think much about''.
Unfortunately, such an attitude on the language's part is not
particularly helpful for the type-level programmer. It often goes
wrong---consider the following function, which doesn't compile
\emph{because} of its type annotation:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{broken ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ b}
\NormalTok{broken f a }\OtherTok{=}\NormalTok{ apply}
  \KeywordTok{where}
\OtherTok{    apply ::}\NormalTok{ b}
\NormalTok{    apply }\OtherTok{=}\NormalTok{ f a}
\end{Highlighting}
\end{Shaded}

The problem with \VERB|\NormalTok{broken}| is that, despite all
appearances, the type \texttt{b} in \VERB|\NormalTok{apply}| is not the
same \texttt{b} in \VERB|\NormalTok{broken}|. Haskell thinks it knows
better than us here, and introduces a new type variable for
\VERB|\NormalTok{apply}|. The result of this is effectively as though we
had instead written the following:

!snipRename\{Misc\}\{brokenWhy\}

Hindley--Milner seems to take the view that types should be ``neither
seen nor heard,'' and an egregious consequence of this is that type
variables have no notion of scope. This is why the example fails to
compile---in essence we've tried to reference an undefined variable, and
Haskell has ``helpfully'' created a new one for us. The Haskell Report
provides us with no means of referencing type variables outside of the
contexts in which they're declared.

There are several language extensions which can assuage this pain, the
most important one being \texttt{-XScopedTypeVariables}. When enabled,
it allows us to bind type variables and refer to them later. However,
this behavior is only turned on for types that begin with an explicit
\VERB|\KeywordTok{forall}| quantifier. For example, with
\texttt{-XScopedTypeVariables}, \VERB|\NormalTok{broken}| is still
broken, but the following works:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{working ::} \KeywordTok{forall}\NormalTok{ a b}\OperatorTok{.}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ b}
\NormalTok{working f a }\OtherTok{=}\NormalTok{ apply}
  \KeywordTok{where}
\OtherTok{    apply ::}\NormalTok{ b}
\NormalTok{    apply }\OtherTok{=}\NormalTok{ f a}
\end{Highlighting}
\end{Shaded}

The \VERB|\KeywordTok{forall}\NormalTok{ a b}\OperatorTok{.}| quantifier
introduces a type scope, and exposes the type variables \texttt{a} and
\texttt{b} to the remainder of the function's definition. This allows us
to reuse \texttt{b} when adding the type signature to
\VERB|\NormalTok{apply}|, rather than introducing a \emph{new} type
variable as it did before.

\texttt{-XScopedTypeVariables} lets us talk about types, but we are
still left without a good way of \emph{instantiating} types. If we
wanted to specialize \VERB|\FunctionTok{fmap}| to \texttt{Maybe}, for
example, the only solution sanctioned by the Haskell Report is to add an
inline type signature.

If we wanted to implement a function that provides a \texttt{String}
corresponding to a type's name, it's unclear how we could do such a
thing. By default, we have no way to explicitly pass type information,
and so even \emph{calling} such a function would be difficult.

Some older libraries often use a \texttt{Proxy} parameter in order to
help with these problems. Its definition is this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Proxy}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Proxy}
\end{Highlighting}
\end{Shaded}

In terms of value-level information content, \texttt{Proxy} is exactly
equivalent to the unit type \texttt{()}. But it also has a phantom type
parameter \texttt{a}, whose only purpose is to allow users to keep track
of a type, and pass it around like a value.

For example, the module \texttt{Data.Typeable} provides a mechanism for
getting information about types at runtime. This is the function
\VERB|\NormalTok{typeRep}|, whose type is
\texttt{Typeable\ a\ =\textgreater{}\ Proxy\ a\ -\textgreater{}\ TypeRep}.
Again, the \texttt{Proxy}'s only purpose is to let
\VERB|\NormalTok{typeRep}| know which type representation we're looking
for. As such, \VERB|\NormalTok{typeRep}| has to be called as
\VERB|\NormalTok{typeRep (}\DataTypeTok{Proxy}\OtherTok{ ::} \DataTypeTok{Proxy} \DataTypeTok{Bool}\NormalTok{)}|.

\hypertarget{type-applications}{%
\section{Type Applications}\label{type-applications}}

Clearly, Haskell's inability to directly specify types has ugly
user-facing ramifications. The extension \texttt{-XTypeApplications}
patches this glaring issue in the language.

\texttt{-XTypeApplications}, as its name suggests, allows us to directly
apply types to expressions. By prefixing a type with an
\VERB|\OperatorTok{@}|, we can explicitly fill in type variables. This
can be demonstrated in GHCi:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{set }\OperatorTok{{-}}\DataTypeTok{XTypeApplications}
\FunctionTok{fmap}\OtherTok{ ::} \DataTypeTok{Functor}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\FunctionTok{fmap}
\FunctionTok{fmap} \OperatorTok{@}\DataTypeTok{Maybe}\OtherTok{ ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ b}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\FunctionTok{fmap} \OperatorTok{@}\DataTypeTok{Maybe}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

While \VERB|\FunctionTok{fmap}| lifts a function over any functor
\texttt{f}, \VERB|\FunctionTok{fmap} \OperatorTok{@}\DataTypeTok{Maybe}|
lifts a function over \texttt{Maybe}. We've applied the type
\texttt{Maybe} to the polymorphic function \VERB|\FunctionTok{fmap}| in
the same way we can apply value arguments to functions.

There are two rules to keep in mind when thinking about type
applications. The first is that types are applied in the same order they
appear in a type signature---including its context and
\VERB|\KeywordTok{forall}| quantifiers. This means that applying a type
\texttt{Int} to \texttt{a\ -\textgreater{}\ b\ -\textgreater{}\ a}
results in \texttt{Int\ -\textgreater{}\ b\ -\textgreater{}\ Int}. But
type applying it to
\texttt{forall\ b\ a.\ a\ -\textgreater{}\ b\ -\textgreater{}\ a} is in
fact \texttt{a\ -\textgreater{}\ Int\ -\textgreater{}\ a}.

Recall that typeclass methods have their context at the beginning of
their type signature. \VERB|\FunctionTok{fmap}|, for example, has type
\texttt{Functor\ f\ =\textgreater{}\ (a\ -\textgreater{}\ b)\ -\textgreater{}\ f\ a\ -\textgreater{}\ f\ b}.
This is why we were able to fill in the functor parameter of
\VERB|\FunctionTok{fmap}|---because it comes first!

The second rule of type applications is that you can avoid applying a
type with an underscore:
\VERB|\OperatorTok{@}\NormalTok{\textbackslash{}\_}|. This means we can
also specialize type variables which are not the first in line. Looking
again at GHCi, we can type apply \VERB|\FunctionTok{fmap}|'s \texttt{a}
and \texttt{b} parameters while leaving \texttt{f} polymorphic:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\FunctionTok{fmap}
\FunctionTok{fmap}\OtherTok{ ::} \DataTypeTok{Functor}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\FunctionTok{fmap} \OperatorTok{@}\NormalTok{\_ }\OperatorTok{@}\DataTypeTok{Int} \OperatorTok{@}\DataTypeTok{Bool}
\FunctionTok{fmap} \OperatorTok{@}\NormalTok{\_ }\OperatorTok{@}\DataTypeTok{Int} \OperatorTok{@}\DataTypeTok{Bool}\OtherTok{ ::} \DataTypeTok{Functor}\NormalTok{ \_ }\OtherTok{=\textgreater{}}\NormalTok{ (}\DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}\NormalTok{) }\OtherTok{{-}\textgreater{}}\NormalTok{ \_ }\DataTypeTok{Int} \OtherTok{{-}\textgreater{}}\NormalTok{ \_ }\DataTypeTok{Bool}
\end{Highlighting}
\end{Shaded}

Because types are applied in the order they're defined, in the presence
of \texttt{-XTypeApplications} types become part of a public signature.
Changing the order of type variables can break downstream code, so be
careful when performing refactors of this nature.

Pay attention to type order whenever you write a function that might be
type applied. As a guiding principle, the hardest types to infer must
come first. This will often require using \texttt{-XScopedTypeVariables}
and an explicitly scoped \VERB|\KeywordTok{forall}|.

\texttt{-XTypeApplications} and \texttt{-XScopedTypeVariables} are the
two most fundamental extensions in a type-programmer's toolbox. They go
together hand in hand.

\hypertarget{ambiguous-types}{%
\section{Ambiguous Types}\label{ambiguous-types}}

Returning again to the example of \texttt{Data.Typeable}'s
\texttt{typeRep} function, we can use it to implement a function that
will give us the name of a type. And we can do so without requiring the
\VERB|\DataTypeTok{Proxy}| parameter.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{typeName ::} \KeywordTok{forall}\NormalTok{ a}\OperatorTok{.} \DataTypeTok{Typeable}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{String} \annotate{1}
\NormalTok{typeName }\OtherTok{=} \FunctionTok{show} \OperatorTok{.}\NormalTok{ typeRep }\OperatorTok{$} \DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{a  }\annotate{2}
\end{Highlighting}
\end{Shaded}

There are two interesting things to note in \VERB|\NormalTok{typeName}|.
At \ann{2}, \VERB|\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{a}| is
written as shorthand for
\VERB|\DataTypeTok{Proxy}\OtherTok{ ::} \DataTypeTok{Proxy}\NormalTok{ a}|---this
is because the \VERB|\DataTypeTok{Proxy}| data constructor has type
\texttt{Proxy\ t}. The type variable \texttt{t} here is the first one in
its type signature, so we're capable of type applying it. Type
applications aren't reserved for functions, they can be used anywhere
types are present.

At \ann{1} we see that the type \texttt{a} doesn't actually appear to
the right of the fat context arrow (\VERB|\OtherTok{=\textgreater{}}|).
Because Hindley--Milner's type inference only works to the right of the
context arrow, it means the type parameter \texttt{a} in
\VERB|\NormalTok{typeName}| can never be correctly inferred. Haskell
refers to such a type as being ambiguous.

By default, Haskell will refuse to compile any programs with ambiguous
types. We can bypass this behavior by enabling the aptly-named
\texttt{-XAllowAmbiguousTypes} extension anywhere we'd like to define
one. Actually \emph{using} code that has ambiguous types, will require
\texttt{-XTypeApplications}.

The two extensions are thus either side of the same coin.
\texttt{-XAllowAmbiguousTypes} allows us to define ambiguously typed
functions, and \texttt{-XTypeApplications} enables us to call them.

We can see this for ourselves. By enabling
\texttt{-XAllowAmbiguousTypes}, we can compile
\VERB|\NormalTok{typeName}| and play with it.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{set }\OperatorTok{{-}}\DataTypeTok{XTypeApplications}
\StringTok{"Bool"}


\OperatorTok{\textgreater{}}\NormalTok{ typeName }\OperatorTok{@}\DataTypeTok{Bool}
\StringTok{"[Char]"}


\OperatorTok{\textgreater{}}\NormalTok{ typeName }\OperatorTok{@}\DataTypeTok{String}
\StringTok{"Maybe [Int]"}


\OperatorTok{\textgreater{}}\NormalTok{ typeName }\OperatorTok{@}\NormalTok{(}\DataTypeTok{Maybe}\NormalTok{ [}\DataTypeTok{Int}\NormalTok{])}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

Though this is a silly example, ambiguous types are very useful when
doing type-level programming. Often we'll want to get our hands on a
term-level representation of types---think about drawing a picture of a
type, or about a program that will dump a schema of a type. Such a
function is almost always going to be ambiguously typed, as we'll see
soon.

However, ambiguous types aren't always this obvious to spot. To compare,
let's look at a surprising example. Consider the following type family:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{family} \DataTypeTok{AlwaysUnit}\NormalTok{ a }\KeywordTok{where}
  \DataTypeTok{AlwaysUnit}\NormalTok{ a }\OtherTok{=}\NormalTok{ ()}
\end{Highlighting}
\end{Shaded}

Given this definition, are all of the following type signatures
non-ambiguous? Take a second to think through each example.

\begin{itemize}
\tightlist
\item
  \texttt{AlwaysUnit\ a\ -\textgreater{}\ a}

  \begin{itemize}
  \tightlist
  \item
    \texttt{b\ -\textgreater{}\ AlwaysUnit\ a\ -\textgreater{}\ b}
  \item
    \texttt{Show\ a\ =\textgreater{}\ AlwaysUnit\ a\ -\textgreater{}\ String}
  \end{itemize}
\end{itemize}

The third example here is, in fact, ambiguous. But why? The problem is
that it's not clear which \texttt{Show\ a} instance we're asking for!
Even though there is an \texttt{a} in
\VERB|\DataTypeTok{Show}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{AlwaysUnit}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{String}|,
we're unable to access it---\texttt{AlwaysUnit\ a} is equal to
\texttt{()} for all \texttt{a}s!

More specifically, the issue is that \texttt{AlwaysUnit} doesn't have an
inverse; there's no \texttt{Inverse} type family such that
\texttt{Inverse\ (AlwaysUnit\ a)} equals \texttt{a}. In mathematics,
this lack of an inverse is known as non-injectivity.

Because \texttt{AlwaysUnit} is non-injective, we're unable to learn what
\texttt{a} is, given \texttt{AlwaysUnit\ a}.

Consider an analogous example from cryptography; just because you know
the hash of someone's password is \VERB|\NormalTok{1234567890abcdef}|
doesn't mean you know what the password is; any good hashing function,
like \texttt{AlwaysUnit}, is \emph{one way}. Just because we can go
forwards doesn't mean we can also come back again.

The solution to non-injectivity is to give GHC some other way of
determining the otherwise ambiguous type. This can be done like in our
examples by adding a \texttt{Proxy\ a} parameter whose only purpose is
to drive inference, or it can be accomplished by enabling
\texttt{-XAllowAmbiguousTypes} at the definition site, and using
\texttt{-XTypeApplications} at the call-site to fill in the ambiguous
parameter manually.

\hypertarget{constraints-and-gadts}{%
\chapter{Constraints and GADTs}\label{constraints-and-gadts}}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

\texttt{Constraint}s are odd. They don't behave like \texttt{Type}s nor
like promoted data kinds. They are a fundamentally different thing
altogether, and thus worth studying.

The \texttt{Constraint} kind is reserved for things that can appear on
the left side of the fat context arrow
(\VERB|\OtherTok{=\textgreater{}}|). This includes fully-saturated
typeclasses (like \texttt{Show\ a}), tuples of other
\texttt{Constraint}s, and type equalities
(\texttt{Int\ \textasciitilde{}\ a}.) We will discuss type equalities in
a moment.

Typeclass constraints are certainly the most familiar. We use them all
the time, even when we are not writing type-level Haskell. Consider the
equality function
\VERB|\OtherTok{(==) ::} \DataTypeTok{Eq}\NormalTok{ a }\OtherTok{=\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}|.
Tuples of \texttt{Constraint}s are similarly well-known:
\VERB|\FunctionTok{sequenceA}\OtherTok{ ::}\NormalTok{ (}\DataTypeTok{Applicative}\NormalTok{ f, }\DataTypeTok{Traversable}\NormalTok{ t) }\OtherTok{=\textgreater{}}\NormalTok{ t (f a) }\OtherTok{{-}\textgreater{}}\NormalTok{ f (t a)}|.

Type equalities are more interesting, and are enabled via
\texttt{-XGADTs}. Compare the following two programs:

\href{Snip}{code/Constraints.hs:five}
\href{Snip}{code/Constraints.hs:five\_}

Both \VERB|\NormalTok{five}| and
\VERB|\NormalTok{five\textbackslash{}\_}| are identical as far as
Haskell is concerned. While \VERB|\NormalTok{five}| has type
\texttt{Int}, \VERB|\NormalTok{five\textbackslash{}\_}| has type
\texttt{a}, along with a constraint saying that \texttt{a} equals
\texttt{Int}. Of course, nobody would actually write
\texttt{five\textbackslash{}\_}, but it's a neat feature of the type
system regardless.

Type equalities form an equivalence relation, meaning that they have the
following properties:

\begin{itemize}
\tightlist
\item
  reflexivity---a type is always equal to itself:
  \texttt{a\ \textasciitilde{}\ a}

  \begin{itemize}
  \item
    \begin{description}
    \tightlist
    \item[symmetry---\texttt{a\ \textasciitilde{}\ b} holds if and only
    if `b]
    a`
    \end{description}
  \item
    \begin{description}
    \tightlist
    \item[transitivity---if we know both
    \texttt{a\ \textasciitilde{}\ b} and `b]
    c\texttt{,\ we\ (and\ GHC)\ can\ infer\ that}a \textasciitilde{} c`.
    \end{description}
  \end{itemize}
\end{itemize}

\hypertarget{gadts}{%
\section{GADTs}\label{gadts}}

Generalized algebraic datatypes (GADTs; pronounced ``gad-its'') are an
extension to Haskell's type system that allow explicit type signatures
to be written for data constructors. They, like type equality
constraints, are also enabled via \texttt{-XGADTs}.

The canonical example of a GADT is a type safe syntax tree. For example,
we can declare a small language with integers, booleans, addition,
logical negation, and if statements.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Expr}\NormalTok{ a }\KeywordTok{where}  \annotate{1}
  \DataTypeTok{LitInt}\OtherTok{  ::} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Expr} \DataTypeTok{Int}  \annotate{2}
  \DataTypeTok{LitBool}\OtherTok{ ::} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{Expr} \DataTypeTok{Bool}
  \DataTypeTok{Add}\OtherTok{     ::} \DataTypeTok{Expr} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Expr} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Expr} \DataTypeTok{Int}
  \DataTypeTok{Not}\OtherTok{     ::} \DataTypeTok{Expr} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{Expr} \DataTypeTok{Bool}
  \DataTypeTok{If}\OtherTok{      ::} \DataTypeTok{Expr} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{Expr}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Expr}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Expr}\NormalTok{ a  }\annotate{3}
\end{Highlighting}
\end{Shaded}

The \VERB|\KeywordTok{where}| at \ann{1} is what turns on GADT syntax
for the rest of the declaration. Each of \VERB|\DataTypeTok{LitInt}|,
\VERB|\DataTypeTok{LitBool}|, \VERB|\DataTypeTok{Add}|, etc. corresponds
to a data constructor of \texttt{Expr}. These constructors all take some
number of arguments before resulting in an \texttt{Expr}.

For example, \VERB|\DataTypeTok{LitInt}| at \ann{2} takes an
\texttt{Int} before returning a \texttt{Expr\ Int}. On the other hand,
the data constructor \VERB|\DataTypeTok{If}| at \ann{3} takes three
arguments (one \texttt{Expr\ Bool} and two \texttt{Expr\ a}s) and
returns an \texttt{Expr\ a}.

It is this ability to specify the return type that is of particular
interest.

You might be pleased that \texttt{Expr} is \emph{correct by
construction.} We are incapable of building a poorly-typed
\texttt{Expr}. While this might not sound immediately remarkable, it
is---we've reflected the \emph{typing rules of \texttt{Expr}} in the
type system of Haskell. For example, we're unable to build an AST which
attempts to add an \texttt{Expr\ Int} to a \texttt{Expr\ Bool}.

To convince ourselves that the type signatures written in GADT syntax
are indeed respected by the compiler, we can look in GHCi:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\DataTypeTok{LitInt}
\DataTypeTok{LitInt}\OtherTok{ ::} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Expr} \DataTypeTok{Int}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\DataTypeTok{If}
\DataTypeTok{If}\OtherTok{ ::} \DataTypeTok{Expr} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{Expr}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Expr}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Expr}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

Because GADTs allow us to specify a data constructor's type, we can use
them to \emph{constrain} a type variable in certain circumstances. Such
a thing is not possible otherwise.

The value of GADTs is that Haskell can use the knowledge of these
constrained types. In fact, we can use this to write a typesafe
evaluator over \texttt{Expr}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{evalExpr ::} \DataTypeTok{Expr}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a}
\NormalTok{evalExpr (}\DataTypeTok{LitInt}\NormalTok{ i)  }\OtherTok{=}\NormalTok{ i  }\annotate{1}
\NormalTok{evalExpr (}\DataTypeTok{LitBool}\NormalTok{ b) }\OtherTok{=}\NormalTok{ b  }\annotate{2}
\NormalTok{evalExpr (}\DataTypeTok{Add}\NormalTok{ x y)   }\OtherTok{=}\NormalTok{ evalExpr x }\OperatorTok{+}\NormalTok{ evalExpr y}
\NormalTok{evalExpr (}\DataTypeTok{Not}\NormalTok{ x)     }\OtherTok{=} \FunctionTok{not} \OperatorTok{$}\NormalTok{ evalExpr x}
\NormalTok{evalExpr (}\DataTypeTok{If}\NormalTok{ b x y)  }\OtherTok{=}
  \KeywordTok{if}\NormalTok{ evalExpr b}
     \KeywordTok{then}\NormalTok{ evalExpr x}
     \KeywordTok{else}\NormalTok{ evalExpr y}
\end{Highlighting}
\end{Shaded}

In just this amount of code, we have a fully functioning little language
and interpreter. Consider:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ evalExpr }\OperatorTok{.} \DataTypeTok{If}\NormalTok{ (}\DataTypeTok{LitBool} \DataTypeTok{False}\NormalTok{) (}\DataTypeTok{LitInt} \DecValTok{1}\NormalTok{) }\OperatorTok{.} \DataTypeTok{Add}\NormalTok{ (}\DataTypeTok{LitInt} \DecValTok{5}\NormalTok{) }\OperatorTok{$} \DataTypeTok{LitInt} \DecValTok{13}
\DecValTok{18}


\OperatorTok{\textgreater{}}\NormalTok{ evalExpr }\OperatorTok{.} \DataTypeTok{Not} \OperatorTok{$} \DataTypeTok{LitBool} \DataTypeTok{True}
\DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

Pay careful attention here! At \ann{1}, \VERB|\NormalTok{evalExpr}|
returns an \texttt{Int}, but at \ann{2} it returns a \texttt{Bool}! This
is possible because Haskell can \emph{reason} about GADTs. In the
\VERB|\DataTypeTok{LitInt}| case, the only way such a pattern could have
matched is if \texttt{a\ \textasciitilde{}\ Int}, in which case it's
certainly okay to return a \texttt{Int}. The reasoning for the other
patterns is similar; Haskell can use information from inside a pattern
match to drive type inference.

GADT syntax is indeed provided by \texttt{-XGADTs}, but it is not the
syntax that is fundamentally interesting. The extension is poorly
named---a more appropriate name might be ``\texttt{-XTypeEqualities}''.
In fact, GADTs are merely syntactic sugar over type equalities. We can
also declare \texttt{Expr} as a traditional Haskell datatype as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Expr\_}\NormalTok{ a}
  \OtherTok{=}\NormalTok{ (a }\OperatorTok{\textasciitilde{}} \DataTypeTok{Int}\NormalTok{)  }\OtherTok{=\textgreater{}} \DataTypeTok{LitInt\_}  \DataTypeTok{Int}
  \OperatorTok{|}\NormalTok{ (a }\OperatorTok{\textasciitilde{}} \DataTypeTok{Bool}\NormalTok{) }\OtherTok{=\textgreater{}} \DataTypeTok{LitBool\_} \DataTypeTok{Bool}
  \OperatorTok{|}\NormalTok{ (a }\OperatorTok{\textasciitilde{}} \DataTypeTok{Int}\NormalTok{)  }\OtherTok{=\textgreater{}} \DataTypeTok{Add\_}\NormalTok{ (}\DataTypeTok{Expr\_} \DataTypeTok{Int}\NormalTok{) (}\DataTypeTok{Expr\_} \DataTypeTok{Int}\NormalTok{)}
  \OperatorTok{|}\NormalTok{ (a }\OperatorTok{\textasciitilde{}} \DataTypeTok{Bool}\NormalTok{) }\OtherTok{=\textgreater{}} \DataTypeTok{Not\_}\NormalTok{ (}\DataTypeTok{Expr\_} \DataTypeTok{Bool}\NormalTok{)}
  \OperatorTok{|} \DataTypeTok{If\_}\NormalTok{ (}\DataTypeTok{Expr\_} \DataTypeTok{Bool}\NormalTok{) (}\DataTypeTok{Expr\_}\NormalTok{ a) (}\DataTypeTok{Expr\_}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

When viewed like this, it's a little easier to see what's happening
behind the scenes. Each data constructor of
\texttt{Expr\textbackslash{}\_} carries along with it a type equality
constraint. Like any constraint inside a data constructor, Haskell will
require the constraint to be proven when the data constructor is called.

As such, when we pattern match on a data constructor which contains a
constraint, this satisfied constraint \emph{comes back into scope.} That
is, a function of type \texttt{Expr\ a\ -\textgreater{}\ a} can return
an \texttt{Int} when pattern matching on \VERB|\DataTypeTok{LitInt}|,
but return a \texttt{Bool} when matching on
\VERB|\DataTypeTok{LitBool}|. The type equality constraining \texttt{a}
only comes back into scope after pattern matching on the data
constructor that contains it.

We will explore the technique of packing constraints inside data
constructors in much greater generality later.

Though GADT syntax doesn't offer anything novel, we will often use it
when defining complicated types. This is purely a matter of style as I
find it more readable.

\hypertarget{heterogeneous-lists}{%
\section{Heterogeneous Lists}\label{heterogeneous-lists}}

One of the primary motivations of GADTs is building inductive type-level
structures out of term-level data. As a working example for this
section, we can use GADTs to define a heterogeneous list---a list which
can store values of different types inside it.

To get a feel for what we'll build:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\DataTypeTok{HNil}
\DataTypeTok{HNil}\OtherTok{ ::} \DataTypeTok{HList} \CharTok{\textquotesingle{}[]}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\DataTypeTok{True} \OperatorTok{:\#} \DataTypeTok{HNil}
\DataTypeTok{True} \OperatorTok{:\#} \DataTypeTok{HNil}\OtherTok{ ::} \DataTypeTok{HList} \CharTok{\textquotesingle{}[Bool]}


\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ hlist }\OtherTok{=} \DataTypeTok{Just} \StringTok{"hello"} \OperatorTok{:\#} \DataTypeTok{True} \OperatorTok{:\#} \DataTypeTok{HNil}
\OtherTok{hlist ::} \DataTypeTok{HList} \CharTok{\textquotesingle{}[Maybe [Char], Bool]}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t hlist}
\DecValTok{2}


\OperatorTok{\textgreater{}}\NormalTok{ hLength hlist}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

The \VERB|\DataTypeTok{HNil}| constructor here is analogous to the
regular list constructor \VERB|\NormalTok{[]}|.
\VERB|\NormalTok{(}\OperatorTok{:}\NormalTok{\textbackslash{}}\OperatorTok{\#}\NormalTok{)}|
likewise corresponds to
\VERB|\NormalTok{(}\OperatorTok{:}\NormalTok{)}|. They're defined as a
GADT:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{HList}\NormalTok{ (}\OtherTok{ts ::}\NormalTok{ [}\DataTypeTok{Type}\NormalTok{]) }\KeywordTok{where} \annotate{1}
  \DataTypeTok{HNil}\OtherTok{ ::} \DataTypeTok{HList} \CharTok{\textquotesingle{}[]  {-}{-} ! 2}
\OtherTok{  (:\#) ::}\NormalTok{ t }\OtherTok{{-}\textgreater{}} \DataTypeTok{HList}\NormalTok{ ts }\OtherTok{{-}\textgreater{}} \DataTypeTok{HList}\NormalTok{ (t }\CharTok{\textquotesingle{}: ts)  {-}{-} ! 3}
\KeywordTok{infixr} \DecValTok{5} \OperatorTok{:\#}
\end{Highlighting}
\end{Shaded}

At \ann{1}, you'll notice that we've given \texttt{HList}'s \texttt{ts}
an explicit kind signature. The type parameter \texttt{ts} is defined to
have kind \texttt{{[}Type{]}}, because we'll store the contained types
inside of it. Although this kind signature isn't strictly
necessary---GHC will correctly infer it for us---your future self will
appreciate you having written it. A good rule of thumb is to annotate
\emph{every} kind if \emph{any} of them isn't \texttt{Type}.

\texttt{HList} is analogous to the familiar \texttt{{[}{]}} type, and so
it needs to define an empty list at \ann{2} called
\VERB|\DataTypeTok{HNil}|, and a cons operator at \ann{3} called
\VERB|\NormalTok{(}\OperatorTok{:}\NormalTok{\textbackslash{}}\OperatorTok{\#}\NormalTok{)}|.
These constructors have carefully chosen types.

\VERB|\DataTypeTok{HNil}| represents an empty \texttt{HList}. We can see
this by the fact that it takes nothing and gives back
\texttt{ts\ \textasciitilde{}\ \textquotesingle{}{[}{]}}---an empty list
of types.

The other data constructor,
\VERB|\NormalTok{(}\OperatorTok{:}\NormalTok{\textbackslash{}}\OperatorTok{\#}\NormalTok{)}|,
takes two parameters. Its first is of type \texttt{t}, and the second is
a \texttt{HList\ ts}. In response, it returns a
\texttt{HList\ (t\ \textquotesingle{}:\ ts)}---the result is this new
type has been consed onto the other \texttt{HList}.

This \texttt{HList} can be pattern matched over, just like we would with
regular lists. For example, we can implement a length function:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{hLength ::} \DataTypeTok{HList}\NormalTok{ ts }\OtherTok{{-}\textgreater{}} \DataTypeTok{Int}
\NormalTok{hLength }\DataTypeTok{HNil}      \OtherTok{=} \DecValTok{0}
\NormalTok{hLength (\_ }\OperatorTok{:\#}\NormalTok{ ts) }\OtherTok{=} \DecValTok{1} \OperatorTok{+}\NormalTok{ hLength ts}
\end{Highlighting}
\end{Shaded}

But, having this explicit list of types to work with, allows us to
implement much more interesting things. To illustrate, we can write a
\emph{total} \VERB|\FunctionTok{head}| function---something impossible
to do with traditional lists.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{hHead ::} \DataTypeTok{HList}\NormalTok{ (t }\CharTok{\textquotesingle{}: ts) {-}\textgreater{} t}
\NormalTok{hHead (t }\OperatorTok{:\#}\NormalTok{ \_) }\OtherTok{=}\NormalTok{ t}
\end{Highlighting}
\end{Shaded}

The oddities don't stop there. We can deconstruct any length-3
\texttt{HList} whose second element is a \texttt{Bool}, show it, and
have the compiler guarantee that this is an acceptable (if strange)
thing to do.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{showBool ::} \DataTypeTok{HList} \CharTok{\textquotesingle{}[\_1, Bool, \_2] {-}\textgreater{} String}
\NormalTok{showBool (\_ }\OperatorTok{:\#}\NormalTok{ b }\OperatorTok{:\#}\NormalTok{ \_ }\OperatorTok{:\#} \DataTypeTok{HNil}\NormalTok{) }\OtherTok{=} \FunctionTok{show}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

Unfortunately, GHC's stock deriving machinery doesn't play nicely with
GADTs---it will refuse to write \texttt{Eq}, \texttt{Show} or other
instances. But we can write our own by providing a base case (for
\VERB|\DataTypeTok{HNil}|), and an inductive case.

The base case is that two empty \texttt{HList}s are always equal.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Eq}\NormalTok{ (}\DataTypeTok{HList} \CharTok{\textquotesingle{}[]) where}
  \DataTypeTok{HNil} \OperatorTok{==} \DataTypeTok{HNil} \OtherTok{=} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

And inductively, two consed \texttt{HList}s are equal only if both their
heads and tails are equal.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{Eq}\NormalTok{ t, }\DataTypeTok{Eq}\NormalTok{ (}\DataTypeTok{HList}\NormalTok{ ts)) }\OtherTok{=\textgreater{}} \DataTypeTok{Eq}\NormalTok{ (}\DataTypeTok{HList}\NormalTok{ (t }\CharTok{\textquotesingle{}: ts)) where}
\NormalTok{  (a }\OperatorTok{:\#}\NormalTok{ as) }\OperatorTok{==}\NormalTok{ (b }\OperatorTok{:\#}\NormalTok{ bs) }\OtherTok{=}\NormalTok{ a }\OperatorTok{==}\NormalTok{ b }\OperatorTok{\&\&}\NormalTok{ as }\OperatorTok{==}\NormalTok{ bs}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Implement `Ord` for `HList`.
\end{verbatim}

\begin{verbatim}
[code/GADTs.hs:ordHNil](Snip)
[code/GADTs.hs:ordHCons](Snip)
\end{verbatim}

\begin{verbatim}
Implement `Show` for `HList`.
\end{verbatim}

\begin{verbatim}
[code/GADTs.hs:showHNil](Snip)
[code/GADTs.hs:showHCons](Snip)
\end{verbatim}

The reason we had to write two instances for \texttt{Eq} was to assert
that every element in the list also had an \texttt{Eq} instance. While
this works, it is rather unsatisfying. Alternatively, we can write a
closed type family which will fold \texttt{ts} into a big
\texttt{Constraint} stating each element has an \texttt{Eq}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{family} \DataTypeTok{AllEq}\NormalTok{ (}\OtherTok{ts ::}\NormalTok{ [}\DataTypeTok{Type}\NormalTok{])}\OtherTok{ ::} \DataTypeTok{Constraint} \KeywordTok{where}
  \DataTypeTok{AllEq} \CharTok{\textquotesingle{}[]       = ()  {-}{-} ! 1}
  \DataTypeTok{AllEq}\NormalTok{ (t }\CharTok{\textquotesingle{}: ts) = (Eq t, AllEq ts)  {-}{-} ! 2}
\end{Highlighting}
\end{Shaded}

As \texttt{AllEq} is our first example of a non-trivial closed type
family, we should spend some time analyzing it. \texttt{AllEq} performs
type-level pattern matching on a list of types, determining whether or
not it is empty.

If it is empty---line \ann{1}---we simply return the unit
\texttt{Constraint}. Note that because of the kind signature on
\texttt{AllEq}, Haskell interprets this as \texttt{Constraint} rather
than the unit \texttt{Type}.

However, if \VERB|\NormalTok{ts}| is a promoted list cons, we instead
construct a \texttt{Constraint}-tuple at \ann{2}. You'll notice that
\texttt{AllEq} is defined inductively, so it will eventually find an
empty list and terminate. By using the \texttt{:kind!} command in GHCi,
we can see what this type family expands to.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{AllEq} \CharTok{\textquotesingle{}[Int, Bool]}
\DataTypeTok{AllEq} \CharTok{\textquotesingle{}[Int, Bool] :: Constraint}
\OtherTok{=}\NormalTok{ (}\DataTypeTok{Eq} \DataTypeTok{Int}\NormalTok{, (}\DataTypeTok{Eq} \DataTypeTok{Bool}\NormalTok{,}\OtherTok{ () ::} \DataTypeTok{Constraint}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\texttt{AllEq} successfully folds \texttt{{[}Type{]}}s into a
\texttt{Constraint}. But there is nothing specific to \texttt{Eq} about
\texttt{AllEq}! Instead, it can be generalized into a fold over any
\texttt{Constraint} \texttt{c}. We will need \texttt{-XConstraintKinds}
in order to talk about polymorphic constraints.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{family} \DataTypeTok{All}\NormalTok{ (}\OtherTok{c ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Constraint}\NormalTok{)}
\NormalTok{                (}\OtherTok{ts ::}\NormalTok{ [}\DataTypeTok{Type}\NormalTok{])}\OtherTok{ ::} \DataTypeTok{Constraint} \KeywordTok{where}
  \DataTypeTok{All}\NormalTok{ c }\CharTok{\textquotesingle{}[]       = ()  {-}{-} ! 1}
  \DataTypeTok{All}\NormalTok{ c (t }\CharTok{\textquotesingle{}: ts) = (c t, All c ts)  {-}{-} ! 2}
\end{Highlighting}
\end{Shaded}

With \texttt{All}, we can now write our \texttt{Eq} instance more
directly.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{All} \DataTypeTok{Eq}\NormalTok{ ts }\OtherTok{=\textgreater{}} \DataTypeTok{Eq}\NormalTok{ (}\DataTypeTok{HList}\NormalTok{ ts) }\KeywordTok{where}
  \DataTypeTok{HNil}      \OperatorTok{==} \DataTypeTok{HNil}      \OtherTok{=} \DataTypeTok{True}
\NormalTok{  (a }\OperatorTok{:\#}\NormalTok{ as) }\OperatorTok{==}\NormalTok{ (b }\OperatorTok{:\#}\NormalTok{ bs) }\OtherTok{=}\NormalTok{ a }\OperatorTok{==}\NormalTok{ b }\OperatorTok{\&\&}\NormalTok{ as }\OperatorTok{==}\NormalTok{ bs}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Rewrite the `Ord` and `Show` instances in terms of `All`.
\end{verbatim}

\begin{verbatim}
[code/GADTs.hs:ordHList](Snip)
[code/GADTs.hs:showHList](Snip)
\end{verbatim}

\hypertarget{rank-n-types}{%
\chapter{Rank-N Types}\label{rank-n-types}}

\hypertarget{introduction-1}{%
\section{Introduction}\label{introduction-1}}

Sometimes Haskell's default notion of polymorphism simply isn't
polymorphic \emph{enough.} To demonstrate, consider a contrived function
which takes the
\VERB|\FunctionTok{id}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a}|
as an argument, and applies it to the number \VERB|\DecValTok{5}|. Our
first attempt might look something like this:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{applyToFive ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ a) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Int}
\NormalTok{applyToFive f }\OtherTok{=}\NormalTok{ f }\DecValTok{5}
\end{Highlighting}
\end{Shaded}

The reasoning here is that because \VERB|\FunctionTok{id}| has type
\texttt{a\ -\textgreater{}\ a}, \VERB|\NormalTok{applyToFive}| should
have type \texttt{(a\ -\textgreater{}\ a)\ -\textgreater{}\ Int}.
Unfortunately, Haskell disagrees with us when we try to compile this.

\begin{verbatim}
<interactive>:2:32: error:
    • Couldn't match expected type ‘a’ with actual type ‘Int’
\end{verbatim}

We can't apply \VERB|\NormalTok{f}| to \VERB|\DecValTok{5}| because, as
the error helpfully points out, \texttt{a} is not an \texttt{Int}.
Recall that under normal circumstances, the \emph{caller} of a
polymorphic function is responsible for choosing which concrete types
those variables get. The signature
\texttt{(a\ -\textgreater{}\ a)\ -\textgreater{}\ Int} promises that
\VERB|\NormalTok{applyToFive}| will happily take any function which
returns the same type it takes.

We wanted \VERB|\NormalTok{applyToFive}| to only be able to take
\VERB|\FunctionTok{id}| as a parameter, but instead we've written a
function which (if it compiled) would happily take any endomorphism.
Because the choice of \texttt{a} is at the mercy of the caller, Haskell
has no choice but to reject the above definition of
\VERB|\NormalTok{applyToFive}|---it would be a type error to try to
apply \VERB|\DecValTok{5}| to \VERB|\FunctionTok{not}|, for example.

And so we come to the inevitable conclusion that, as is so often the
case, the compiler is right and we (or at least, our type) is wrong. The
type of \VERB|\NormalTok{applyToFive}| simply doesn't have enough
polymorphism. But why not, and what can we do about it?

The discrepancy comes from a quirk of Haskell's syntax. By default, the
language will automatically quantify our type variables, meaning that
the type signature \texttt{a\ -\textgreater{}\ a} is really syntactic
sugar for \texttt{forall\ a.\ a\ -\textgreater{}\ a}. By enabling
\texttt{-XRankNTypes} we can write these desugared types explicitly.
Comparing \VERB|\FunctionTok{id}| and \VERB|\NormalTok{applyToFive}|
side-by-side is revealing.

\href{Snip}{code/RankN.hs:id}
\href{Snip}{code/RankN.hs:explicitBrokenApply}

Recall that we intended to give the type of \VERB|\FunctionTok{id}| for
the first parameter of \VERB|\NormalTok{applyToFive}|. However, due to
Haskell's implicit quantification of type variables, we were lead astray
in our attempts. This explains why \VERB|\NormalTok{applyToFive}| above
didn't compile.

The solution is easy: we simply need to move the
\VERB|\KeywordTok{forall}\NormalTok{ a}\OperatorTok{.}| part inside of
the parentheses.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{applyToFive ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ a}\OperatorTok{.}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Int}
\NormalTok{applyToFive f }\OtherTok{=}\NormalTok{ f }\DecValTok{5}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ applyToFive }\FunctionTok{id}
\DecValTok{5}
\end{Highlighting}
\end{Shaded}

In this chapter we will dive into what rank-n types are and what their
more interesting uses can do for us.

\hypertarget{ranks}{%
\section{Ranks}\label{ranks}}

The \texttt{-XRankNTypes} is best thought of as making polymorphism
\emph{first-class}. It allows us to introduce polymorphism anywhere a
type is allowed, rather than only on top-level bindings.

While relaxing this restriction is ``obviously a good thing'', it's not
without its sharp edges. In general, type inference is undecidable in
the presence of higher-rank polymorphism. Code that doesn't interact
with such things need not worry, but higher-rank polymorphism always
requires an explicit type signature.

But what exactly \emph{is} a rank?

In type-theory lingo, the rank of a function is the ``depth'' of its
polymorphism. A function that has no polymorphic parameters is rank 0.
However, most, if not all, polymorphic functions you're familiar
with---\VERB|\FunctionTok{const}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ b }\OtherTok{{-}\textgreater{}}\NormalTok{ a}|,
\VERB|\FunctionTok{head}\OtherTok{ ::}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ a}|,
etc---are rank 1.

The function \VERB|\NormalTok{applyToFive}| above is rank 2, because its
\VERB|\NormalTok{f}| parameter itself is rank 1. In principle there is
no limit to how high rank a function can be, but in practice nobody
seems to have gone above rank 3. And for good reason---higher-rank
functions quickly become unfathomable. Rather than explicitly counting
ranks, we usually call any function above rank-1 to be rank-n or higher
rank.

The intuition behind higher-rank types is that they are \emph{functions
which take callbacks}. The rank of a function is how often control gets
``handed off''. A rank-2 function will call a polymorphic function for
you, while a rank-3 function will run a callback which itself runs a
callback.

Because callbacks are used to transfer control from a called function
back to its calling context, there's a sort of a seesaw thing going on.
For example, consider an (arbitrarily chosen) rank-2 function
\texttt{foo\ ::\ forall\ r.\ (forall\ a.\ a\ -\textgreater{}\ r)\ -\textgreater{}\ r}.
As the caller of \VERB|\NormalTok{foo}|, we are responsible for
determining the instantiation of \texttt{r}. However, the
\emph{implementation} of \VERB|\NormalTok{foo}| gets to choose what type
\texttt{a} is. The callback you give it must work for whatever choice of
\texttt{a} it makes.

This is exactly why \VERB|\NormalTok{applyToFive}| works. Recall its
definition:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{applyToFive ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ a}\OperatorTok{.}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Int}
\NormalTok{applyToFive f }\OtherTok{=}\NormalTok{ f }\DecValTok{5}
\end{Highlighting}
\end{Shaded}

Notice that the implementation of \VERB|\NormalTok{applyToFive}| is what
calls \VERB|\NormalTok{f}|. Because \VERB|\NormalTok{f}| is rank-1 here,
\VERB|\NormalTok{applyToFive}| can instantiate it at \texttt{Int}.
Compare it with our broken implementation:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{applyToFive ::} \KeywordTok{forall}\NormalTok{ a}\OperatorTok{.}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ a) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Int}
\NormalTok{applyToFive f }\OtherTok{=}\NormalTok{ f }\DecValTok{5}
\end{Highlighting}
\end{Shaded}

Here, \VERB|\NormalTok{f}| is rank-0 because it is no longer
polymorphic---the caller of \texttt{applyToFive} has already
instantiated \texttt{a} by the time \texttt{applyToFive} gets access to
it---and as such, it's an error to apply it to \VERB|\DecValTok{5}|. We
have no guarantees that the caller decided
\texttt{a\ \textasciitilde{}\ Int}.

By pushing up the rank of \VERB|\NormalTok{applyToFive}|, we can delay
who gets to decide the type \texttt{a}. We move it from being the
caller's choice to being the \emph{callee's} choice.

Even higher-yet ranks also work in this fashion. The caller of the
function and the implementations seesaw between who is responsible for
instantiating the polymorphic types. We will look more deeply at these
sorts of functions later.

\hypertarget{the-nitty-gritty-details}{%
\section{The Nitty Gritty Details}\label{the-nitty-gritty-details}}

It is valuable to formalize exactly what's going on with this rank
stuff. More precisely, a function gains higher rank every time a
\VERB|\KeywordTok{forall}| quantifier exists on the left-side of a
function arrow.

But aren't \VERB|\KeywordTok{forall}| quantifiers \emph{always} on the
left-side of a function arrow? While it might seem that way, this is
merely a quirk of Haskell's syntax. Because the
\VERB|\KeywordTok{forall}| quantifier binds more loosely than the arrow
type \VERB|\NormalTok{(}\OtherTok{{-}\textgreater{}}\NormalTok{)}|, the
everyday type of \VERB|\FunctionTok{id}|,

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{forall}\NormalTok{ a}\OperatorTok{.}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

\noindent has some implicit parentheses. When written in full:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{forall}\NormalTok{ a}\OperatorTok{.}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

\noindent it's easier to see that the arrow is in fact captured by the
\VERB|\KeywordTok{forall}|. Compare this to a rank-\emph{n} type with
all of its implicit parentheses inserted:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{forall}\NormalTok{ r}\OperatorTok{.}\NormalTok{ ((}\KeywordTok{forall}\NormalTok{ a}\OperatorTok{.}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ r)) }\OtherTok{{-}\textgreater{}}\NormalTok{ r)}
\end{Highlighting}
\end{Shaded}

Here we can see that indeed the
\VERB|\KeywordTok{forall}\NormalTok{ a}\OperatorTok{.}| \emph{is} to the
left of a function arrow---the outermost one. And so, the rank of a
function is simply the number of arrows its deepest
\VERB|\KeywordTok{forall}| is to the left of.

\begin{verbatim}
What is the rank of `Int -> forall a. a -> a`? Hint: try adding the
explicit parentheses.
\end{verbatim}

\begin{verbatim}
  `Int -> forall a. a -> a` is rank-1.
\end{verbatim}

\begin{verbatim}
What is the rank of `(a -> b) -> (forall c. c -> a) -> b`? Hint:
recall that the function arrow is right-associative, so `a -> b -> c` is
actually parsed as `a -> (b -> c)`.
\end{verbatim}

\begin{verbatim}
  `(a -> b) -> (forall c. c -> a) -> b` is rank-2.
\end{verbatim}

\begin{verbatim}
What is the rank of `((forall x. m x -> b (z m x)) -> b (z m a)) ->
m a`? Believe it or not, this is a real type signature we had to write back in
the bad old days before `MonadUnliftIO`!
\end{verbatim}

\begin{verbatim}
  Rank-3.
\end{verbatim}

\hypertarget{the-continuation-monad}{%
\section{The Continuation Monad}\label{the-continuation-monad}}

An interesting fact is that the types \texttt{a} and
\texttt{forall\ r.\ (a\ -\textgreater{}\ r)\ -\textgreater{}\ r} are
isomorphic. This is witnessed by the following functions:

\href{Snip}{code/RankN.hs:cont} \href{Snip}{code/RankN.hs:runCont}

Intuitively, we understand this as saying that having a value is just as
good as having a function that will give that value to a callback. Spend
a few minutes looking at \VERB|\NormalTok{cont}| and
\VERB|\NormalTok{runCont}| to convince yourself you know why these
things form an isomorphism.

The type
\texttt{forall\ r.\ (a\ -\textgreater{}\ r)\ -\textgreater{}\ r} is
known as being in continuation-passing style or more tersely as CPS.

Recall that isomorphisms are transitive. If we have an isomorphism
\texttt{t1} ≅ \texttt{t2}, and another \texttt{t2} ≅ \texttt{t3}, we
must also have one \texttt{t1} ≅ \texttt{t3}.

Since we know that \texttt{Identity\ a} ≅ \texttt{a} and that \texttt{a}
≅ \texttt{forall\ r.\ (a\ -\textgreater{}\ r)\ -\textgreater{}\ r}, we
should expect the transitive isomorphism between \texttt{Identity\ a}
and CPS. Since we know that \texttt{Identity\ a} is a \texttt{Monad} and
that isomorphisms preserve typeclasses, we should expect that CPS also
forms a \texttt{Monad}.

We'll use a newtype as something to attach this instance to.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{Cont}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Cont}
\NormalTok{  \{}\OtherTok{ unCont ::} \KeywordTok{forall}\NormalTok{ r}\OperatorTok{.}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ r) }\OtherTok{{-}\textgreater{}}\NormalTok{ r}
\NormalTok{  \}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Provide a `Functor` instance for `Cont`. Hint: use lots of type holes, and
  an explicit lambda whenever looking for a function type. The implementation is
  sufficiently difficult that trying to write it point-free will be particularly
  mind-bending.
\end{verbatim}

\begin{verbatim}
[code/RankN.hs:contFunctor](Snip)
\end{verbatim}

\begin{verbatim}
Provide the `Applicative` instances for `Cont`.
\end{verbatim}

\begin{verbatim}
[code/RankN.hs:contApplicative](Snip)
\end{verbatim}

\begin{verbatim}
Provide the `Monad` instances for `Cont`.
\end{verbatim}

\begin{verbatim}
[code/RankN.hs:contMonad](Snip)
\end{verbatim}

One of the big values of \texttt{Cont}'s \texttt{Monad} instance is that
it allows us to flatten JavaScript-style ``pyramids of doom.''

For example, imagine the following functions all perform asynchronous
\texttt{IO} in order to compute their values, and will call their given
callbacks when completed.

\href{Snip}{code/RankN.hs:withVersionNumber}
\href{Snip}{code/RankN.hs:withTimestamp}
\href{Snip}{code/RankN.hs:withOS}

We can write a ``pyramid of doom''-style function that uses all three
callbacks to compute a value:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{releaseString ::} \DataTypeTok{String}
\NormalTok{releaseString }\OtherTok{=}
\NormalTok{  withVersionNumber }\OperatorTok{$}\NormalTok{ \textbackslash{}version }\OtherTok{{-}\textgreater{}}
\NormalTok{    withTimestamp }\OperatorTok{$}\NormalTok{ \textbackslash{}date }\OtherTok{{-}\textgreater{}}
\NormalTok{      withOS }\OperatorTok{$}\NormalTok{ \textbackslash{}os }\OtherTok{{-}\textgreater{}}
\NormalTok{        os }\OperatorTok{++} \StringTok{"{-}"} \OperatorTok{++} \FunctionTok{show}\NormalTok{ version }\OperatorTok{++} \StringTok{"{-}"} \OperatorTok{++} \FunctionTok{show}\NormalTok{ date}
\end{Highlighting}
\end{Shaded}

Notice how the deeper the callbacks go, the further indented this code
becomes. We can instead use the \texttt{Cont} (or \texttt{ContT} if we
want to believe these functions are actually performing \texttt{IO}) to
flatten this pyramid.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{releaseStringCont ::} \DataTypeTok{String}
\NormalTok{releaseStringCont }\OtherTok{=}\NormalTok{ runCont }\OperatorTok{$}\NormalTok{ unCont }\OperatorTok{$} \KeywordTok{do}
\NormalTok{  version }\OtherTok{\textless{}{-}} \DataTypeTok{Cont}\NormalTok{ withVersionNumber}
\NormalTok{  date    }\OtherTok{\textless{}{-}} \DataTypeTok{Cont}\NormalTok{ withTimestamp}
\NormalTok{  os      }\OtherTok{\textless{}{-}} \DataTypeTok{Cont}\NormalTok{ withOS}
  \FunctionTok{pure} \OperatorTok{$}\NormalTok{ os }\OperatorTok{++} \StringTok{"{-}"} \OperatorTok{++} \FunctionTok{show}\NormalTok{ version }\OperatorTok{++} \StringTok{"{-}"} \OperatorTok{++} \FunctionTok{show}\NormalTok{ date}
\end{Highlighting}
\end{Shaded}

When written in continuation-passing style,
\VERB|\NormalTok{releaseStringCont}| hides the fact that it's doing
nested callbacks.

\begin{verbatim}
There is also a monad transformer version of `Cont`. Implement it.
\end{verbatim}

\begin{verbatim}
[code/RankN.hs:ContT](Snip)

  The `Functor`, `Applicative` and `Monad` instances for `ContT` are
  identical to `Cont`.
\end{verbatim}

\hypertarget{existential-types}{%
\chapter{Existential Types}\label{existential-types}}

\hypertarget{existential-types-and-eliminators}{%
\section{Existential Types and
Eliminators}\label{existential-types-and-eliminators}}

Closely related to rank-\emph{n} types are the \emph{existential types}.
These are types with a sort of identity problem---the type system has
forgotten what they are! Although it sounds strange at first,
existentials are in fact very useful.

For the time being, we will look at a simpler example: the \texttt{Any}
type.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Any} \OtherTok{=} \KeywordTok{forall}\NormalTok{ a}\OperatorTok{.} \DataTypeTok{Any}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

\texttt{Any} is capable of storing a value of any type, and in doing so,
forgets what type it has. The type constructor doesn't have any type
variables, and so it \emph{can't} remember anything. There's nowhere for
it to store that information.

In order to introduce a type variable for \texttt{Any} to be polymorphic
over, we can use the same
\VERB|\KeywordTok{forall}\NormalTok{ a}\OperatorTok{.}| as when working
with rank-\emph{n} types. This \texttt{a} type exists only within the
context of the \VERB|\DataTypeTok{Any}| data constructor; it is
existential.

The syntax for defining existential types in data constructors is
heavy-handed. GADTs provide a more idiomatic syntax for this
construction.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Any} \KeywordTok{where}
  \DataTypeTok{Any}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Any}
\end{Highlighting}
\end{Shaded}

We can use \texttt{Any} to define a list with values of any types. At
first blush this sounds like the \texttt{HList} we constructed in
chapter 5. However, the usefulness of an \texttt{Any} list is limited
due to the fact that its values can never be recovered.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t [ }\DataTypeTok{Any} \DecValTok{5}\NormalTok{, }\DataTypeTok{Any} \DataTypeTok{True}\NormalTok{, }\DataTypeTok{Any} \StringTok{"hello"}\NormalTok{ ]}
\NormalTok{[ }\DataTypeTok{Any} \DecValTok{5}\NormalTok{, }\DataTypeTok{Any} \DataTypeTok{True}\NormalTok{, }\DataTypeTok{Any} \StringTok{"hello"}\NormalTok{ ]}\OtherTok{ ::}\NormalTok{ [}\DataTypeTok{Any}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Existential types can be \emph{eliminated} (consumed) via
continuation-passing. An \emph{eliminator} is a rank-2 function which
takes an existential type and a continuation that can produce a value
regardless of what it gets. Elimination occurs when our existential type
is fed into this rank-2 function.

To clarify, the eliminator for \texttt{Any} is
\VERB|\NormalTok{elimAny}|:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{elimAny ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ a}\OperatorTok{.}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ r) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Any} \OtherTok{{-}\textgreater{}}\NormalTok{ r}
\NormalTok{elimAny f (}\DataTypeTok{Any}\NormalTok{ a) }\OtherTok{=}\NormalTok{ f a}
\end{Highlighting}
\end{Shaded}

Pay attention to where the \texttt{a} and \texttt{r} types are
quantified. The caller of \VERB|\NormalTok{elimAny}| gets to decide the
result \texttt{r}, but \texttt{a} is determined by the type inside of
the \texttt{Any}.

\begin{verbatim}
Are functions of type `forall a. a -> r` interesting? Why or why
not?
\end{verbatim}

\begin{verbatim}
  These functions can only ever return constant values, as the polymorphism on
  their input doesn't allow any form of inspection.
\end{verbatim}

This approach of existentializing types and later eliminating them is
more useful than it seems. As a next step, consider what happens when we
pack a typeclass dictionary along with our existentialized data.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{HasShow} \KeywordTok{where}
  \DataTypeTok{HasShow}\OtherTok{ ::} \DataTypeTok{Show}\NormalTok{ t }\OtherTok{=\textgreater{}}\NormalTok{ t }\OtherTok{{-}\textgreater{}} \DataTypeTok{HasShow}
\end{Highlighting}
\end{Shaded}

The definition of \texttt{HasShow} is remarkably similar to the GADT
definition of \texttt{Any}, with the addition of the
\VERB|\DataTypeTok{Show}\NormalTok{ t }\OtherTok{=\textgreater{}}|
constraint. This constraint requires a \texttt{Show} instance whenever
constructing a \texttt{HasShow}, and Haskell will remember this. Because
a \texttt{Show} instance was required to build a \texttt{HasShow},
whatever type is inside of \texttt{HasShow} must have a \texttt{Show}
instance. Remarkably, Haskell is smart enough to realize this, and allow
us to call \VERB|\FunctionTok{show}| on whatever type exists inside.

We can use this fact to write a \texttt{Show} instance for
\texttt{HasShow}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Show} \DataTypeTok{HasShow} \KeywordTok{where}
  \FunctionTok{show}\NormalTok{ (}\DataTypeTok{HasShow}\NormalTok{ s) }\OtherTok{=} \StringTok{"HasShow "} \OperatorTok{++} \FunctionTok{show}\NormalTok{ s}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
What happens to this instance if you remove the `Show t =>`{.haskell}
constraint from `HasShow`?
\end{verbatim}

\begin{verbatim}
The `Show HasShow` instance can't be written without its `Show t =>`{.haskell}
  constraint---as the type inside `HasShow` is existential and Haskell
  doesn't know which instance of `Show` to use for the `show`{.haskell} call.
\end{verbatim}

More generally, we are able to write an eliminator for \texttt{HasShow}
which knows we have a \texttt{Show} dictionary in scope.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{elimHasShow}
\OtherTok{    ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ a}\OperatorTok{.} \DataTypeTok{Show}\NormalTok{ a }\OtherTok{=\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ r)}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{HasShow}
    \OtherTok{{-}\textgreater{}}\NormalTok{ r}
\NormalTok{elimHasShow f (}\DataTypeTok{HasShow}\NormalTok{ a) }\OtherTok{=}\NormalTok{ f a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Write the `Show` instance for `HasShow` in terms of
`elimHasShow`{.haskell}.
\end{verbatim}

\begin{verbatim}
[code/RankN.hs:showElimHasShow](Snip)
\end{verbatim}

\hypertarget{dynamic-types}{%
\subsection{Dynamic Types}\label{dynamic-types}}

This pattern of packing a dictionary alongside an existential type
becomes more interesting with other typeclasses. The \texttt{Typeable}
class provides type information at runtime, and allows for dynamic
casting via
\VERB|\OtherTok{cast ::}\NormalTok{ (}\DataTypeTok{Typeable}\NormalTok{ a, }\DataTypeTok{Typeable}\NormalTok{ b) }\OtherTok{=\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ b}|.
We can existentialize \texttt{Typeable} types in order to turn Haskell
into a dynamically typed language.

Using this approach, we can write Python-style functions that play fast
and loose with their types. As an illustration, the \VERB|\ErrorTok{+}|
operator in Python plays double duty by concatenating strings and adding
numbers. And we can implement the same function in Haskell with
\texttt{Dynamic}.

Given the datatype and its eliminator:

\href{Snip}{code/RankN.hs:Dynamic}
\href{Snip}{code/RankN.hs:elimDynamic}

We can implement \texttt{fromDynamic} which attempts to cast a
\texttt{Dynamic} to an \texttt{a}.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{fromDynamic ::} \DataTypeTok{Typeable}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Dynamic} \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a}
\NormalTok{fromDynamic }\OtherTok{=}\NormalTok{ elimDynamic cast}
\end{Highlighting}
\end{Shaded}

A helper function will assist in the implementation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liftD2}
\OtherTok{    ::} \KeywordTok{forall}\NormalTok{ a b r}\OperatorTok{.}
\NormalTok{       ( }\DataTypeTok{Typeable}\NormalTok{ a}
\NormalTok{       , }\DataTypeTok{Typeable}\NormalTok{ b}
\NormalTok{       , }\DataTypeTok{Typeable}\NormalTok{ r}
\NormalTok{       )}
    \OtherTok{=\textgreater{}} \DataTypeTok{Dynamic}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Dynamic}
    \OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b }\OtherTok{{-}\textgreater{}}\NormalTok{ r)}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe} \DataTypeTok{Dynamic}
\NormalTok{liftD2 d1 d2 f }\OtherTok{=}
    \FunctionTok{fmap} \DataTypeTok{Dynamic} \OperatorTok{.}\NormalTok{ f}
      \OperatorTok{\textless{}$\textgreater{}}\NormalTok{ fromDynamic }\OperatorTok{@}\NormalTok{a d1}
      \OperatorTok{\textless{}*\textgreater{}}\NormalTok{ fromDynamic }\OperatorTok{@}\NormalTok{b d2}
\end{Highlighting}
\end{Shaded}

This function attempts to lift a regular, strongly-typed function into a
function over dynamic types. It returns a \texttt{Maybe\ Dynamic}, which
is returned if the cast failed.

Finally, we can present a Haskell version of Python's
\VERB|\ErrorTok{+}| operator:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{pyPlus ::} \DataTypeTok{Dynamic} \OtherTok{{-}\textgreater{}} \DataTypeTok{Dynamic} \OtherTok{{-}\textgreater{}} \DataTypeTok{Dynamic}
\NormalTok{pyPlus a b }\OtherTok{=}
\NormalTok{  fromMaybe (}\FunctionTok{error} \StringTok{"bad types for pyPlus"}\NormalTok{) }\OperatorTok{$}\NormalTok{ asum}
\NormalTok{    [ liftD2 }\OperatorTok{@}\DataTypeTok{String} \OperatorTok{@}\DataTypeTok{String}\NormalTok{ a b (}\OperatorTok{++}\NormalTok{)}
\NormalTok{    , liftD2 }\OperatorTok{@}\DataTypeTok{Int}    \OperatorTok{@}\DataTypeTok{Int}\NormalTok{    a b (}\OperatorTok{+}\NormalTok{)}
\NormalTok{    , liftD2 }\OperatorTok{@}\DataTypeTok{String} \OperatorTok{@}\DataTypeTok{Int}\NormalTok{    a b }\OperatorTok{$}\NormalTok{ \textbackslash{}strA intB }\OtherTok{{-}\textgreater{}}
\NormalTok{        strA }\OperatorTok{++} \FunctionTok{show}\NormalTok{ intB}
\NormalTok{    , liftD2 }\OperatorTok{@}\DataTypeTok{Int}    \OperatorTok{@}\DataTypeTok{String}\NormalTok{ a b }\OperatorTok{$}\NormalTok{ \textbackslash{}intA strB }\OtherTok{{-}\textgreater{}}
        \FunctionTok{show}\NormalTok{ intA }\OperatorTok{++}\NormalTok{ strB}
\NormalTok{    ]}
\end{Highlighting}
\end{Shaded}

In order to easily play with it in GHCi we will need to enable
\texttt{-XTypeApplications} (to get the right type out), and set the
default numeric type to \texttt{Int} (to construct \texttt{Dynamic}s
without type signatures.)

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ default (}\DataTypeTok{Int}\NormalTok{)}
\DataTypeTok{Just} \DecValTok{3}


\OperatorTok{\textgreater{}}\NormalTok{ fromDynamic }\OperatorTok{@}\DataTypeTok{Int}\NormalTok{ (pyPlus (}\DataTypeTok{Dynamic} \DecValTok{1}\NormalTok{) (}\DataTypeTok{Dynamic} \DecValTok{2}\NormalTok{))}
\DataTypeTok{Just} \StringTok{"hello world"}


\OperatorTok{\textgreater{}}\NormalTok{ fromDynamic }\OperatorTok{@}\DataTypeTok{String}\NormalTok{ (pyPlus (}\DataTypeTok{Dynamic} \StringTok{"hello"}\NormalTok{) (}\DataTypeTok{Dynamic} \StringTok{" world"}\NormalTok{))}
\DataTypeTok{Just} \StringTok{"4 minute"}


\OperatorTok{\textgreater{}}\NormalTok{ fromDynamic }\OperatorTok{@}\DataTypeTok{String}\NormalTok{ (pyPlus (}\DataTypeTok{Dynamic} \DecValTok{4}\NormalTok{) (}\DataTypeTok{Dynamic} \StringTok{" minute"}\NormalTok{))}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

If you were particularly plucky, with this approach you could embed a
fully-functioning a dynamically typed language inside of Haskell. The
boilerplate around writing type dependent pattern matches would amortize
down to \(O(1)\) as more of the standard library were implemented.

But, just so we're on the same page: just because you \emph{can},
doesn't mean you \emph{should.} However, there is an interesting
philosophical takeaway here---dynamically typed languages are merely
strongly typed languages with a single type.

\hypertarget{generalized-constraint-kinded-existentials}{%
\subsection{Generalized Constraint Kinded
Existentials}\label{generalized-constraint-kinded-existentials}}

The definitions of \texttt{HasShow} and \texttt{Dynamic} are nearly
identical. Recall:

\href{Snip}{code/RankN.hs:HasShow} \href{Snip}{code/RankN.hs:Dynamic}

There is a clear pattern here, that can be factored out by being
polymorphic over the \texttt{Constraint} packed inside. By enabling
\texttt{-XConstraintKinds}, we are able to be polymorphic over
\texttt{Constraint}s:

\href{Snip}{code/RankN.hs:Has} \href{Snip}{code/RankN.hs:elimHas}

We can thus implement \texttt{HasShow} and \texttt{Dynamic} as type
synonyms.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{HasShow} \OtherTok{=} \DataTypeTok{Has} \DataTypeTok{Show}
\KeywordTok{type} \DataTypeTok{Dynamic} \OtherTok{=} \DataTypeTok{Has} \DataTypeTok{Typeable}
\end{Highlighting}
\end{Shaded}

Sometimes we want to be able to talk about multiple constraints at once.
Like the function which determines if its argument is
\VERB|\FunctionTok{mempty}|.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{isMempty ::}\NormalTok{ (}\DataTypeTok{Monoid}\NormalTok{ a, }\DataTypeTok{Eq}\NormalTok{ a) }\OtherTok{=\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{isMempty a }\OtherTok{=}\NormalTok{ a }\OperatorTok{==} \FunctionTok{mempty}
\end{Highlighting}
\end{Shaded}

Maybe we'd like to construct an \texttt{Has} around this constraint,
\texttt{(Monoid\ a,\ Eq\ a)}. Unfortunately, there is no type-level
lambda syntax, so we're unable to turn this type into something that's
curryable. We can try a type synonym:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{MonoidAndEq}\NormalTok{ a }\OtherTok{=}\NormalTok{ (}\DataTypeTok{Monoid}\NormalTok{ a, }\DataTypeTok{Eq}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

But GHC won't allow us to construct a \texttt{Has\ MonoidAndEq}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\DataTypeTok{Has}\NormalTok{ [}\DataTypeTok{True}\NormalTok{]}\OtherTok{ ::} \DataTypeTok{Has} \DataTypeTok{MonoidAndEq}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

The problem is that type synonyms must always be fully saturated. We're
unable to talk about \texttt{MonoidAndEq} in its unsaturated form---only
\texttt{MonoidAndEq\ a} is acceptable to the compiler.

Fortunately, there is a solution for \texttt{Constraint}-synonyms
(though not for type synonyms in general.) We can instead define a new
class with a superclass constraint, and an instance that comes for free
given those same constraints.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{    (}\DataTypeTok{Monoid}\NormalTok{ a, }\DataTypeTok{Eq}\NormalTok{ a) }\OtherTok{=\textgreater{}} \DataTypeTok{MonoidEq}\NormalTok{ a}
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{Monoid}\NormalTok{ a, }\DataTypeTok{Eq}\NormalTok{ a) }\OtherTok{=\textgreater{}} \DataTypeTok{MonoidEq}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

This is known as a constraint synonym. While type synonyms are unable to
be partially applied, classes have no such restriction.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ foo }\OtherTok{=} \DataTypeTok{Has}\NormalTok{ [}\DataTypeTok{True}\NormalTok{]}\OtherTok{ ::} \DataTypeTok{Has} \DataTypeTok{MonoidEq}
\DataTypeTok{False}


\OperatorTok{\textgreater{}}\NormalTok{ elimHas isMempty foo}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

\hypertarget{scoping-information-with-existentials}{%
\section{Scoping Information with
Existentials}\label{scoping-information-with-existentials}}

Existential types can be used to prevent information from leaking
outside of a desired scope. For example, it means we can ensure that
allocated resources can't escape a pre-specified region. We can use the
type system to prove that a HTTP session-token is quarantined within its
request context, or that a file handle doesn't persist after it's been
closed.

Because existential types are unable to exist outside of their
quantifier, we can use it as a scoping mechanism. By tagging sensitive
data with an existential type, the type system will refuse any attempts
to move this data outside of its scope.

Haskell's \texttt{ST} monad is the most famous example of this approach,
lending its name to the approach: the ST trick. If you're unfamiliar
with it, \texttt{ST} allows us to write stateful code---including
mutable variables---to perform computations, so long as the statefulness
never leaves the monad. In other words, \texttt{ST} allows you to
compute pure functions using impure means.

The amazing thing is that \texttt{ST} is not some magical compiler
primitive---it's just library code. And we can implement it ourselves,
assuming we're comfortable using a little
\VERB|\NormalTok{unsafePerformIO}|! Of course, this is not a comfortable
situation---\VERB|\NormalTok{unsafePerformIO}| is \emph{fundamentally
unsafe}, but observe that there is nothing inherently unsafe about
mutable variables.

It's not the presence of mutable variables that makes code hard to
reason about. So long as all of its mutations are kept local, we know
that a computation is pure. Mutable variables on their own do not cause
us to lose referential transparency.

Referential transparency is lost when code relies on \emph{external}
mutable variables. Doing so creates an invisible data dependency between
our code and the state of its external variables. It is these
cases---and these cases alone---that we need worry about.

As such, it's completely safe to have mutable variables so long as you
can prove they never escape. The ST trick exists to prevent such things
from happening. Enough jibber-jabber. Let's implement it.

At its heart, \texttt{ST} is just the \texttt{Identity} monad with a
phantom \texttt{s} parameter.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{ST}\NormalTok{ s a }\OtherTok{=} \DataTypeTok{ST}  \annotate{1}
\NormalTok{  \{}\OtherTok{ unsafeRunST ::}\NormalTok{ a}
\NormalTok{  \}}
\end{Highlighting}
\end{Shaded}

Notice that at \ann{1} we have a phantom type parameter \texttt{s}. This
variable exists only as a place to put our existential type tag. We'll
better see how it's used in a minute.

\texttt{Applicative} and \texttt{Monad} instances can be provided for
\texttt{ST}. To ensure that our ``unsafe'' IO is performed while it's
actually still safe, these instances must be explicitly strict.
\emph{This is not necessary in general to perform the ST trick}---it's
only because we will be using \VERB|\NormalTok{unsafePerformIO}| for the
example.

\href{Snip}{code/ST.hs:functor} \href{Snip}{code/ST.hs:applicative}
\href{Snip}{code/ST.hs:monad}

Mutable variables can be introduced inside of the \texttt{ST} monad. For
our implementation, we can simply implement these in terms of
\texttt{IORef}s. We will wrap them in a newtype.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{STRef}\NormalTok{ s a }\OtherTok{=} \DataTypeTok{STRef}  \annotate{1}
\NormalTok{  \{}\OtherTok{ unSTRef ::} \DataTypeTok{IORef}\NormalTok{ a}
\NormalTok{  \}}
\end{Highlighting}
\end{Shaded}

Pay attention to the fact that \texttt{STRef} also has a phantom
\texttt{s} parameter (\ann{1}). This is not accidental. \texttt{s} acts
as a label irrevocably knotting a \texttt{STRef} with the \texttt{ST}
context that created it. We'll discuss this after a little more
boilerplate that it's necessary to get through.

Function wrappers for \texttt{STRef} around \texttt{IORef} are provided,
each of which unsafely performs \texttt{IO}. For example, we'd like to
be able to create new \texttt{STRef}s.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{newSTRef ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{ST}\NormalTok{ s (}\DataTypeTok{STRef}\NormalTok{ s a)  }\annotate{1}
\NormalTok{newSTRef }\OtherTok{=}
  \FunctionTok{pure} \OperatorTok{.} \DataTypeTok{STRef} \OperatorTok{.}\NormalTok{ unsafePerformIO }\OperatorTok{.}\NormalTok{ newIORef}
\end{Highlighting}
\end{Shaded}

See here at \ann{1}, that creating a \texttt{STRef} gives us one whose
\texttt{s} parameter is the same as \texttt{ST}'s \texttt{s}. This is
the irrevocable linking between the two types I mentioned earlier.

There are a few more useful functions to wrap:

\href{Snip}{code/ST.hs:readSTRef} \href{Snip}{code/ST.hs:writeSTRef}
\href{Snip}{code/ST.hs:modifySTRef}

And finally, we provide a function to escape from the \texttt{ST} monad.
This is merely \texttt{unsafeRunST}, but with a specialized type
signature.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{runST}
\OtherTok{    ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ s}\OperatorTok{.} \DataTypeTok{ST}\NormalTok{ s a)  }\annotate{1}
    \OtherTok{{-}\textgreater{}}\NormalTok{ a}
\NormalTok{runST }\OtherTok{=}\NormalTok{ unsafeRunST}
\end{Highlighting}
\end{Shaded}

At \ann{1} we see the introduction of the ST trick. The type
\VERB|\NormalTok{(}\KeywordTok{forall}\NormalTok{ s}\OperatorTok{.} \DataTypeTok{ST}\NormalTok{ s a)}|
indicates that \VERB|\NormalTok{runST}| is capable of running only those
\texttt{ST}s which do not depend on their \texttt{s} parameter.

We will discuss why exactly this works shortly, but let's first convince
ourselves that \VERB|\NormalTok{runST}| lives up to its promises. We can
write a safe usage of \texttt{ST}---one which uses its state to compute
a pure value.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{safeExample ::} \DataTypeTok{ST}\NormalTok{ s }\DataTypeTok{String}
\NormalTok{safeExample }\OtherTok{=} \KeywordTok{do}
\NormalTok{  ref }\OtherTok{\textless{}{-}}\NormalTok{ newSTRef }\StringTok{"hello"}
\NormalTok{  modifySTRef ref (}\OperatorTok{++} \StringTok{" world"}\NormalTok{)}
\NormalTok{  readSTRef ref}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ runST safeExample}
\StringTok{"hello world"}
\end{Highlighting}
\end{Shaded}

But the type system now prevents us from \VERB|\NormalTok{runST}|-ing
any code that would leak a reference to a \texttt{STRef}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ runST (newSTRef }\DataTypeTok{True}\NormalTok{)}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

Indeed, \VERB|\NormalTok{runST}| seems to work as expected---but how?
Let's look again at the type of \texttt{runST}.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{runST ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ s}\OperatorTok{.} \DataTypeTok{ST}\NormalTok{ s a) }\OtherTok{{-}\textgreater{}}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

The word \VERB|\KeywordTok{forall}| here acts as a quantifier over
\texttt{s}---the type variable exists in scope \emph{only} within
\texttt{ST\ s\ a}. Because it's existential, without a quantifier, we
have no way of talking about the type. It simply doesn't exist outside
of its \VERB|\KeywordTok{forall}|!

And this is the secret to why the ST trick works. We exploit this fact
that existentials can't leave their quantifier in order to scope our
data. The ``quarantined zone'' is defined with an existential
quantifier, we tag our quarantined data with the resulting existential
type, and the type system does the rest.

To really drive this home, let's look at a specific example. Take again
the case of
\VERB|\NormalTok{runST (newSTRef }\DataTypeTok{True}\NormalTok{)}|. If
we specialize the type of \VERB|\NormalTok{runST}| here, it results in
the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{runST}
\OtherTok{    ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ s}\OperatorTok{.} \DataTypeTok{ST}\NormalTok{ s (}\DataTypeTok{STRef}\NormalTok{ s }\DataTypeTok{Bool}\NormalTok{)) }\annotate{1}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{STRef}\NormalTok{ s }\DataTypeTok{Bool}  \annotate{2}
\end{Highlighting}
\end{Shaded}

Written like this, it's more clear what's going wrong. The type variable
\texttt{s} is introduced---and scoped---at \ann{1}. But later \texttt{s}
is referenced at \ann{2}. At this point the type no longer
exists---there isn't any type \texttt{s} in scope!

GHC calls \texttt{s} a rigid skolem type variable. Rigid variables are
those that are constrained by a type signature written by a
programmer---in other words, they are not allowed to be type inferred. A
human has already given them their type.

A skolem is, for all intents and purposes, any existential type.

The purpose of the phantom \texttt{s} variable in \texttt{ST} and
\texttt{STRef} is exactly to introduce a rigid skolem. If it weren't
rigid (specified), it would be free to vary, and Haskell would correctly
infer that it is unused. If it weren't a skolem, we would be unable to
restrict its existence.

This ST trick can be used whenever you want to restrict the existence of
some piece of data. I've seen it used to tag variables owned by external
FFI, and used it to implement monadic regions which have more or fewer
effect capabilities.

\hypertarget{roles}{%
\chapter{Roles}\label{roles}}

\hypertarget{coercions}{%
\section{Coercions}\label{coercions}}

In Haskell, newtypes are guaranteed to be a zero-cost abstraction. What
this means is that, under the hood, a newtype has exactly the same
memory representation as the type it wraps. At runtime, there is no
difference between a newtype and its wrapped type. The distinction
between the two is made up, and exists only in the type system.

Given the following definitions from \texttt{base}, for example,

\href{Snip}{code/Roles.hs:ZipList} \href{Snip}{code/Roles.hs:Sum}

\noindent then the following values are all representationally
equal---they have exactly the same physical representation in memory

\begin{itemize}
\tightlist
\item
  \VERB|\NormalTok{[}\DecValTok{54}\NormalTok{, }\DecValTok{46}\NormalTok{]}|

  \begin{itemize}
  \tightlist
  \item
    \VERB|\NormalTok{[}\DataTypeTok{Sum} \DecValTok{54}\NormalTok{, }\DataTypeTok{Sum} \DecValTok{46}\NormalTok{]}|
  \item
    \VERB|\DataTypeTok{ZipList}\NormalTok{ [}\DecValTok{54}\NormalTok{, }\DecValTok{46}\NormalTok{]}|
  \item
    \VERB|\DataTypeTok{ZipList}\NormalTok{ [}\DataTypeTok{Sum} \DecValTok{54}\NormalTok{, }\DataTypeTok{Sum} \DecValTok{46}\NormalTok{]}|
  \end{itemize}
\end{itemize}

\VERB|\DataTypeTok{ZipList}\NormalTok{ [}\DecValTok{54}\NormalTok{, }\DecValTok{46}\NormalTok{]}|
is representationally equal to
\VERB|\NormalTok{[}\DecValTok{54}\NormalTok{, }\DecValTok{46}\NormalTok{]}|
because the wrapped list consists of the same bytes in memory as its
unwrapped counterpart. Likewise
\VERB|\NormalTok{[}\DataTypeTok{Sum} \DecValTok{54}\NormalTok{, }\DataTypeTok{Sum} \DecValTok{46}\NormalTok{]}|
is the same, because point-wise, each element in the list is
representationally equal. In the last example here we see that
representational equality is transitive.

This zero-cost property of newtypes has profound implications for
performance. It gives us the ability to \emph{reinterpret} a value of
one type as a value of another---and do it in \(O(0)\) time. This can be
performed via the \VERB|\NormalTok{coerce}| function.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{coerce ::} \DataTypeTok{Coercible}\NormalTok{ a b }\OtherTok{=\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

The \texttt{Coercible\ a\ b} constraint is a proof that the types
\texttt{a} and \texttt{b} do, in fact, have the same runtime
representation. Unless explicitly prevented (discussed later,) a newtype
is always \texttt{Coercible} with its underlying type.
\texttt{Coercible} is a magic constraint. The compiler will write
instances of it for you, and in fact, insists on this---it's actually an
error to write your own!

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \KeywordTok{instance} \DataTypeTok{Coercible}\NormalTok{ a b}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

Anyway, \VERB|\NormalTok{coerce}| can be used to massage data from one
type into another without paying any runtime cost. As an example, if we
wanted to sum a list of \texttt{Int}s, we could use the
\texttt{Sum\ Int} monoid instance.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{slowSum ::}\NormalTok{ [}\DataTypeTok{Int}\NormalTok{] }\OtherTok{{-}\textgreater{}} \DataTypeTok{Int}
\NormalTok{slowSum }\OtherTok{=}\NormalTok{ getSum }\OperatorTok{.} \FunctionTok{mconcat} \OperatorTok{.} \FunctionTok{fmap} \DataTypeTok{Sum}
\end{Highlighting}
\end{Shaded}

While this works, it's not entirely satisfactory; it requires traversing
the entire list with an \VERB|\FunctionTok{fmap}| just in order to get
the right \texttt{Monoid} instance in scope. This is an \(O(n)\) we need
to pay, for no reason other than to satisfy the type system. In such a
simple example, list fusion might optimize away this penalty, but then
again, it might not. And without looking at the generated core, we have
no way of knowing.

For comparison, we can instead use \VERB|\NormalTok{coerce}| to
transform \texttt{{[}Int{]}} into \texttt{{[}Sum\ Int{]}} in \(O(0)\)
time, giving us access to the right \texttt{Monoid} for free.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{fastSum ::}\NormalTok{ [}\DataTypeTok{Int}\NormalTok{] }\OtherTok{{-}\textgreater{}} \DataTypeTok{Int}
\NormalTok{fastSum }\OtherTok{=}\NormalTok{ getSum }\OperatorTok{.} \FunctionTok{mconcat} \OperatorTok{.}\NormalTok{ coerce}
\end{Highlighting}
\end{Shaded}

As a general rule, if you ever find yourself writing
\VERB|\FunctionTok{fmap} \DataTypeTok{NewtypeCtor}|, it should be
replaced with \VERB|\NormalTok{coerce}|---unless the functor instance is
polymorphic, in which case the compiler will complain and refuse to
compile the code. Your runtime performance will thank you, and you'll be
able to sleep peacefully with the satisfaction of a job well done.

Because \texttt{Coercible} corresponds to representational
\emph{equality}, we should expect it to follow all of the usual laws of
equality.

\begin{itemize}
\tightlist
\item
  Reflexivity---\texttt{Coercible\ a\ a} is true for any type \texttt{a}

  \begin{itemize}
  \tightlist
  \item
    Symmetry---\texttt{Coercible\ a\ b} implies
    \texttt{Coercible\ b\ \ \ a}
  \item
    Transitivity---given \texttt{Coercible\ a\ b} and
    \texttt{Coercible\ b\ c} we have \texttt{Coercible\ a\ c}
  \end{itemize}
\end{itemize}

By this line of reasoning, we see that it's perfectly acceptable to
coerce a \texttt{Sum\ a} into a \texttt{Product\ a}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ coerce (}\DecValTok{1867}\OtherTok{ ::} \DataTypeTok{Sum} \DataTypeTok{Int}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{Product} \DataTypeTok{Int}
\DataTypeTok{Product}\NormalTok{ \{getProduct }\OtherTok{=} \DecValTok{1867}\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The line of reasoning here is that both \texttt{Sum\ Int} and
\texttt{Product\ Int} are newtypes over \texttt{Int}, therefore they are
inter-coercible by transitivity.

A natural question about coercions is whether representationally equal
types are always safely interchangeable. They're not. To see why,
consider the case of \texttt{Data.Map.Map} from the \texttt{containers}
package.

\texttt{Map\ k\ v} is a container providing map lookups with key
\texttt{k} and value \texttt{v}. It's represented as a balanced tree,
ordered via an \texttt{Ord\ k} instance. For example, look at the type
of its \VERB|\NormalTok{insert}| method:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{insert ::} \DataTypeTok{Ord}\NormalTok{ k }\OtherTok{=\textgreater{}}\NormalTok{ k }\OtherTok{{-}\textgreater{}}\NormalTok{ v }\OtherTok{{-}\textgreater{}} \DataTypeTok{Map}\NormalTok{ k v }\OtherTok{{-}\textgreater{}} \DataTypeTok{Map}\NormalTok{ k v}
\end{Highlighting}
\end{Shaded}

This \texttt{Ord\ k} instance is required in order to know where to put
the resulting \texttt{v} in the map. The consequence is that a
\texttt{Map\ k\ v}'s layout in memory is \emph{entirely dependent} on
the \texttt{Ord\ k} instance it was built with. Normally typeclass
coherence prevents us from shooting ourselves in the foot (by switching
out the \texttt{Ord\ k} instance in scope, for example) but
\VERB|\NormalTok{coerce}| softens this invariant.

For example, consider the newtype \texttt{Reverse} which flips around an
underlying \texttt{Ord} instance.

\href{Snip}{code/Roles.hs:Reverse} \href{Snip}{code/Roles.hs:OrdReverse}

Even though \texttt{Reverse\ a} is safely \texttt{Coercible} with
\texttt{a}, it is not the case that \texttt{Map\ (Reverse\ k)\ v} can be
safely coerced to \texttt{Map\ k\ v}---they have completely different
layouts in memory! At best, a \texttt{Map\ (Reverse\ k)\ v} interpreted
as a \texttt{Map\ k\ v} will fail to find keys; at worst, it will crash
if the container does unsafe things in the name of performance.

Notice however that the layout of \texttt{Map\ k\ v} does \emph{not}
depend on \texttt{v}; we are free to safely coerce \texttt{Map\ k\ v} as
\texttt{Map\ k\ v\textquotesingle{}} to our hearts' content. Thankfully,
Haskell knows both of these facts, and allows us to coerce only when
it's safe.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ coerce (M.singleton }\CharTok{\textquotesingle{}S\textquotesingle{}} \DataTypeTok{True}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{M.Map} \DataTypeTok{Char}\NormalTok{ (}\DataTypeTok{Reverse} \DataTypeTok{Bool}\NormalTok{)}
\NormalTok{fromList [(}\CharTok{\textquotesingle{}S\textquotesingle{}}\NormalTok{,}\DataTypeTok{Reverse}\NormalTok{ \{getReverse }\OtherTok{=} \DataTypeTok{True}\NormalTok{\})]}


\OperatorTok{\textgreater{}}\NormalTok{ coerce (M.singleton }\CharTok{\textquotesingle{}S\textquotesingle{}} \DataTypeTok{True}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{M.Map}\NormalTok{ (}\DataTypeTok{Reverse} \DataTypeTok{Char}\NormalTok{) }\DataTypeTok{Bool}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

\hypertarget{roles-1}{%
\section{Roles}\label{roles-1}}

The question, of course, is what differentiates \texttt{k} from
\texttt{v}? Their roles are different. Just as the type system ensures
terms are used correctly, and the kind system ensures types are logical,
the role system ensures coercions are safe.

Every type parameter for a given type constructor is assigned a role.
Roles describe how a type's representational equality is related to its
parameters' coercion-safety. There are three varieties of roles.

\begin{itemize}
\tightlist
\item
  nominal---the everyday notion of type-equality in Haskell,
  corresponding to the \texttt{a\ \textasciitilde{}\ b} constraint. For
  example, \texttt{Int} is nominally equal \emph{only} to itself.

  \begin{itemize}
  \tightlist
  \item
    representational---as discussed earlier in this chapter; types
    \texttt{a} and \texttt{b} are representationally equal if and only
    if it's safe to reinterpret the memory of an \texttt{a} as a
    \texttt{b}.
  \item
    phantom---two types are always phantom-ly equal to one another.
  \end{itemize}
\end{itemize}

In the newtype \texttt{Sum\ a}, we say that \texttt{a} \emph{is at role}
\VERB|\NormalTok{representational}|; which means that if
\texttt{Coercible\ a\ b\ =\textgreater{}\ Coercible\ (Sum\ a)\ (Sum\ b)}---that
\texttt{Sum\ a} and \texttt{Sum\ b} are representationally equal
whenever \texttt{a} and \texttt{b} are!

This is also the case for \texttt{v} in \texttt{Map\ k\ v}. However, as
we've seen above, \texttt{Coercible\ k1\ k2} does not imply
\texttt{Coercible\ (Map\ k1\ v)\ (Map\ k2\ v)}, and this is because
\texttt{k} must be at role \VERB|\NormalTok{nominal}|.
\texttt{Coercible\ (Map\ k1\ v)\ (Map\ k2\ v)} is only the case when
\texttt{k1\ \textasciitilde{}\ k2}, and so this nominal role on
\texttt{k} is what keeps \texttt{Map} safe.

The other role is \VERB|\NormalTok{phantom}|, and as you might have
guessed, it is reserved for phantom parameters. \texttt{Proxy}, for
example, has a phantom type variable:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Proxy}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Proxy}
\end{Highlighting}
\end{Shaded}

The type variable \texttt{a} is at role \VERB|\NormalTok{phantom}|, and
as expected, \texttt{Coercible\ (Proxy\ a)\ (Proxy\ b)} is always true.
Since \texttt{a} doesn't actually ever exist at runtime, it's safe to
change it whenever we'd like.

There is an inherent ordering in roles; \VERB|\NormalTok{phantom}| types
can be coerced in more situations than
\VERB|\NormalTok{representational}| types, which themselves can be
coerced more often than \VERB|\NormalTok{nominal}| types. Upgrading from
a weaker role (usable in more situations) to a stronger one is known as
strengthening it.

Just like types, roles are automatically inferred by the compiler,
though they can be specified explicitly if desired. This inference
process is relatively simple, and works as follows:

\begin{itemize}
\tightlist
\item
  All type parameters are assumed to be at role
  \VERB|\NormalTok{phantom}|.

  \begin{itemize}
  \tightlist
  \item
    The type constructor \texttt{(-\textgreater{})} has two
    \VERB|\NormalTok{representational}| roles; any type parameter
    applied to a \texttt{(-\textgreater{})} gets upgraded to
    \texttt{representational}. Data constructors count as applying
    \texttt{(-\textgreater{})}.
  \item
    The type constructor \texttt{(\textasciitilde{})} has two
    \VERB|\NormalTok{nominal}| roles; any type parameter applied to a
    \texttt{(\textasciitilde{})} gets upgraded to
    \VERB|\NormalTok{nominal}|. GADTs and type families count as
    applying \texttt{(\textasciitilde{})}.
  \end{itemize}
\end{itemize}

\begin{verbatim}
  What is the role signature of `Either a b`?
\end{verbatim}

\begin{verbatim}
  `type role Either representational representational`{.haskell}
\end{verbatim}

\begin{verbatim}
  What is the role signature of `Proxy a`?
\end{verbatim}

\begin{verbatim}
  `type role Proxy phantom`{.haskell}
\end{verbatim}

While it's logical that a GADT counts as an application of
\texttt{(\textasciitilde{})}, it might be less clear why types used by
type families must be at role \texttt{nominal}. Let's look at an example
to see why.

Consider a type family that replaces \texttt{Int} with \texttt{Bool},
but otherwise leaves its argument alone.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{family} \DataTypeTok{IntToBool}\NormalTok{ a }\KeywordTok{where}
  \DataTypeTok{IntToBool} \DataTypeTok{Int} \OtherTok{=} \DataTypeTok{Bool}
  \DataTypeTok{IntToBool}\NormalTok{ a   }\OtherTok{=}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

Is it safe to say \texttt{a} is at role
\VERB|\NormalTok{representational}|? Of course
not---\texttt{Coercible\ a\ b\ =\textgreater{}\ Coercible\ (IntToBool\ a)\ (IntToBool\ b)}
doesn't hold in general. In particular, it fails whenever
\texttt{a\ \textasciitilde{}\ Int}. As a result, any type that a type
family can potentially match on must be given role
\VERB|\NormalTok{nominal}|.

While roles are automatically inferred via the compiler, it's possible
to strengthen an inferred role to a less permissive one by providing a
role signature.

For example, binary search trees, like \texttt{Map}s, have an implicit
memory dependency on their \texttt{Ord} instance. Given a data-type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{BST}\NormalTok{ v}
  \OtherTok{=} \DataTypeTok{Empty}
  \OperatorTok{|} \DataTypeTok{Branch}\NormalTok{ (}\DataTypeTok{BST}\NormalTok{ v) v (}\DataTypeTok{BST}\NormalTok{ v)}
\end{Highlighting}
\end{Shaded}

After enabling \texttt{-XRoleAnnotations}, we're capable of providing a
annotation for it to strengthen the inferred role.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ role }\DataTypeTok{BST}\NormalTok{ nominal}
\end{Highlighting}
\end{Shaded}

The syntax for role annotations is
\VERB|\KeywordTok{type}\NormalTok{ role }\DataTypeTok{TyCon}\NormalTok{ role1 role2 }\OperatorTok{...}|,
where roles are given for type variables in the same order they're
defined.

Note that it's only possible to strengthen inferred roles, never weaken
them. For example, because the \texttt{v} in \texttt{BST\ v} is inferred
to be at role \VERB|\NormalTok{representational}|, we are unable to
assert that it is at role \VERB|\NormalTok{phantom}|. Attempting to do
so will result in an error at compile-time.

\hypertarget{associated-type-families}{%
\chapter{Associated Type Families}\label{associated-type-families}}

Let's return to our earlier discussion about \VERB|\NormalTok{printf}|.
Recall, the concern was that despite \VERB|\NormalTok{printf}| having a
type that humans can understand, its many bugs come from our inability
to convince the compiler about this type.

One of Haskell's most profound lessons is a deep appreciation for types.
With it comes the understanding that \texttt{String}s are suitable only
for \emph{unstructured} text. Our format ``strings'' most certainly
\emph{are} structured, and thus, as the argument goes, they should not
be \texttt{String}s.

But, if \VERB|\NormalTok{printf}|'s format string isn't really a string,
what is it?

When we look only at the specifiers in the format string, we see that
they're a kind of type signature themselves. They describe not only the
number of parameters, but also the types of those parameters.

For example, the format string
\VERB|\StringTok{"}\ErrorTok{\textbackslash{}\%}\StringTok{c}\ErrorTok{\textbackslash{}\%}\StringTok{d}\ErrorTok{\textbackslash{}\%}\StringTok{d"}|
could be interpreted in Haskell as a function that takes a character,
two integers, and returns a string---the concatenation of pushing all of
those parameters together. In other words,
\VERB|\StringTok{"}\ErrorTok{\textbackslash{}\%}\StringTok{c}\ErrorTok{\textbackslash{}\%}\StringTok{d}\ErrorTok{\textbackslash{}\%}\StringTok{d"}|
corresponds to the type
\texttt{Char\ -\textgreater{}\ Int\ -\textgreater{}\ Int\ -\textgreater{}\ String}.

But, a format string is not only specifiers; it can also contain
arbitrary text that is to be strung together between the arguments. In
our earlier example, this corresponds to format strings like
\VERB|\StringTok{"some number: }\ErrorTok{\textbackslash{}\%}\StringTok{d"}|.
The type corresponding to this function is still just
\texttt{Int\ -\textgreater{}\ String}, but its actual implementation
should be
\VERB|\NormalTok{\textbackslash{}textbackslash s }\OtherTok{{-}\textgreater{}} \StringTok{"some number: "} \OperatorTok{\textless{}\textgreater{}} \FunctionTok{show}\NormalTok{ s}|.

After some thinking, the key insight here turns out that these format
strings are nothing more than a sequence of types and text to
intersperse between them. We can model this in Haskell by keeping a
type-level list of \texttt{Type}s and \texttt{Symbol}s. The
\texttt{Type}s describe parameters, and the \texttt{Symbol}s are literal
pieces of text to output.

\hypertarget{building-types-from-a-schema}{%
\section{Building Types from a
Schema}\label{building-types-from-a-schema}}

We'll need a data-structure to store the format schema of a
\VERB|\NormalTok{printf}| call. This can be done by building a binary
type constructor which is polykinded in both of its parameters. The goal
is to build a type-safe, heterogeneously-kinded linked-list.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{ (}\OtherTok{a ::}\NormalTok{ k1) }\OperatorTok{:\textless{}\textless{}}\NormalTok{ (}\OtherTok{b ::}\NormalTok{ k2)}
\KeywordTok{infixr} \DecValTok{5} \OperatorTok{:\textless{}\textless{}}
\end{Highlighting}
\end{Shaded}

The \texttt{(:\textless{}\textless{})} symbol was chosen due to the
similarly it has with C++'s \VERB|\NormalTok{\textless{}\textless{}}|
output stream operator, but has no other special meaning to Haskell or
to us.

Notice here that \texttt{(:\textless{}\textless{})} doesn't have any
data constructors, so we are unable to construct one of them at the
term-level. This makes sense, as its only purpose is to store type-level
information.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind (}\OperatorTok{:\textless{}\textless{}}\NormalTok{)}
\OtherTok{(:\textless{}\textless{}) ::}\NormalTok{ k1 }\OtherTok{{-}\textgreater{}}\NormalTok{ k2 }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type}
\end{Highlighting}
\end{Shaded}

Indeed, \texttt{(:\textless{}\textless{})} works as a cons-cell for our
linked-list; we can chain them together indefinitely and store
everything we want at the type-level:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \StringTok{"hello "} \OperatorTok{:\textless{}\textless{}} \DataTypeTok{String} \OperatorTok{:\textless{}\textless{}} \StringTok{"!"}
\StringTok{"hello "} \OperatorTok{:\textless{}\textless{}} \DataTypeTok{String} \OperatorTok{:\textless{}\textless{}} \StringTok{"!"}\OtherTok{ ::} \DataTypeTok{Type}
\OtherTok{=} \StringTok{"hello "} \OperatorTok{:\textless{}\textless{}}\NormalTok{ (}\DataTypeTok{String} \OperatorTok{:\textless{}\textless{}} \StringTok{"!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Because of our
\VERB|\KeywordTok{infixr} \DecValTok{5} \OperatorTok{:\textless{}\textless{}}|
declaration, repeated applications of \texttt{(:\textless{}\textless{})}
associate to the right as we'd expect.

Armed with a means of storing our format schema, our next step is to use
it to construct the proper type signature of our formatting function.
Which is to say, given \emph{eg.} a type
\texttt{Int\ :\textless{}\textless{}\ ":"\ :\textless{}\textless{}\ Bool\ :\textless{}\textless{}\ "!"},
we'd like to produce the type
\texttt{Int\ -\textgreater{}\ Bool\ -\textgreater{}\ String}. This
sounds like a type-level function, and so we should immediately begin to
think about type families.

However, instead of using \emph{closed} type families which are useful
when promoting functions from the term-level to the type-level, we
instead will use an associated type family. Associated type families are
associated with a typeclass, and provide a convenient way to bundle
term-level code with computed types.

Because typeclasses are our means of providing ad-hoc polymorphism,
associated type families allow us to compute ad-hoc types.

We'll talk about bundling term-level code in a moment, but first, we can
define our associated type family:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{HasPrintf}\NormalTok{ a }\KeywordTok{where}  \annotate{1}
  \KeywordTok{type} \DataTypeTok{Printf}\OtherTok{ a ::} \DataTypeTok{Type}  \annotate{2}
\end{Highlighting}
\end{Shaded}

Here at \ann{1} we're saying we have a typeclass \texttt{HasPrintf\ a},
of which every instance must provide an associated type
\texttt{Printf\ a} (\ann{2}). \texttt{Printf\ a} will correspond to the
desired type of our formatting function, and we will construct it in a
moment.

While it's not strictly necessary to use an associated type family
instead of a closed one---they're equivalent in power---the ability to
take advantage of Haskell's overlapping typeclasses will greatly
simplify our logic.

In the name of implementation parsimony, we will say our format types
will always be of the form
\texttt{a\ :\textless{}\textless{}\ ...\ \ :\textless{}\textless{}\ "symbol"}---that
is to say that they'll always end with a \texttt{Symbol}. Such a
simplification gives us a convenient base case for the structural
recursion we want to build.

Structural recursion refers to the technique of producing something by
tearing a recursive structure apart into smaller and smaller pieces,
until you find a case simple enough you know how to handle. It's really
just a fancy name for ``divide and conquer.''

In our \VERB|\NormalTok{printf}| example, we will require three cases:

\begin{itemize}
\tightlist
\item
  \VERB|\DataTypeTok{HasPrintf}\NormalTok{ (}\OtherTok{text ::} \DataTypeTok{Symbol}\NormalTok{)}|

  \begin{itemize}
  \tightlist
  \item
    \VERB|\DataTypeTok{HasPrintf}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{HasPrintf}\NormalTok{ ((}\OtherTok{text ::} \DataTypeTok{Symbol}\NormalTok{) }\OperatorTok{:\textless{}\textless{}}\NormalTok{ a)}|
  \item
    \VERB|\DataTypeTok{HasPrintf}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{HasPrintf}\NormalTok{ ((}\OtherTok{param ::} \DataTypeTok{Type}\NormalTok{) }\OperatorTok{:\textless{}\textless{}}\NormalTok{ a)}|
  \end{itemize}
\end{itemize}

With these three cases, we can tear down any right-associative sequence
of \texttt{(:\textless{}\textless{})}s via case 2 or 3 until we run out
of \texttt{(:\textless{}\textless{})} constructors. At that point, we
will finally be left with a \texttt{Symbol} that we can handle via case
1.

Case 1 corresponds to having no more parameters. Here there is not any
type-level recursion to be done, and so we should just return our
desired output type---a \texttt{String}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{HasPrintf}\NormalTok{ (}\OtherTok{text ::} \DataTypeTok{Symbol}\NormalTok{) }\KeywordTok{where}
  \KeywordTok{type} \DataTypeTok{Printf}\NormalTok{ text }\OtherTok{=} \DataTypeTok{String}
\end{Highlighting}
\end{Shaded}

The second case corresponds to having additional text we want to inject
into our final formatted string. In this case, we don't have a parameter
available to consume, and so here we don't change the resulting simpler
type of \texttt{Printf}. Therefore, we define the associated type
instance of \texttt{Printf} as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{HasPrintf}\NormalTok{ a}
    \OtherTok{=\textgreater{}} \DataTypeTok{HasPrintf}\NormalTok{ ((}\OtherTok{text ::} \DataTypeTok{Symbol}\NormalTok{) }\OperatorTok{:\textless{}\textless{}}\NormalTok{ a) }\KeywordTok{where}
  \KeywordTok{type} \DataTypeTok{Printf}\NormalTok{ (text }\OperatorTok{:\textless{}\textless{}}\NormalTok{ a) }\OtherTok{=} \DataTypeTok{Printf}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

This recursive definition is an acceptable thing to do, because a type
instance of \texttt{Printf\ a} comes from an instance of
\texttt{HasPrintf\ a}---which we have as a constraint on this instance
of \texttt{HasPrintf}.

Case 3 is the most interesting; here we want to add our \texttt{param}
type as a parameter to the generated function. We can do that by
defining \texttt{Printf} as an arrow type that takes the desired
parameter, and recurses.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{HasPrintf}\NormalTok{ a}
    \OtherTok{=\textgreater{}} \DataTypeTok{HasPrintf}\NormalTok{ ((}\OtherTok{param ::} \DataTypeTok{Type}\NormalTok{) }\OperatorTok{:\textless{}\textless{}}\NormalTok{ a) }\KeywordTok{where}
  \KeywordTok{type} \DataTypeTok{Printf}\NormalTok{ (param }\OperatorTok{:\textless{}\textless{}}\NormalTok{ a) }\OtherTok{=}\NormalTok{ param }\OtherTok{{-}\textgreater{}} \DataTypeTok{Printf}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

We're saying our formatting type requires a \texttt{param}, and then
gives back our recursively-defined \texttt{Printf\ a} type. Strictly
speaking, the \texttt{Type} kind signature here isn't necessary---GHC
will infer it based on \texttt{param\ -\textgreater{}\ Printf\ a}---but
it adds to the readability, so we'll keep it.

As a general principle, making type-level programming as legible as
possible will make you and your coworkers' life much easier. Everyone
will thank you later.

We can walk through our earlier example of
\texttt{Int\ :\textless{}\textless{}\ ":"\ :\textless{}\textless{}\ Bool\ :\textless{}\textless{}\ "!"}
to convince ourselves that \texttt{Printf} expands correctly. First, we
see that
\texttt{Int\ :\textless{}\textless{}\ ":"\ :\textless{}\textless{}\ Bool\ :\textless{}\textless{}\ "!"}
is an instance of case 3.

From here, we expand the definition of
\texttt{Printf\ (param\ :\textless{}\textless{}\ a)} into
\texttt{param\ -\textgreater{}\ Printf\ a}, or, substituting for our
earlier type equalities:
\texttt{Int\ -\textgreater{}\ Printf\ (":"\ :\textless{}\textless{}\ Bool\ :\textless{}\textless{}\ "!")}.

We continue matching
\texttt{Printf\ (":"\ :\textless{}\textless{}\ Bool\ :\textless{}\textless{}\ "!")}
and notice now that it matches case 2, giving us
\texttt{Int\ -\textgreater{}\ Printf\ (Bool\ :\textless{}\textless{}\ "!")}.
Expansion again follows case 3, and expands to
\texttt{Int\ -\textgreater{}\ Bool\ -\textgreater{}\ Printf\ "!"}.

Finally, we have run out of \texttt{(:\textless{}\textless{})}
constructors, and so \texttt{Printf\ "!"} matches case 1, where
\texttt{Printf\ text\ =\ String}. Here our recursion ends, and we find
ourselves with the generated type
\texttt{Int\ -\textgreater{}\ Bool\ -\textgreater{}\ String}, exactly
the type we were hoping for.

Analysis of this form is painstaking and time-intensive. Instead, in the
future, we can just ask GHCi if we got it right, again with the
\texttt{:kind!} command:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{Printf}\NormalTok{ (}\DataTypeTok{Int} \OperatorTok{:\textless{}\textless{}} \StringTok{":"} \OperatorTok{:\textless{}\textless{}} \DataTypeTok{Bool} \OperatorTok{:\textless{}\textless{}} \StringTok{"!"}\NormalTok{)}
\DataTypeTok{Printf}\NormalTok{ (}\DataTypeTok{Int} \OperatorTok{:\textless{}\textless{}} \StringTok{":"} \OperatorTok{:\textless{}\textless{}} \DataTypeTok{Bool} \OperatorTok{:\textless{}\textless{}} \StringTok{"!"}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{Type}
\OtherTok{=} \DataTypeTok{Int} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{String}
\end{Highlighting}
\end{Shaded}

Much easier.

\hypertarget{generating-associated-terms}{%
\section{Generating Associated
Terms}\label{generating-associated-terms}}

Building the type \texttt{Printf\ a} is wonderful and all, but producing
a type without any corresponding terms won't do us much good. Our next
step is to update the definition of \texttt{HasPrintf} to also provide a
\VERB|\NormalTok{format}| function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{HasPrintf}\NormalTok{ a }\KeywordTok{where}
  \KeywordTok{type} \DataTypeTok{Printf}\OtherTok{ a ::} \DataTypeTok{Type}
\OtherTok{  format ::} \DataTypeTok{String}    \annotate{1}
         \OtherTok{{-}\textgreater{}} \DataTypeTok{Proxy}\NormalTok{ a   }\annotate{2}
         \OtherTok{{-}\textgreater{}} \DataTypeTok{Printf}\NormalTok{ a  }\annotate{3}
\end{Highlighting}
\end{Shaded}

The type of \VERB|\NormalTok{format}| is a little odd, and could use an
explanation. Looking at the \ann{2}, we find a term of type
\texttt{Proxy\ a}. This \VERB|\DataTypeTok{Proxy}| exists only to allow
Haskell to find the correct instance of \texttt{HasPrintf} from the
call-site of \VERB|\NormalTok{format}|. You might think Haskell would be
able to find an instance based on the \texttt{a} in \texttt{Printf\ a},
but this isn't so for reasons we will discuss soon.

The parameter \ann{1} is an implementation detail, and will act as an
accumulator where we can keep track of all of the formatting done by
earlier steps in the recursion.

Finally, \VERB|\NormalTok{format}| results in a \texttt{Printf\ a} at
\ann{3}. Recall that \texttt{Printf} will expand to arrow types if the
formatting schema contains parameters, and thus all of our additional
formatting is hiding inside \ann{3}.

Our instance definitions for each of the three cases can be updated so
they correctly implement \VERB|\NormalTok{format}|.

In the first case, we have no work to do, so the only thing necessary is
to return the accumulator and append the final text to it.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{KnownSymbol}\NormalTok{ text }\OtherTok{=\textgreater{}} \DataTypeTok{HasPrintf}\NormalTok{ (}\OtherTok{text ::} \DataTypeTok{Symbol}\NormalTok{) }\KeywordTok{where}
  \KeywordTok{type} \DataTypeTok{Printf}\NormalTok{ text }\OtherTok{=} \DataTypeTok{String}
\NormalTok{  format s \_ }\OtherTok{=}\NormalTok{ s }\OperatorTok{\textless{}\textgreater{}}\NormalTok{ symbolVal (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{text)}
\end{Highlighting}
\end{Shaded}

Case 2 is very similar; here we want to update our accumulator with the
\VERB|\NormalTok{symbolVal}| of \texttt{text}, but also structurally
recursively call \VERB|\NormalTok{format}|. This requires conjuring up a
\texttt{Proxy\ a}, which we can do via \texttt{-XTypeApplications}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{HasPrintf}\NormalTok{ a, }\DataTypeTok{KnownSymbol}\NormalTok{ text)}
    \OtherTok{=\textgreater{}} \DataTypeTok{HasPrintf}\NormalTok{ ((}\OtherTok{text ::} \DataTypeTok{Symbol}\NormalTok{) }\OperatorTok{:\textless{}\textless{}}\NormalTok{ a) }\KeywordTok{where}
  \KeywordTok{type} \DataTypeTok{Printf}\NormalTok{ (text }\OperatorTok{:\textless{}\textless{}}\NormalTok{ a) }\OtherTok{=} \DataTypeTok{Printf}\NormalTok{ a}
\NormalTok{  format s \_ }\OtherTok{=}\NormalTok{ format (s }\OperatorTok{\textless{}\textgreater{}}\NormalTok{ symbolVal (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{text))}
\NormalTok{                      (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{a)}
\end{Highlighting}
\end{Shaded}

All that's left is case 3, which should look familiar to the attentive
reader.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{HasPrintf}\NormalTok{ a, }\DataTypeTok{Show}\NormalTok{ param)}
    \OtherTok{=\textgreater{}} \DataTypeTok{HasPrintf}\NormalTok{ ((}\OtherTok{param ::} \DataTypeTok{Type}\NormalTok{) }\OperatorTok{:\textless{}\textless{}}\NormalTok{ a) }\KeywordTok{where}
  \KeywordTok{type} \DataTypeTok{Printf}\NormalTok{ (param }\OperatorTok{:\textless{}\textless{}}\NormalTok{ a) }\OtherTok{=}\NormalTok{ param }\OtherTok{{-}\textgreater{}} \DataTypeTok{Printf}\NormalTok{ a}
\NormalTok{  format s \_ param }\OtherTok{=}\NormalTok{ format (s }\OperatorTok{\textless{}\textgreater{}} \FunctionTok{show}\NormalTok{ param) (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{a)}
\end{Highlighting}
\end{Shaded}

Notice the \VERB|\NormalTok{param}| parameter to our
\VERB|\NormalTok{format}| function here---this corresponds to the
\texttt{param} parameter in case 3's \texttt{Printf} instance. For any
specifier, we use its \texttt{Show} instance to convert the parameter
into a string, and append it to our accumulator.

With all three of our cases covered, we appear to be finished. We can
define a helper function to hide the accumulator from the user, since
it's purely an implementation detail:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{printf ::} \DataTypeTok{HasPrintf}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Proxy}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Printf}\NormalTok{ a}
\NormalTok{printf }\OtherTok{=}\NormalTok{ format }\StringTok{""}
\end{Highlighting}
\end{Shaded}

Firing up GHCi allows us to try it:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ printf (}\DataTypeTok{Proxy} \OperatorTok{@}\StringTok{"test"}\NormalTok{)}
\StringTok{"test"}


\OperatorTok{\textgreater{}}\NormalTok{ printf (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{(}\DataTypeTok{Int} \OperatorTok{:\textless{}\textless{}} \StringTok{"+"} \OperatorTok{:\textless{}\textless{}} \DataTypeTok{Int} \OperatorTok{:\textless{}\textless{}} \StringTok{"=3"}\NormalTok{)) }\DecValTok{1} \DecValTok{2}
\StringTok{"1+2=3"}


\OperatorTok{\textgreater{}} \OperatorTok{/}\NormalTok{wrongPrintf}\OperatorTok{/}\NormalTok{printf}\OperatorTok{/}\NormalTok{wrongPrintf (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{(}\DataTypeTok{String} \OperatorTok{:\textless{}\textless{}} \StringTok{" world!"}\NormalTok{)) }\StringTok{"hello"}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

It works pretty well for our first attempt, all things considered. One
noticeable flaw is that \texttt{String}s gain an extra set of quotes due
to being \VERB|\FunctionTok{show}|n.~We can fix this infelicity by
providing a special instance of \texttt{HasPrintf} just for
\texttt{String}s:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \OtherTok{\{{-}\# OVERLAPPING \#{-}\}} \DataTypeTok{HasPrintf}\NormalTok{ a}
    \OtherTok{=\textgreater{}} \DataTypeTok{HasPrintf}\NormalTok{ (}\DataTypeTok{String} \OperatorTok{:\textless{}\textless{}}\NormalTok{ a) }\KeywordTok{where}
  \KeywordTok{type} \DataTypeTok{Printf}\NormalTok{ (}\DataTypeTok{String} \OperatorTok{:\textless{}\textless{}}\NormalTok{ a) }\OtherTok{=} \DataTypeTok{String} \OtherTok{{-}\textgreater{}} \DataTypeTok{Printf}\NormalTok{ a}
\NormalTok{  format s \_ param }\OtherTok{=}\NormalTok{ format (s }\OperatorTok{\textless{}\textgreater{}}\NormalTok{ param) (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{a)}
\end{Highlighting}
\end{Shaded}

Writing this instance will require the \texttt{-XFlexibleInstances}
extension, since the instance head is no longer just a single type
constructor and type variables. We mark the instance with the
\VERB|\CommentTok{\{{-}\textbackslash{}\# OVERLAPPING \textbackslash{}\#{-}\}}|
pragma because we'd like to select this instance instead of case 3 when
the parameter is a \texttt{String}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ printf (}\DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{(}\DataTypeTok{String} \OperatorTok{:\textless{}\textless{}} \StringTok{" world!"}\NormalTok{)) }\StringTok{"hello"}
\StringTok{"hello world!"}
\end{Highlighting}
\end{Shaded}

Marvelous.

There is something to be noted about overlapping instances for type
families---that, in general, they're not allowed. The reason we can
overlap \texttt{param\ :\textless{}\textless{}\ a} and
\texttt{String\ :\textless{}\textless{}\ a} is that they actually
\emph{agree} on the type family instance. When
\texttt{param\ \textasciitilde{}\ String}, both instances give
\texttt{Printf\ (param\ :\textless{}\textless{}\ a)} to be
\texttt{String\ -\textgreater{}\ Printf\ a}.

What we've accomplished here is a type-safe version of
\VERB|\NormalTok{printf}|, but by recognizing that C++'s ``format
string'' is better thought of as a ``structured type signature.'' Using
type-level programming, we were able to convert such a thing into a
function with the correct type, that implements nontrivial logic.

This technique is widely-applicable. For example, the popular
\texttt{servant}({\textbf{???}}) library uses a similar type-level
schema to describe web APIs, and will generate typesafe servers, clients
and interop specs for them.

\hypertarget{first-class-families}{%
\chapter{First Class Families}\label{first-class-families}}

\hypertarget{defunctionalization}{%
\section{Defunctionalization}\label{defunctionalization}}

Until recently, it was believed that type families had no chance of
being first class; because they're unable to be partially applied, reuse
and abstraction seemed impossible goals. Every type-level
\VERB|\FunctionTok{fmap}| would need to be specialized with its mapping
function built-in, and there seemed no way of abstracting away this
repetitive boilerplate.

The work of Li-yao Xia ({\textbf{???}}) has relaxed this limitation, not
by providing unsaturated type families, but by giving us tools for
working around them. It works via Defunctionalization---the process of
replacing an instantiation of a polymorphic function with a specialized
label instead.

For example, rather than the function \VERB|\FunctionTok{fst}|:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{fst}\OtherTok{ ::}\NormalTok{ (a, b) }\OtherTok{{-}\textgreater{}}\NormalTok{ a}
\FunctionTok{fst}\NormalTok{ (a, b) }\OtherTok{=}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

We can instead defunctionalize it by providing an equivalent label:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Fst}\NormalTok{ a b }\OtherTok{=} \DataTypeTok{Fst}\NormalTok{ (a, b)}
\end{Highlighting}
\end{Shaded}

All that's left to implement is the actual evaluation function. This can
be codified as a typeclass with a functional dependency to guide the
return type.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Eval}\NormalTok{ l t }\OperatorTok{|}\NormalTok{ l }\OtherTok{{-}\textgreater{}}\NormalTok{ t }\KeywordTok{where}  \annotate{1}
\OtherTok{  eval ::}\NormalTok{ l }\OtherTok{{-}\textgreater{}}\NormalTok{ t}
\end{Highlighting}
\end{Shaded}

The syntax
\VERB|\OperatorTok{\VerbBar{}}\NormalTok{ l }\OtherTok{{-}\textgreater{}}\NormalTok{ t}|
at \ann{1} is known as a functional dependency, and states that the type
\texttt{t} is fully determined by the type \texttt{l}. Here, \texttt{l}
is the type of our defunctionalized label, and \texttt{t} is the return
type of the evaluation.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Fst}\NormalTok{ a b) a }\KeywordTok{where}
\NormalTok{  eval (}\DataTypeTok{Fst}\NormalTok{ (a, b)) }\OtherTok{=}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

Despite being roundabout, this approach works just as well as
\VERB|\FunctionTok{fst}| itself does.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ eval (}\DataTypeTok{Fst}\NormalTok{ (}\StringTok{"hello"}\NormalTok{, }\DataTypeTok{True}\NormalTok{))}
\StringTok{"hello"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Defunctionalize `listToMaybe :: [a] -> Maybe a`{.haskell}.
\end{verbatim}

\begin{verbatim}
[code/Defunc.hs:ListToMaybe](Snip)
[code/Defunc.hs:EvalListToMaybe](Snip)
\end{verbatim}

Even higher-order functions can be defunctionalized:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{MapList}\NormalTok{ dfb a }\OtherTok{=} \DataTypeTok{MapList}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ dfb) [a]  }\annotate{1}
\end{Highlighting}
\end{Shaded}

The \texttt{dfb} type at \ann{1} could be labeled simply as \texttt{b},
but we will enforce it is a defunctionalized symbol---evaluation of
\texttt{MapList} will depend on an \texttt{Eval\ dfb} instance. This
name helps suggest that.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ dfb dft }\OtherTok{=\textgreater{}} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{MapList}\NormalTok{ dfb a) [dft] }\KeywordTok{where}
\NormalTok{  eval (}\DataTypeTok{MapList}\NormalTok{ f []) }\OtherTok{=}\NormalTok{ []}
\NormalTok{  eval (}\DataTypeTok{MapList}\NormalTok{ f (a }\OperatorTok{:}\NormalTok{ as)) }\OtherTok{=}
\NormalTok{    eval (f a) }\OperatorTok{:}\NormalTok{ eval (}\DataTypeTok{MapList}\NormalTok{ f as)  }\annotate{1}
\end{Highlighting}
\end{Shaded}

Pay attention to \ann{1}---rather than consing \VERB|\NormalTok{f a}| to
the mapped list, we instead cons \VERB|\NormalTok{eval (f a)}|. While
there is morally no difference, such an approach allows
defunctionalization of \VERB|\FunctionTok{map}| to propagate evaluation
of other defunctionalized symbols. We can see it in action:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ eval (}\DataTypeTok{MapList} \DataTypeTok{Fst}\NormalTok{ [(}\StringTok{"hello"}\NormalTok{, }\DecValTok{1}\NormalTok{), (}\StringTok{"world"}\NormalTok{, }\DecValTok{2}\NormalTok{)])}
\NormalTok{[}\StringTok{"hello"}\NormalTok{,}\StringTok{"world"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\hypertarget{type-level-defunctionalization}{%
\section{Type-Level
Defunctionalization}\label{type-level-defunctionalization}}

This entire line of reasoning lifts, as Xia shows, to the type-level
where it fits a little more naturally. Because type families are capable
of discriminating on types, we can write a defunctionalized symbol whose
type corresponds to the desired type-level function.

These are known as first class families, or FCFs for short.

We begin with a kind synonym, \texttt{Exp\ a} which describes a
type-level function which, when evaluated, will produce a type of kind
\texttt{a}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{Exp}\NormalTok{ a }\OtherTok{=}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type}
\end{Highlighting}
\end{Shaded}

This ``evaluation'' is performed via an open type family \texttt{Eval}.
\texttt{Eval} matches on \texttt{Exp\ a}s, mapping them to an
\texttt{a}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{family} \DataTypeTok{Eval}\NormalTok{ (}\OtherTok{e ::} \DataTypeTok{Exp}\NormalTok{ a)}\OtherTok{ ::}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

To write defunctionalized ``labels'', empty data-types can be used. As
an illustration, if we wanted to lift \VERB|\FunctionTok{snd}| to the
type-level, we write a data-type whose kind mirrors the type of
\VERB|\FunctionTok{snd}|.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Snd}\OtherTok{ ::}\NormalTok{ (a, b) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Exp}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\FunctionTok{snd}
\FunctionTok{snd}\OtherTok{ ::}\NormalTok{ (a, b) }\OtherTok{{-}\textgreater{}}\NormalTok{ b}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind }\DataTypeTok{Snd}
\DataTypeTok{Snd}\OtherTok{ ::}\NormalTok{ (a, b) }\OtherTok{{-}\textgreater{}}\NormalTok{ b }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type}
\end{Highlighting}
\end{Shaded}

The type of \VERB|\FunctionTok{snd}| and kind of \texttt{Snd} share a
symmetry, if you ignore the trailing
\VERB|\OtherTok{{-}\textgreater{}} \DataTypeTok{Type}| on \texttt{Snd}.
An instance of \texttt{Eval} can be used to implement the evaluation of
\texttt{Snd}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Snd} \CharTok{\textquotesingle{}(a, b)) = b}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Snd} \CharTok{\textquotesingle{}(1, "hello"))}
\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Snd} \CharTok{\textquotesingle{}(1, "hello")) :: Symbol}
\OtherTok{=} \StringTok{"hello"}
\end{Highlighting}
\end{Shaded}

Functions that perform pattern matching can be lifted to the
defunctionalized style by providing multiple type instances for
\texttt{Eval}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{FromMaybe}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Exp}\NormalTok{ a}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{FromMaybe}\NormalTok{ \_1 (}\DataTypeTok{\textquotesingle{}Just}\NormalTok{ a)) }\OtherTok{=}\NormalTok{ a}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{FromMaybe}\NormalTok{ a }\DataTypeTok{\textquotesingle{}Nothing}\NormalTok{)   }\OtherTok{=}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

\texttt{Eval} of \texttt{FromMaybe} proceeds as you'd expect.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{FromMaybe} \StringTok{"nothing"}\NormalTok{ (}\DataTypeTok{\textquotesingle{}Just} \StringTok{"just"}\NormalTok{))}
\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{FromMaybe} \StringTok{"nothing"}\NormalTok{ (}\DataTypeTok{\textquotesingle{}Just} \StringTok{"just"}\NormalTok{))}\OtherTok{ ::} \DataTypeTok{Symbol}
\OtherTok{=} \StringTok{"just"}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{FromMaybe} \StringTok{"nothing"} \DataTypeTok{\textquotesingle{}Nothing}\NormalTok{)}
\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{FromMaybe} \StringTok{"nothing"} \DataTypeTok{\textquotesingle{}Nothing}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{Symbol}
\OtherTok{=} \StringTok{"nothing"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Defunctionalize `listToMaybe`{.haskell} at the type-level.
\end{verbatim}

\begin{verbatim}
[code/FCTF.hs:ListToMaybe](Snip)
\end{verbatim}

However, the real appeal of this approach is that it allows for
\emph{higher-order} functions. For example, \VERB|\FunctionTok{map}| is
lifted by taking a defunctionalization label of kind
\texttt{a\ -\textgreater{}\ Exp\ b} and applying it to a
\texttt{{[}a{]}} to get a \texttt{Exp\ {[}b{]}}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{MapList}\OtherTok{ ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Exp}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}} \DataTypeTok{Exp}\NormalTok{ [b]}
\end{Highlighting}
\end{Shaded}

\texttt{Eval} of \texttt{\textquotesingle{}{[}{]}} is trivial:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{MapList}\NormalTok{ f }\CharTok{\textquotesingle{}[]) = \textquotesingle{}}\NormalTok{[]}
\end{Highlighting}
\end{Shaded}

And \texttt{Eval} of cons proceeds in the only way that will type check,
by evaluating the function symbol applied to the head, and evaluating
the \texttt{MapList} of the tail.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{MapList}\NormalTok{ f (a }\CharTok{\textquotesingle{}: as))}
  \OtherTok{=} \DataTypeTok{Eval}\NormalTok{ (f a) }\CharTok{\textquotesingle{}: Eval (MapList f as)}
\end{Highlighting}
\end{Shaded}

Behold! A type-level \texttt{MapList} is now \emph{reusable}!

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{MapList}\NormalTok{ (}\DataTypeTok{FromMaybe} \DecValTok{0}\NormalTok{) [}\DataTypeTok{\textquotesingle{}Nothing}\NormalTok{, (}\DataTypeTok{\textquotesingle{}Just} \DecValTok{1}\NormalTok{)])}
\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{MapList}\NormalTok{ (}\DataTypeTok{FromMaybe} \DecValTok{0}\NormalTok{) [}\DataTypeTok{\textquotesingle{}Nothing}\NormalTok{, (}\DataTypeTok{\textquotesingle{}Just} \DecValTok{1}\NormalTok{)])}\OtherTok{ ::}\NormalTok{ [}\DataTypeTok{Nat}\NormalTok{]}
\OtherTok{=} \CharTok{\textquotesingle{}[0, 1]}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{MapList} \DataTypeTok{Snd}\NormalTok{ [}\CharTok{\textquotesingle{}(5, 7), \textquotesingle{}}\NormalTok{(}\DecValTok{13}\NormalTok{, }\DecValTok{13}\NormalTok{)])}
\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{MapList} \DataTypeTok{Snd}\NormalTok{ [}\CharTok{\textquotesingle{}(5, 7), \textquotesingle{}}\NormalTok{(}\DecValTok{13}\NormalTok{, }\DecValTok{13}\NormalTok{)])}\OtherTok{ ::}\NormalTok{ [}\DataTypeTok{Nat}\NormalTok{]}
\OtherTok{=} \CharTok{\textquotesingle{}[7, 13]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Defunctionalize `foldr ::`{.haskell} 
 `(a -> b -> b) -> b -> [a] -> b`.
\end{verbatim}

\begin{verbatim}
[code/FCTF.hs:Foldr](Snip)
\end{verbatim}

\hypertarget{working-with-first-class-families}{%
\section{Working with First Class
Families}\label{working-with-first-class-families}}

Interestingly, first-class families form a monad at the type-level.

\href{Snip}{code/FCTF.hs:Pure} \href{Snip}{code/FCTF.hs:bind}

As such, we can compose them in terms of their Kleisli composition.
Traditionally the fish operator
(\VERB|\OperatorTok{\textless{}=\textless{}}|) is used to represent this
combinator in Haskell. We are unable to use the more familiar period
operator at the type-level, as it conflicts with the syntax of the
\texttt{forall} quantifier.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{ (}\OperatorTok{\textless{}=\textless{}}\NormalTok{)}
\OtherTok{    ::}\NormalTok{ (b }\OtherTok{{-}\textgreater{}} \DataTypeTok{Exp}\NormalTok{ c)}
    \OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Exp}\NormalTok{ b)}
    \OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Exp}\NormalTok{ c}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ ((f }\OperatorTok{\textless{}=\textless{}}\NormalTok{ g) x) }\OtherTok{=}
  \DataTypeTok{Eval}\NormalTok{ (f (}\DataTypeTok{Eval}\NormalTok{ (g x)))}
\KeywordTok{infixr} \DecValTok{1} \OperatorTok{\textless{}=\textless{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{set }\OperatorTok{{-}}\DataTypeTok{XPolyKinds}
\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Snd2} \CharTok{\textquotesingle{}(1, \textquotesingle{}}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)))}\OtherTok{ ::} \DataTypeTok{Nat}
\OtherTok{=} \DecValTok{3}


\OperatorTok{\textgreater{}} \KeywordTok{type} \DataTypeTok{Snd2} \OtherTok{=} \DataTypeTok{Snd} \OperatorTok{\textless{}=\textless{}} \DataTypeTok{Snd}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

While \texttt{(\textless{}=\textless{})} at the type-level acts like
regular function composition
\VERB|\NormalTok{(}\OperatorTok{.}\NormalTok{)}|,
\texttt{(=\textless{}\textless{})} behaves like function application
\VERB|\NormalTok{(\textbackslash{}}\OperatorTok{$}\NormalTok{)}|.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Snd} \OperatorTok{\textless{}=\textless{}} \DataTypeTok{FromMaybe} \CharTok{\textquotesingle{}(0, 0) =\textless{}\textless{} Pure (Just \textquotesingle{}}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)))}
\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Snd} \OperatorTok{\textless{}=\textless{}} \DataTypeTok{FromMaybe} \CharTok{\textquotesingle{}(0, 0) =\textless{}\textless{} Pure (Just \textquotesingle{}}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)))}\OtherTok{ ::} \DataTypeTok{Nat}
\OtherTok{=} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

The \texttt{first-class-families}({\textbf{???}}) package provides most
of \texttt{Prelude} as FCFs, as well as some particularly useful
functions for type-level programming. For example, we can determine if
any two types are the same---remember, there is no \texttt{Eq} at the
type-level.

\href{Snip}{code/FCTF.hs:TyEq} \href{Snip}{code/FCTF.hs:EvalTyEq}
\href{Snip}{code/FCTF.hs:TyEqImpl}

We also have the ability to collapse lists of \texttt{Constraint}s.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Collapse}\OtherTok{ ::}\NormalTok{ [}\DataTypeTok{Constraint}\NormalTok{] }\OtherTok{{-}\textgreater{}} \DataTypeTok{Exp} \DataTypeTok{Constraint}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Collapse} \CharTok{\textquotesingle{}[]) =}
\NormalTok{  (}\OtherTok{() ::} \DataTypeTok{Constraint}\NormalTok{)}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Collapse}\NormalTok{ (a }\CharTok{\textquotesingle{}: as)) =}
\NormalTok{  (a, }\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Collapse}\NormalTok{ as))}
\end{Highlighting}
\end{Shaded}

Which leads us very naturally to:

\href{Snip}{code/FCTF.hs:All} \href{Snip}{code/FCTF.hs:Pure1}

And we find ourselves with a much nicer implementation of \texttt{All}
than we wrote in chapter 5.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{All} \DataTypeTok{Eq} \CharTok{\textquotesingle{}[Int, Bool])}
\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{All} \DataTypeTok{Eq} \CharTok{\textquotesingle{}[Int, Bool]) :: Constraint}
\OtherTok{=}\NormalTok{ (}\DataTypeTok{Eq} \DataTypeTok{Int}\NormalTok{, (}\DataTypeTok{Eq} \DataTypeTok{Bool}\NormalTok{,}\OtherTok{ () ::} \DataTypeTok{Constraint}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{ad-hoc-polymorphism}{%
\section{Ad-Hoc Polymorphism}\label{ad-hoc-polymorphism}}

Consider the following definition of \texttt{Map}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Map}\OtherTok{ ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Exp}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Exp}\NormalTok{ (f b)}
\end{Highlighting}
\end{Shaded}

Because type families are capable of discriminating on types, we can
write several instances of \texttt{Eval} for \texttt{Map}. For example,
for lists:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Map}\NormalTok{ f }\CharTok{\textquotesingle{}[]) = \textquotesingle{}}\NormalTok{[]}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Map}\NormalTok{ f (a }\CharTok{\textquotesingle{}: as)) = Eval (f a) \textquotesingle{}}\OperatorTok{:} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Map}\NormalTok{ f as)}
\end{Highlighting}
\end{Shaded}

And also for \texttt{Maybe}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Map}\NormalTok{ f }\DataTypeTok{\textquotesingle{}Nothing}\NormalTok{)  }\OtherTok{=} \DataTypeTok{\textquotesingle{}Nothing}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Map}\NormalTok{ f (}\DataTypeTok{\textquotesingle{}Just}\NormalTok{ a)) }\OtherTok{=} \DataTypeTok{\textquotesingle{}Just}\NormalTok{ (}\DataTypeTok{Eval}\NormalTok{ (f a))}
\end{Highlighting}
\end{Shaded}

Why not an instance for \texttt{Either} while we're at it.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Map}\NormalTok{ f (}\DataTypeTok{\textquotesingle{}Left}\NormalTok{ x))  }\OtherTok{=} \DataTypeTok{\textquotesingle{}Left}\NormalTok{ x}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Map}\NormalTok{ f (}\DataTypeTok{\textquotesingle{}Right}\NormalTok{ a)) }\OtherTok{=} \DataTypeTok{\textquotesingle{}Right}\NormalTok{ (}\DataTypeTok{Eval}\NormalTok{ (f a))}
\end{Highlighting}
\end{Shaded}

As you might expect, this gives us ad-hoc polymorphism for a promoted
\VERB|\FunctionTok{fmap}|.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Map} \DataTypeTok{Snd}\NormalTok{ (}\DataTypeTok{\textquotesingle{}Just} \CharTok{\textquotesingle{}(1, 2)))}
\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Map} \DataTypeTok{Snd}\NormalTok{ (}\DataTypeTok{\textquotesingle{}Just} \CharTok{\textquotesingle{}(1, 2))) :: Maybe Nat}
\OtherTok{=} \DataTypeTok{\textquotesingle{}Just} \DecValTok{2}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Map} \DataTypeTok{Snd} \CharTok{\textquotesingle{}[ \textquotesingle{}}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{) ])}
\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Map} \DataTypeTok{Snd} \CharTok{\textquotesingle{}[ \textquotesingle{}}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{) ])}\OtherTok{ ::}\NormalTok{ [}\DataTypeTok{Nat}\NormalTok{]}
\OtherTok{=} \CharTok{\textquotesingle{}[2]}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Map} \DataTypeTok{Snd}\NormalTok{ (}\DataTypeTok{Left} \DataTypeTok{\textquotesingle{}False}\NormalTok{))}
\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Map} \DataTypeTok{Snd}\NormalTok{ (}\DataTypeTok{Left} \DataTypeTok{\textquotesingle{}False}\NormalTok{))}\OtherTok{ ::} \DataTypeTok{Either} \DataTypeTok{Bool}\NormalTok{ b}
\OtherTok{=} \DataTypeTok{\textquotesingle{}Left} \DataTypeTok{\textquotesingle{}False}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Write a promoted functor instance for tuples.
\end{verbatim}

\begin{verbatim}
[code/FCTF.hs:MapTuple](Snip)
\end{verbatim}

This technique of ad-hoc polymorphism generalizes in the obvious way,
allowing us to implement the semigroup operation \texttt{Mappend}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Mappend}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Exp}\NormalTok{ a}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}
\NormalTok{  (}\DataTypeTok{Mappend} \CharTok{\textquotesingle{}() \textquotesingle{}}\NormalTok{()) }\OtherTok{=} \CharTok{\textquotesingle{}()}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}
\NormalTok{  (}\DataTypeTok{Mappend}\NormalTok{ (}\OtherTok{a ::} \DataTypeTok{Constraint}\NormalTok{)}
\NormalTok{           (}\OtherTok{b ::} \DataTypeTok{Constraint}\NormalTok{)) }\OtherTok{=}\NormalTok{ (a, b)}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}
\NormalTok{  (}\DataTypeTok{Mappend}\NormalTok{ (}\OtherTok{a ::}\NormalTok{ [k])}
\NormalTok{           (}\OtherTok{b ::}\NormalTok{ [k])) }\OtherTok{=} \DataTypeTok{Eval}\NormalTok{ (a }\OperatorTok{++}\NormalTok{ b)}
\CommentTok{{-}{-} etc}
\end{Highlighting}
\end{Shaded}

However, at first glance, it's unclear how the approach can be used to
implement \texttt{Mempty}. Type families are not allowed to discriminate
on their return type. We can cheat this restriction by muddying up the
interface a little and making the ``type application'' explicit. We give
the kind signature of \texttt{Mempty} as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Mempty}\OtherTok{ ::}\NormalTok{ k }\OtherTok{{-}\textgreater{}} \DataTypeTok{Exp}\NormalTok{ k}
\end{Highlighting}
\end{Shaded}

The understanding here is that given a type of any monoidal kind
\texttt{k}, \texttt{Mempty} will give back the monoidal identity for
that kind. This can be done by matching on a rigid kind signature, as in
the following instances.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}
\NormalTok{  (}\DataTypeTok{Mempty} \CharTok{\textquotesingle{}()) = \textquotesingle{}}\NormalTok{()}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}
\NormalTok{  (}\DataTypeTok{Mempty}\NormalTok{ (}\OtherTok{c ::} \DataTypeTok{Constraint}\NormalTok{))}
    \OtherTok{=}\NormalTok{ (}\OtherTok{() ::} \DataTypeTok{Constraint}\NormalTok{)}
\KeywordTok{type} \KeywordTok{instance} \DataTypeTok{Eval}
\NormalTok{  (}\DataTypeTok{Mempty}\NormalTok{ (}\OtherTok{l ::}\NormalTok{ [k])) }\OtherTok{=} \CharTok{\textquotesingle{}[]}
\CommentTok{{-}{-} etc}
\end{Highlighting}
\end{Shaded}

\hypertarget{extensible-data}{%
\chapter{Extensible Data}\label{extensible-data}}

\hypertarget{introduction-2}{%
\section{Introduction}\label{introduction-2}}

One heralded feature of dynamic languages---conspicuously missing in
Haskell---is their support for ad-hoc objects. Consider Python's
dictionary datatype:

\begin{verbatim}
record = { 'foo': 12, 'bar': True } -- ! 1
record['qux'] = "hello" -- ! 2
record['foo'] = [1, 2, 3] -- ! 3
\end{verbatim}

At \ann{1}, \texttt{record} can be said to have a (Haskell) type
\VERB|\NormalTok{\{}\OtherTok{foo ::} \DataTypeTok{Int}\NormalTok{,}\OtherTok{ bar ::} \DataTypeTok{Bool}\NormalTok{\}}|.
However, at \ann{2} it also gains a
\VERB|\OtherTok{qux ::} \DataTypeTok{String}| field. And at \ann{3}, the
type of \VERB|\NormalTok{foo}| changes to
\VERB|\NormalTok{[}\DataTypeTok{Int}\NormalTok{]}|. Of course, Python
doesn't actually enforce any of these typing rules. It is, however, a
good example of a program that would be hard to represent in Haskell.

In this chapter, we will discuss how to build this sort of
``extensible'' record type. As its dual, we will also investigate
generalizing the \texttt{Either} type to support an arbitrary number of
potential types. These types are a good and instructive use of
type-level programming.

When looking at the canonical representations of types, we saw that all
of custom Haskell data-types can be built as \emph{sums-of-products}.
Sums correspond to \texttt{Either\ a\ b}, and products correspond to the
pair type \texttt{(a,\ b)}. However, just because we can show an
isomorphism between a type and this sum-of-products doesn't mean such an
encoding is \emph{efficient}.

Because both \texttt{Either} and \texttt{(,)} are \emph{binary
operators}, using them for arbitrarily large representations will
require lots of extra constructors. In the best case our representation
will be a balanced binary tree (of the form
\texttt{Either\ (Either\ ...)\ (Either\ ...)}.) This corresponds to an
overhead of \(O(\log{n})\) constructors. In the worst case, it degrades
into a linked list, and we pay for \(O(n)\) constructors.

It seems, however, like we should be able to describe a sum of any
number of possibilities in \(O(1)\) space, since it only ever contains
one thing. Likewise, that we can describe a product in \(O(n)\) space
(rather than the \(O(n+\log{n})\) balanced binary tree, or \(O(2n)\)
linked list.)

The ``trick'' building extensible sum and product types is to use the
type system to encode the extra information. Anything we do at the
type-level is free at runtime. Because open sums have fewer moving
pieces, we will work through them first, and use their lessons to help
build open products.

\hypertarget{open-sums}{%
\section{Open Sums}\label{open-sums}}

By definition, an open sum is a container of a data whose type isn't
known statically. Furthermore, there are no guarantees that we know
which types it \emph{might be,} since the list of types itself might be
polymorphic.

Existential types are ones whose type has been forgotten by the type
system. As a result, we can use them to allow us to store \emph{any}
type inside of our open sum container. We will constrain this later on.

Although they're not necessary, as we've seen, GADTs provide a nice
interface for defining and working with existential types.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{OpenSum}\NormalTok{ (}\OtherTok{f ::}\NormalTok{ k }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{) (}\OtherTok{ts ::}\NormalTok{ [k]) }\KeywordTok{where} \annotate{1}
  \DataTypeTok{UnsafeOpenSum}  \annotate{2}
\OtherTok{      ::} \DataTypeTok{Int}
      \OtherTok{{-}\textgreater{}}\NormalTok{ f t }\annotate{3}
      \OtherTok{{-}\textgreater{}} \DataTypeTok{OpenSum}\NormalTok{ f ts }\annotate{4}
\end{Highlighting}
\end{Shaded}

At \ann{1} we declare \texttt{OpenSum} as a GADT. It has two parameters,
\texttt{f} of kind \texttt{k\ -\textgreater{}\ Type} and \texttt{ts} of
kind \texttt{{[}k{]}}. We call \texttt{f} an \emph{indexed type}, which
means it provides a \texttt{Type} when given a \texttt{k}. We will talk
more about these parameters in a minute.

The data constructor \VERB|\DataTypeTok{UnsafeOpenSum}| at \ann{2} is
thus named because, well, its unsafe. We'll later provide tools for
constructing \texttt{OpenSum}s safely, but building one via the data
constructor isn't guaranteed to maintain our invariants. It's a common
pattern in type level programming to label raw data constructors as
\VERB|\DataTypeTok{Unsafe}|, and write smart constructors that enforce
the safety.

Looking at \ann{3}, we see that \texttt{OpenSum} is a container of
\texttt{f\ t}, where \texttt{t} has kind \texttt{k}. Because \texttt{t}
isn't mentioned in the return type of our constructor (\ann{4}),
\texttt{t} is existential. Once \texttt{t} enters an \texttt{OpenSum},
it can never be recovered. Knowledge of what \texttt{t} is is lost
forever.

Returning to our parameters, we assign the semantics that the
existential \texttt{t} must be one of the elements of \texttt{ts}. If
\texttt{ts\ \textasciitilde{}\ \textquotesingle{}{[}\ Int,\ Bool,\ String\ {]}},
we know \texttt{t} was originally one of \texttt{Int}, \texttt{Bool} or
\texttt{String}, though we do not necessarily know which.

You might be wondering about the value of the \texttt{f} parameter. Its
presence allows us to add a common shape to all the members of
\texttt{ts}. For example,
\texttt{OpenSum\ ((-\textgreater{})\ String)\ \textquotesingle{}{[}Int,\ Bool{]}}
is capable of storing \texttt{String\ -\textgreater{}\ Int} and
\texttt{String\ -\textgreater{}\ Bool}.

Users who just want to store regular types with no additional structure
should let \texttt{f\ \textasciitilde{}\ Identity}.

The \texttt{OpenSum} data constructor also stores an \texttt{Int}, which
we will use later as a tag to ``remember'' what type the existential
variable \texttt{t} had. It will be used as an index into \texttt{ts}.
For example, if we are storing the number \VERB|\DecValTok{2}| and
\texttt{ts\ \textasciitilde{}\ \textquotesingle{}{[}A,\ B,\ C,\ D{]}},
we understand that originally, \texttt{t\ \textasciitilde{}\ C}.

A first-class type family can be used to find \texttt{t} in \texttt{ts}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{FindElem}\NormalTok{ (}\OtherTok{key ::}\NormalTok{ k) (}\OtherTok{ts ::}\NormalTok{ [k]) }\OtherTok{=}
  \DataTypeTok{FromMaybe} \DataTypeTok{Stuck}  \annotate{1}
    \OperatorTok{=\textless{}\textless{}} \DataTypeTok{FindIndex}\NormalTok{ (}\DataTypeTok{TyEq}\NormalTok{ key) ts}
\end{Highlighting}
\end{Shaded}

\texttt{FindElem} works by looking through \texttt{ts} and comparing the
first element of each tuple with \texttt{key}. The result of
\texttt{FindIndex} is a \texttt{Maybe\ k}, which we then, at \ann{1},
call the type-level equivalent of \VERB|\NormalTok{fromJust}| on. If
\texttt{FindIndex} returned \texttt{\textquotesingle{}Nothing},
\texttt{FindElem} returns \texttt{Stuck}. A stuck type family is one
which can't reduce any further. We can exploit this property and ask
whether \texttt{FindElement} evaluated fully by asking whether it's a
\texttt{KnownNat}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{Member}\NormalTok{ t ts }\OtherTok{=} \DataTypeTok{KnownNat}\NormalTok{ (}\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{FindElem}\NormalTok{ t ts))}
\end{Highlighting}
\end{Shaded}

A benefit of this approach is that a \texttt{KnownNat} constraint allows
for reification of the \texttt{Nat} at the term-level---we can get an
\texttt{Int} corresponding to the \texttt{Nat} we had. Additionally, the
type-level nature of \texttt{FindElem} means we pay no runtime cost for
the computation.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{findElem ::} \KeywordTok{forall}\NormalTok{ t ts}\OperatorTok{.} \DataTypeTok{Member}\NormalTok{ t ts }\OtherTok{=\textgreater{}} \DataTypeTok{Int}
\NormalTok{findElem }\OtherTok{=} \FunctionTok{fromIntegral}
         \OperatorTok{.}\NormalTok{ natVal}
         \OperatorTok{$} \DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{(}\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{FindElem}\NormalTok{ t ts))}
\end{Highlighting}
\end{Shaded}

Armed with \VERB|\NormalTok{findElem}|, we are able to build a smart,
type safe constructor for \texttt{OpenSum}s.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{inj ::} \KeywordTok{forall}\NormalTok{ f t ts}\OperatorTok{.} \DataTypeTok{Member}\NormalTok{ t ts }\OtherTok{=\textgreater{}}\NormalTok{ f t }\OtherTok{{-}\textgreater{}} \DataTypeTok{OpenSum}\NormalTok{ f ts}
\NormalTok{inj }\OtherTok{=} \DataTypeTok{UnsafeOpenSum}\NormalTok{ (findElem }\OperatorTok{@}\NormalTok{t }\OperatorTok{@}\NormalTok{ts)}
\end{Highlighting}
\end{Shaded}

\VERB|\NormalTok{inj}| allows injecting a \texttt{f\ t} into any
\texttt{OpenSum\ f\ ts} so long as \texttt{t} is an element somewhere in
\texttt{ts}. However, nothing about this definition suggests \texttt{ts}
must be monomorphic; it can remain as a type variable so long as we
propagate the \texttt{Member\ t\ ts} constraint upwards.

But a sum type is no good without the ability to try to take things out
of it.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{prj ::} \KeywordTok{forall}\NormalTok{ f t ts}\OperatorTok{.} \DataTypeTok{Member}\NormalTok{ t ts }\OtherTok{=\textgreater{}} \DataTypeTok{OpenSum}\NormalTok{ f ts }\OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ (f t)}
\NormalTok{prj (}\DataTypeTok{UnsafeOpenSum}\NormalTok{ i f) }\OtherTok{=}
  \KeywordTok{if}\NormalTok{ i }\OperatorTok{==}\NormalTok{ findElem }\OperatorTok{@}\NormalTok{t }\OperatorTok{@}\NormalTok{ts }\annotate{1}
     \KeywordTok{then} \DataTypeTok{Just} \OperatorTok{$}\NormalTok{ unsafeCoerce f }\annotate{2}
     \KeywordTok{else} \DataTypeTok{Nothing}
\end{Highlighting}
\end{Shaded}

Projections out of \texttt{OpenSum} are done by a runtime check at
\ann{1} that the \texttt{Int} type tag inside of \texttt{OpenSum} is the
same as the type we're trying to extract it as. If they are the same, at
\ann{2} we know it's safe to perform an \VERB|\NormalTok{unsafeCoerce}|,
convincing the type checker to give back a (non-existential) \texttt{t}.
If the type tags are not the same, \VERB|\NormalTok{prj}| gives back
\VERB|\DataTypeTok{Nothing}|.

We find ourselves wanting to reduce an \texttt{OpenSum} regardless of
whats inside it. \texttt{prj} is no help here---it either succeeds or it
doesn't. If it fails, we the programmers have learned something about
the type inside (what it is \emph{not}). The types don't reflect that
knowledge.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{decompose}
\OtherTok{    ::} \DataTypeTok{OpenSum}\NormalTok{ f (t }\CharTok{\textquotesingle{}: ts)}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Either}\NormalTok{ (f t) (}\DataTypeTok{OpenSum}\NormalTok{ f ts)}
\NormalTok{decompose (}\DataTypeTok{UnsafeOpenSum} \DecValTok{0}\NormalTok{ t) }\OtherTok{=} \DataTypeTok{Left}  \OperatorTok{$}\NormalTok{ unsafeCoerce t}
\NormalTok{decompose (}\DataTypeTok{UnsafeOpenSum}\NormalTok{ n t) }\OtherTok{=} \DataTypeTok{Right}
                              \OperatorTok{$} \DataTypeTok{UnsafeOpenSum}\NormalTok{ (n }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) t}
\end{Highlighting}
\end{Shaded}

The \VERB|\NormalTok{decompose}| function lets us perform induction over
an \texttt{OpenSum}. Either we will get out the type corresponding to
the head of \texttt{ts}, or we will get back a \texttt{OpenSum} with
fewer possibilities. A type tag of 0 corresponds to the head of the type
list, so it is unnecessary to call \VERB|\NormalTok{findElem}|. We
maintain this invariant by decrementing the type tag in the
\VERB|\DataTypeTok{Right}| case.

In practice, it is also useful to be able to \emph{widen} the
possibilities of an open sum. A new function, \VERB|\NormalTok{weaken}|,
tacks a \texttt{x} type in front of the list of possibilities.

\begin{verbatim}
Write `weaken :: OpenSum f ts -> OpenSum f (x ': ts)`{.haskell}
\end{verbatim}

\begin{verbatim}
[code/OpenSum.hs:weaken](Snip)
\end{verbatim}

If we want to perform the same logic regardless of what's inside an
\texttt{OpenSum}, \VERB|\NormalTok{prj}| and
\VERB|\NormalTok{decompose}| both feel inelegant. We introduce
\VERB|\NormalTok{match}| eliminator which consumes an \texttt{OpenSum}
in \(O(1)\) time.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{match}
\OtherTok{    ::} \KeywordTok{forall}\NormalTok{ f ts b}
     \OperatorTok{.}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ t}\OperatorTok{.}\NormalTok{ f t }\OtherTok{{-}\textgreater{}}\NormalTok{ b)  }\annotate{1}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{OpenSum}\NormalTok{ f ts}
    \OtherTok{{-}\textgreater{}}\NormalTok{ b}
\NormalTok{match fn (}\DataTypeTok{UnsafeOpenSum}\NormalTok{ \_ t) }\OtherTok{=}\NormalTok{ fn t}
\end{Highlighting}
\end{Shaded}

By using a rank-n type at \ann{1}, \VERB|\NormalTok{match}| is given a
function that can provide a \texttt{b} \emph{regardless of what's inside
the sum.} In this case, inspecting the type tag isn't necessary.

There is a general principle to take away here. If it's too hard to do
at the type-level, it's OK to cheat and prove things at the term-level.
In these cases, \VERB|\NormalTok{unsafeCoerce}| can be your best
friend---so long as you're careful to hide the unsafe constructors.

\hypertarget{open-products}{%
\section{Open Products}\label{open-products}}

Open products are significantly more involved than their sum duals.
Their implementation is made sticky due to the sheer number of moving
pieces. Not only do open products have several internal types it's
necessary to keep track of, they also require a human-friendly
interface.

Our implementation will associate names with each type inside. These
names can later be used by the user to refer back to the data contained.
As a result, the majority of our implementation will be type-level
book-keeping. Inside the product itself will be nothing new of interest.

We begin by defining a container \texttt{Any} that will existentialize
away its \texttt{k} index. \texttt{Any} is just a name around the same
pattern we did in \texttt{OpenSum}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Any}\NormalTok{ (}\OtherTok{f ::}\NormalTok{ k }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{) }\KeywordTok{where}
  \DataTypeTok{Any}\OtherTok{ ::}\NormalTok{ f t }\OtherTok{{-}\textgreater{}} \DataTypeTok{Any}\NormalTok{ f}
\end{Highlighting}
\end{Shaded}

This implementation of \texttt{OpenProduct} will optimize for \(O(1)\)
reads, and \(O(n)\) writes, although other trade-offs are possible. We
thus define \texttt{OpenProduct} as a \texttt{Data.Vector} of
\texttt{Any}s.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{OpenProduct}\NormalTok{ (}\OtherTok{f  ::}\NormalTok{ k }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{)}
\NormalTok{                 (}\OtherTok{ts ::}\NormalTok{ [(}\DataTypeTok{Symbol}\NormalTok{, k)]) }\KeywordTok{where}  \annotate{1}
  \DataTypeTok{OpenProduct}\OtherTok{ ::} \DataTypeTok{V.Vector}\NormalTok{ (}\DataTypeTok{Any}\NormalTok{ f) }\OtherTok{{-}\textgreater{}} \DataTypeTok{OpenProduct}\NormalTok{ f ts}
\end{Highlighting}
\end{Shaded}

\texttt{OpenProduct} is structured similarly to \texttt{OpenSum}, but
its \texttt{ts} parameter is of kind \texttt{{[}(Symbol,\ k){]}}. The
parameter \texttt{ts} now pulls double duty---not only does it keep
track of which types are stored in our \texttt{Vector\ Any}, but it also
associates names to those pieces of data. We will use these
\texttt{Symbol}s to allow the user to provide his own names for the
contents of the product.

Creating an empty \texttt{OpenProduct} is now possible. It has an empty
\texttt{Vector} and an empty list of types.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{nil ::} \DataTypeTok{OpenProduct}\NormalTok{ f }\CharTok{\textquotesingle{}[]}
\NormalTok{nil }\OtherTok{=} \DataTypeTok{OpenProduct}\NormalTok{ V.empty}
\end{Highlighting}
\end{Shaded}

Because all data inside an \texttt{OpenProduct} will be labeled by a
\texttt{Symbol}, we need a way for users to talk about \texttt{Symbol}s
at the term-level.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Key}\NormalTok{ (}\OtherTok{key ::} \DataTypeTok{Symbol}\NormalTok{) }\OtherTok{=} \DataTypeTok{Key}
\end{Highlighting}
\end{Shaded}

By way of \texttt{-XTypeApplications}, \texttt{Key} allows users to
provide labels for data. For example,
\VERB|\DataTypeTok{Key} \OperatorTok{@}\StringTok{"myData"}| is a value
whose type is \texttt{Key\ "myData"}. Later
Chapter~\ref{sec:OverloadedLabels} we will look at how to lessen the
syntax to build \texttt{Key}s. These are the necessary tools to insert
data into an open product. Given a \texttt{Key\ key} and a
\texttt{f\ k}, we can insert a \texttt{\textquotesingle{}(key,\ k)} into
our \texttt{OpenProduct}.

!snipRename\{OpenProduct\}\{badInsert\}\{insert\}

Our function \VERB|\NormalTok{insert}| adds our new
\texttt{\textquotesingle{}(key,\ k)} to the head of the type list, and
inserts the \texttt{f\ k} to the head of the internal \texttt{Vector}.
In this way, it preserves the invariant that our list of types has the
same ordering as the data in the \texttt{Vector}.

We can test this in GHCi with the \texttt{:t} command.

\begin{Shaded}
\begin{Highlighting}[]

\end{Highlighting}
\end{Shaded}

While this looks good, there is a flaw in our implementation.

\begin{Shaded}
\begin{Highlighting}[]

\end{Highlighting}
\end{Shaded}

Trying to \VERB|\NormalTok{insert}| a duplicate key into an
\texttt{OpenProduct} succeeds. While this isn't necessarily a
\emph{bug}, it's confusing behavior for the user because only one piece
of keyed data will be available to them. We can fix this with a type
family which computes whether a key would be unique.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{UniqueKey}\NormalTok{ (}\OtherTok{key ::}\NormalTok{ k) (}\OtherTok{ts ::}\NormalTok{ [(k, t)])}
  \OtherTok{=} \DataTypeTok{Null} \OperatorTok{=\textless{}\textless{}} \DataTypeTok{Filter}\NormalTok{ (}\DataTypeTok{TyEq}\NormalTok{ key }\OperatorTok{\textless{}=\textless{}} \DataTypeTok{Fst}\NormalTok{) ts}
\end{Highlighting}
\end{Shaded}

\texttt{UniqueKey} is the type-level equivalent of
\VERB|\FunctionTok{null} \OperatorTok{.} \FunctionTok{filter}\NormalTok{ (}\OperatorTok{==}\NormalTok{ key) }\OperatorTok{.} \FunctionTok{fst}|.
If the \texttt{key} doesn't exist in \texttt{ts}, \texttt{UniqueKey}
returns \texttt{\textquotesingle{}True}. We can now fix the
implementation of \VERB|\NormalTok{insert}| by adding a constraint to it
that
\texttt{UniqueKey\ key\ ts\ \textasciitilde{}\ \textquotesingle{}True}.

!snipRename\{OpenProduct\}\{oldInsert\}\{insert\}

GHCi agrees that this fixes the bug.

\begin{Shaded}
\begin{Highlighting}[]

\end{Highlighting}
\end{Shaded}

Informative it is not, but at least it fixes the bug. In the next
chapter, we will look at how to make this error message much friendlier.

To project data out from an open product, we'll first need to write a
getter. This requires doing a lookup in our list of types to figure out
which index of the \texttt{Vector} to return. The implementation is very
similar to that for \texttt{OpenSum}, except that we compare on the key
names instead of the \texttt{k}s themselves.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{FindElem}\NormalTok{ (}\OtherTok{key ::} \DataTypeTok{Symbol}\NormalTok{) (}\OtherTok{ts ::}\NormalTok{ [(}\DataTypeTok{Symbol}\NormalTok{, k)]) }\OtherTok{=}
  \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{FromMaybe} \DataTypeTok{Stuck}
    \OperatorTok{=\textless{}\textless{}} \DataTypeTok{FindIndex}\NormalTok{ (}\DataTypeTok{TyEq}\NormalTok{ key }\OperatorTok{\textless{}=\textless{}} \DataTypeTok{Fst}\NormalTok{) ts)}


\NormalTok{findElem}
\OtherTok{    ::} \KeywordTok{forall}\NormalTok{ key ts}
     \OperatorTok{.} \DataTypeTok{KnownNat}\NormalTok{ (}\DataTypeTok{FindElem}\NormalTok{ key ts)}
    \OtherTok{=\textgreater{}} \DataTypeTok{Int}
\NormalTok{findElem }\OtherTok{=} \FunctionTok{fromIntegral}
         \OperatorTok{.}\NormalTok{ natVal}
         \OperatorTok{$} \DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{(}\DataTypeTok{FindElem}\NormalTok{ key ts)}
\end{Highlighting}
\end{Shaded}

We will also require another type family to index into \texttt{ts} and
determine what type to return from \VERB|\NormalTok{get}|.
\texttt{LookupType} returns the \texttt{k} associated with the
\texttt{key}ed \texttt{Symbol}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{LookupType}\NormalTok{ (}\OtherTok{key ::}\NormalTok{ k) (}\OtherTok{ts ::}\NormalTok{ [(k, t)]) }\OtherTok{=}
  \DataTypeTok{FromMaybe} \DataTypeTok{Stuck} \OperatorTok{=\textless{}\textless{}} \DataTypeTok{Lookup}\NormalTok{ key ts}


\NormalTok{get}
\OtherTok{    ::} \KeywordTok{forall}\NormalTok{ key ts f}
     \OperatorTok{.} \DataTypeTok{KnownNat}\NormalTok{ (}\DataTypeTok{FindElem}\NormalTok{ key ts)}
    \OtherTok{=\textgreater{}} \DataTypeTok{Key}\NormalTok{ key}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{OpenProduct}\NormalTok{ f ts}
    \OtherTok{{-}\textgreater{}}\NormalTok{ f (}\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{LookupType}\NormalTok{ key ts)) }\annotate{1}
\NormalTok{get \_ (}\DataTypeTok{OpenProduct}\NormalTok{ v) }\OtherTok{=}
\NormalTok{    unAny }\OperatorTok{$}\NormalTok{ V.unsafeIndex v }\OperatorTok{$}\NormalTok{ findElem }\OperatorTok{@}\NormalTok{key }\OperatorTok{@}\NormalTok{ts}
  \KeywordTok{where}
\NormalTok{    unAny (}\DataTypeTok{Any}\NormalTok{ a) }\OtherTok{=}\NormalTok{ unsafeCoerce a  }\annotate{2}
\end{Highlighting}
\end{Shaded}

At \ann{1}, we say the return type of \VERB|\NormalTok{get}| is
\texttt{f} indexed by the result of \texttt{LookupType\ key\ ts}. Since
we've been careful in maintaining our invariant that the types wrapped
in our \texttt{Vector} correspond exactly with those in \texttt{ts}, we
know it's safe to \VERB|\NormalTok{unsafeCoerce}| at \ann{2}.

As one last example for open products, let's add the ability to modify
the value at a key. There is no constraint that the new value has the
same type as the old one. As usual, we begin with a first-class type
family that will compute our new associated type list.
\texttt{UpdateElem} scans through \texttt{ts} and sets the type
associated with \texttt{key} to \texttt{t}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{UpdateElem}\NormalTok{ (}\OtherTok{key ::} \DataTypeTok{Symbol}\NormalTok{) (}\OtherTok{t ::}\NormalTok{ k) (}\OtherTok{ts ::}\NormalTok{ [(}\DataTypeTok{Symbol}\NormalTok{, k)]) }\OtherTok{=}
  \DataTypeTok{SetIndex}\NormalTok{ (}\DataTypeTok{FindElem}\NormalTok{ key ts) }\CharTok{\textquotesingle{}(key, t) ts}
\end{Highlighting}
\end{Shaded}

The implementation of \VERB|\NormalTok{update}| is rather predictable;
we update the value stored in our \texttt{Vector} at the same place we
want to replace the type in \texttt{ts}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{update}
\OtherTok{    ::} \KeywordTok{forall}\NormalTok{ key ts t f}
     \OperatorTok{.} \DataTypeTok{KnownNat}\NormalTok{ (}\DataTypeTok{FindElem}\NormalTok{ key ts)}
    \OtherTok{=\textgreater{}} \DataTypeTok{Key}\NormalTok{ key}
    \OtherTok{{-}\textgreater{}}\NormalTok{ f t}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{OpenProduct}\NormalTok{ f ts}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{OpenProduct}\NormalTok{ f (}\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{UpdateElem}\NormalTok{ key t ts))}
\NormalTok{update \_ ft (}\DataTypeTok{OpenProduct}\NormalTok{ v) }\OtherTok{=}
  \DataTypeTok{OpenProduct} \OperatorTok{$}\NormalTok{ v }\OperatorTok{V.//}\NormalTok{ [(findElem }\OperatorTok{@}\NormalTok{key }\OperatorTok{@}\NormalTok{ts, }\DataTypeTok{Any}\NormalTok{ ft)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Implement `delete`{.haskell} for `OpenProduct`s.
\end{verbatim}

\begin{verbatim}
[code/OpenProduct.hs:delete](Snip)
\end{verbatim}

\begin{verbatim}
Implement `upsert`{.haskell} (update or insert) for `OpenProduct`s.

  Hint: write a type family to compute a `Maybe Nat` corresponding to the
  index of the key in the list of types, if it exists. Use class instances to
  lower this kind to the term-level, and then pattern match on it to implement
  `upsert`{.haskell}.
\end{verbatim}

\begin{verbatim}
This is a particularly involved exercise. We begin by writing a FCF to compute
  the resultant type of the `upsert`{.haskell}:

[code/OpenProduct.hs:UpsertElem](Snip)

  Notice that at [1](Ann) we refer to `Placeholder1Of3`---which is a little
  hack to get around the lack of type-level lambdas in FCFs. Its definition is
  this:

[code/OpenProduct.hs:Placeholder1Of3](Snip)
[code/OpenProduct.hs:EvalPlaceholder](Snip)

  The actual implementation of `upsert`{.haskell} requires knowing whether we should
  insert or update. We will need to compute a `Maybe Nat` for the type in
  question:

[code/OpenProduct.hs:UpsertLoc](Snip)

  And we can use a typeclass to lower this the `Maybe Nat` into a `Maybe
  Int`:

[code/OpenProduct.hs:FindUpsertElem](Snip)
[code/OpenProduct.hs:FindUpsertNothing](Snip)
[code/OpenProduct.hs:FindUpsertJust](Snip)

  Finally, we're capable of writing `upsert`{.haskell}:

[code/OpenProduct.hs:upsert](Snip)
\end{verbatim}

\hypertarget{overloaded-labels}{%
\section{Overloaded Labels}\label{overloaded-labels}}

We earlier promised to revisit the syntax behind \texttt{Key}. Working
with \texttt{OpenProducts} doesn't yet bring us joy, mostly due to the
syntactic noise behind constructing \texttt{Key}s. Consider
\VERB|\NormalTok{get (}\DataTypeTok{Key} \OperatorTok{@}\StringTok{"example"}\NormalTok{) foo}|;
there are nine bytes of boilerplate syntactic overhead. While this
doesn't seem like a lot, it weighs on the potential users of our
library. You'd be surprised by how often things like these cause users
to reach for lighter-weight alternatives.

Thankfully, there \emph{is} a lighter-weight alternative. They're known
as overloaded labels, and can turn our earlier snippet into
\VERB|\NormalTok{get \textbackslash{}}\OperatorTok{\#}\NormalTok{example foo}|.

Overloaded labels are enabled by turning on \texttt{-XOverloadedLabels}.
This extension gives us access to the
\VERB|\NormalTok{\textbackslash{}}\OperatorTok{\#}\NormalTok{foo}|
syntax, which gets desugared as
\VERB|\NormalTok{fromLabel }\OperatorTok{@}\StringTok{"foo"}\OtherTok{ ::}\NormalTok{ a}|
and asks the type system to solve a \texttt{IsLabel\ "foo"\ a}
constraint. Therefore, all we need to do is provide an instance of
\texttt{IsLabel} for \texttt{Key}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ (key }\OperatorTok{\textasciitilde{}}\NormalTok{ key\textquotesingle{}) }\annotate{1}
      \OtherTok{=\textgreater{}} \DataTypeTok{IsLabel}\NormalTok{ key (}\DataTypeTok{Key}\NormalTok{ key\textquotesingle{}) }\KeywordTok{where}
\NormalTok{  fromLabel }\OtherTok{=} \DataTypeTok{Key}
\end{Highlighting}
\end{Shaded}

Notice that the instance head is \emph{not} of the form
\VERB|\DataTypeTok{IsLabel}\NormalTok{ key (}\DataTypeTok{Key}\NormalTok{ key)}|,
but instead has two type variables (\texttt{key} and
\texttt{key\textquotesingle{}}) which are then asserted to be the same
(\ann{1}). This odd phrasing is due to a quirk with Haskell's instance
resolution, and is known as the constraint trick.

The machinery behind instance resolution is unintuitive. It will only
match instance heads (the part that comes after the fat constraint arrow
\VERB|\OtherTok{=\textgreater{}}|). The instance head of
\VERB|\NormalTok{(}\DataTypeTok{Eq}\NormalTok{ a, }\DataTypeTok{Eq}\NormalTok{ b) }\OtherTok{=\textgreater{}} \DataTypeTok{Eq}\NormalTok{ (a, b)}|
is \VERB|\DataTypeTok{Eq}\NormalTok{ (a, b)}|. Once it has matched an
instance head, Haskell will work backwards and only then try to solve
the context
(\VERB|\NormalTok{(}\DataTypeTok{Eq}\NormalTok{ a, }\DataTypeTok{Eq}\NormalTok{ b)}|
in this example.) All of this is to say that the context is not
considered when matching looking for typeclass instances.

It is this unintuitive property of instance resolution that makes the
constraint trick necessary. Notice how when we're looking for key
\VERB|\NormalTok{\textbackslash{}}\OperatorTok{\#}\NormalTok{foo}|,
there is nothing constraining our return type to be \texttt{Key\ "foo"}.
Because of this, the instance Haskell looks for is
\VERB|\DataTypeTok{IsLabel} \StringTok{"foo"}\NormalTok{ (}\DataTypeTok{Key}\NormalTok{ a)}|.

If our instance definition were of the form
\VERB|\KeywordTok{instance} \DataTypeTok{IsLabel}\NormalTok{ key (}\DataTypeTok{Key}\NormalTok{ key)}|,
this head \emph{won't} match
\VERB|\DataTypeTok{IsLabel} \StringTok{"foo"}\NormalTok{ (}\DataTypeTok{Key}\NormalTok{ a)}|,
because Haskell has no guarantees \texttt{"foo"\ \textasciitilde{}\ a}.
Perhaps we can reason that this must be the case, because that is the
only relevant instance of \texttt{IsLabel}---but again, Haskell has no
guarantees that someone won't later provide a different, non-overlapping
instance.

By using the constraint trick, an instance head of the form
\VERB|\DataTypeTok{IsLabel}\NormalTok{ key (}\DataTypeTok{Key}\NormalTok{ key\textquotesingle{})}|
allows Haskell to find this instance when looking for
\texttt{IsLabel\ "foo"\ (Key\ a)}. It unifies
\texttt{key\ \textasciitilde{}\ "foo"} and
\texttt{key\textquotesingle{}\ \textasciitilde{}\ a}, and then will
expand the context of our instance. When it does, it learns that
\texttt{key\ \textasciitilde{}\ key\textquotesingle{}}, and finally that
\texttt{a\ \textasciitilde{}\ "foo"}. It's roundabout, but it gets there
in the end.

The definition of \texttt{IsLabel} can be found in
\texttt{GHC.OverloadedLabels}.

\hypertarget{custom-type-errors}{%
\chapter{Custom Type Errors}\label{custom-type-errors}}

\texttt{OpenSum} and \texttt{OpenProduct} are impressive when used
correctly. But the type errors that come along with their misuse are
nothing short of nightmarish and unhelpful. For example:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ foo }\OtherTok{=}\NormalTok{ inj (}\DataTypeTok{Identity} \DataTypeTok{True}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{OpenSum} \DataTypeTok{Identity} \CharTok{\textquotesingle{}[Bool, String]}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

As a user, when we do something wrong we're barraged by meaningless
errors about implementation details. As library writers, this breakdown
in user experience is nothing short of a failure in our library. A
type-safe library is of no value if nobody knows how to use it.

Fortunately, GHC provides the ability to construct custom type errors.
The module \texttt{GHC.TypeLits} defines the type \texttt{TypeError} of
kind \texttt{ErrorMessage\ -\textgreater{}\ k}. The semantics of
\texttt{TypeError} is that if GHC is ever asked to solve one, it emits
the given type error instead, and refuse to compile. Because
\texttt{TypeError} is polykinded, we can put it anywhere we'd like at
the type-level.

The following four means of constructing \texttt{ErrorMessage}s are
available to us.

\begin{itemize}
\tightlist
\item
  \texttt{\textquotesingle{}Text} (of kind
  \texttt{Symbol\ -\textgreater{}\ ErrorMessage}.) Emits the symbol
  verbatim. Note that this is \emph{not} \texttt{Data.Text.Text}.

  \begin{itemize}
  \tightlist
  \item
    \texttt{\textquotesingle{}ShowType} (of kind
    \texttt{k\ -\textgreater{}\ ErrorMessage}.) Prints the name of the
    given type.
  \item
    \texttt{\textquotesingle{}(:\textless{}\textgreater{}:)} (of kind
    \texttt{ErrorMessage\ -\textgreater{}\ ErrorMessage\ -\textgreater{}\ ErrorMessage}.)
    Concatenate two \texttt{ErrorMessage}s side-by-side.
  \item
    \texttt{\textquotesingle{}(:\textbackslash{}\$\textbackslash{}\$:)}
    (of kind
    \texttt{ErrorMessage\ -\textgreater{}\ ErrorMessage\ -\textgreater{}\ ErrorMessage}.)
    Append one \texttt{ErrorMessage} vertically atop another.
  \end{itemize}
\end{itemize}

\texttt{TypeError} is usually used as a constraint in an instance
context, or as the result of a type family. As an illustration, we can
provide a more helpful error message when Haskell tries to solve a
\texttt{Num} instance for functions. Recall that the usual error message
is not particularly useful:

\begin{Shaded}
\begin{Highlighting}[]

\end{Highlighting}
\end{Shaded}

However, by bringing the following instance into scope:

\href{Snip}{code/Misc.hs:pragmas} \href{Snip}{code/Misc.hs:showFunc}

We now get a more helpful solution to what might be wrong:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \DecValTok{1} \DataTypeTok{True}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

When evaluating \VERB|\DecValTok{1} \DataTypeTok{True}|, Haskell matches
the instance head of \texttt{Num\ (a\ -\textgreater{}\ b)}, and then
attempts to solve its context. Recall that whenever GHC sees a
\texttt{TypeError}, it fails with the given message. We can use this
principle to emit a friendlier type error when using
\VERB|\NormalTok{prj}| incorrectly.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{family} \DataTypeTok{FriendlyFindElem}\NormalTok{ (}\OtherTok{f ::}\NormalTok{ k }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{) (}\OtherTok{t ::}\NormalTok{ k) (}\OtherTok{ts ::}\NormalTok{ [k]) }\KeywordTok{where}
  \DataTypeTok{FriendlyFindElem}\NormalTok{ f t ts }\OtherTok{=}
    \DataTypeTok{FromMaybe}
\NormalTok{         ( }\DataTypeTok{TypeError}
\NormalTok{         ( }\DataTypeTok{\textquotesingle{}Text} \StringTok{"Attempted to call \textasciigrave{}friendlyPrj\textquotesingle{} to produce a \textasciigrave{}"}
     \CharTok{\textquotesingle{}:\textless{}\textgreater{}: \textquotesingle{}}\DataTypeTok{ShowType}\NormalTok{ (f t)}
     \CharTok{\textquotesingle{}:\textless{}\textgreater{}: \textquotesingle{}}\DataTypeTok{Text} \StringTok{"\textquotesingle{}."}
     \CharTok{\textquotesingle{}:$$: \textquotesingle{}}\DataTypeTok{Text} \StringTok{"But the OpenSum can only contain one of:"}
     \CharTok{\textquotesingle{}:$$: \textquotesingle{}}\DataTypeTok{Text} \StringTok{"  "}
     \CharTok{\textquotesingle{}:\textless{}\textgreater{}: \textquotesingle{}}\DataTypeTok{ShowType}\NormalTok{ ts}
\NormalTok{         )) }\OperatorTok{=\textless{}\textless{}} \DataTypeTok{FindIndex}\NormalTok{ (}\DataTypeTok{TyEq}\NormalTok{ t) ts}
\end{Highlighting}
\end{Shaded}

Notice that \texttt{FriendlyFindElem} is defined as a \emph{type
family}, rather than a \emph{type synonym} as FCFs usually are. This is
to delay the expansion of the type error so GHC doesn't emit the error
immediately. We now attempt to find \texttt{t} in \texttt{ts}, and use
\texttt{FromMaybe} to emit a type error in the case that we didn't find
it.

Rewriting \VERB|\NormalTok{prj}| to use
\texttt{KnownNat\ (FriendlyFindElem\ t\ ts\ f\ ts)} instead of
\texttt{Member\ t\ ts} is enough to fix our error messages.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ foo }\OtherTok{=}\NormalTok{ inj (}\DataTypeTok{Identity} \DataTypeTok{True}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{OpenSum} \DataTypeTok{Identity} \CharTok{\textquotesingle{}[Bool, String]}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

Let's return to the example of \VERB|\NormalTok{insert}| for
\texttt{OpenProduct}. Recall the
\texttt{UniqueKey\ key\ ts\ \textasciitilde{}\ \textquotesingle{}True}
constraint we added to prevent duplicate keys.

!snipRename\{OpenProduct\}\{oldInsert\}\{insert\}

This is another good place to add a custom type error; it's likely to
happen, and the default one GHC will emit is unhelpful at best and
horrendous at worst. Because \texttt{UniqueKey} is already a type family
that can't get stuck (ie. is total), we can write another type family
that will conditionally produce the error.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{family} \DataTypeTok{RequireUniqueKey}
\NormalTok{      (}\OtherTok{result ::} \DataTypeTok{Bool}\NormalTok{)  }\annotate{1}
\NormalTok{      (}\OtherTok{key ::} \DataTypeTok{Symbol}\NormalTok{)}
\NormalTok{      (}\OtherTok{t ::}\NormalTok{ k)}
\NormalTok{      (}\OtherTok{ts ::}\NormalTok{ [(}\DataTypeTok{Symbol}\NormalTok{, k)])}\OtherTok{ ::} \DataTypeTok{Constraint} \KeywordTok{where}
  \DataTypeTok{RequireUniqueKey} \DataTypeTok{\textquotesingle{}True}\NormalTok{  key t ts }\OtherTok{=}\NormalTok{ ()  }\annotate{2}
  \DataTypeTok{RequireUniqueKey} \DataTypeTok{\textquotesingle{}False}\NormalTok{ key t ts }\OtherTok{=}
    \DataTypeTok{TypeError}
\NormalTok{         ( }\DataTypeTok{\textquotesingle{}Text} \StringTok{"Attempting to add a field named \textasciigrave{}"}
     \CharTok{\textquotesingle{}:\textless{}\textgreater{}: \textquotesingle{}}\DataTypeTok{Text}\NormalTok{ key}
     \CharTok{\textquotesingle{}:\textless{}\textgreater{}: \textquotesingle{}}\DataTypeTok{Text} \StringTok{"\textquotesingle{} with type "}
     \CharTok{\textquotesingle{}:\textless{}\textgreater{}: \textquotesingle{}}\DataTypeTok{ShowType}\NormalTok{ t}
     \CharTok{\textquotesingle{}:\textless{}\textgreater{}: \textquotesingle{}}\DataTypeTok{Text} \StringTok{" to an OpenProduct."}
     \CharTok{\textquotesingle{}:$$: \textquotesingle{}}\DataTypeTok{Text} \StringTok{"But the OpenProduct already has a field \textasciigrave{}"}
     \CharTok{\textquotesingle{}:\textless{}\textgreater{}: \textquotesingle{}}\DataTypeTok{Text}\NormalTok{ key}
     \CharTok{\textquotesingle{}:\textless{}\textgreater{}: \textquotesingle{}}\DataTypeTok{Text} \StringTok{"\textquotesingle{} with type "}
     \CharTok{\textquotesingle{}:\textless{}\textgreater{}: \textquotesingle{}}\DataTypeTok{ShowType}\NormalTok{ (}\DataTypeTok{LookupType}\NormalTok{ key ts)}
     \CharTok{\textquotesingle{}:$$: \textquotesingle{}}\DataTypeTok{Text} \StringTok{"Consider using \textasciigrave{}update\textquotesingle{} "}  \annotate{3}
     \CharTok{\textquotesingle{}:\textless{}\textgreater{}: \textquotesingle{}}\DataTypeTok{Text} \StringTok{"instead of \textasciigrave{}insert\textquotesingle{}."}
\NormalTok{         )}
\end{Highlighting}
\end{Shaded}

\texttt{RequireUniqueKey} is intended to be called as
\texttt{RequireUniqueKey\ (UniqueKey\ key\ ts)\ key\ t\ ts}. The
\texttt{Bool} at \ann{1} is the result of calling \texttt{UniqueKey},
and it is pattern matched on. At \ann{2}, if it's
\texttt{\textquotesingle{}True}, \texttt{RequireUniqueKey} emits the
unit constraint \texttt{()} . As a \texttt{Constraint}, \texttt{()} is
trivially satisfied.

Notice that at \ann{3} we helpfully suggest a solution. This is good
form in any libraries you write. Your users will thank you for it.

We can now rewrite \VERB|\NormalTok{insert}| with our new constraint.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{insert}
\OtherTok{    ::} \DataTypeTok{RequireUniqueKey}\NormalTok{ (}\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{UniqueKey}\NormalTok{ key ts)) key t ts}
    \OtherTok{=\textgreater{}} \DataTypeTok{Key}\NormalTok{ key}
    \OtherTok{{-}\textgreater{}}\NormalTok{ f t}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{OpenProduct}\NormalTok{ f ts}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{OpenProduct}\NormalTok{ f (}\CharTok{\textquotesingle{}(key, t) \textquotesingle{}}\OperatorTok{:}\NormalTok{ ts)}
\NormalTok{insert \_ ft (}\DataTypeTok{OpenProduct}\NormalTok{ v) }\OtherTok{=}
  \DataTypeTok{OpenProduct} \OperatorTok{$}\NormalTok{ V.cons (}\DataTypeTok{Any}\NormalTok{ ft) v}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Add helpful type errors to `OpenProduct`'s `update`{.haskell} and
`delete`{.haskell} functions.
\end{verbatim}

\begin{verbatim}
[code/OpenProduct.hs:FriendlyFindElem](Snip)
!snipRename{OpenProduct}{friendlyUpdate}{update}
!snipRename{OpenProduct}{friendlyDelete}{delete}

These functions could be cleaned up a little by moving the `FriendlyFindElem`
  constraint to `findElem`, which would remove the need for both constraints.
\end{verbatim}

\begin{verbatim}
Write a closed type family of kind `[k] -> ErrorMessage` that
pretty prints a list. Use it to improve the error message from
`FriendlyFindElem`.
\end{verbatim}

\begin{verbatim}
[code/OpenProduct.hs:ShowList](Snip)
[code/OpenProduct.hs:FriendlyFindElem2](Snip)
\end{verbatim}

\begin{verbatim}
See what happens when you directly add a `TypeError` to the context
of a function (eg. `foo :: TypeError ... => a`{.haskell}). What happens? Do you know
why?
\end{verbatim}

\begin{verbatim}
GHC will throw the error message immediately upon attempting to compile the
  module.

The reason why is because the compiler will attempt to discharge any extraneous
  constraints (for example, `Show Int` is always in scope, and so it can
  automatically be discharged.) This machinery causes the type error to be seen,
  and thus thrown.
\end{verbatim}

\hypertarget{generics}{%
\chapter{Generics}\label{generics}}

When writing Haskell, we have two tools in our belt for introducing
polymorphism: parametric and ad-hoc polymorphism.

Parametric polymorphism gives one definition for every possible type
(think
\VERB|\FunctionTok{head}\OtherTok{ ::}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ a}|.)
It's what you get when you write a standard Haskell function with type
variables. This flavor of polymorphism is predictable---the same
function must always do the same thing, regardless of the types it's
called with.

Ad-hoc polymorphism, like its name implies, allows us to write a
different implementation for every type---as made possible by
typeclasses.

But for our purposes, there's also a third category---a sort of no man's
land between the parametric and the ad-hoc: structural polymorphism.
Structural polymorphism is ad-hoc in the sense of being different for
each type, but it is also highly regular and predictable. It's what's
colloquially known as ``boilerplate.'' It's the boring, uninteresting
code that is repetitive but just different enough to be hard to automate
away. While structural polymorphism doesn't have any formal definition,
it's the sort of thing you recognize when you see it.

\texttt{Eq}, \texttt{Show} and \texttt{Functor} instances are good
examples of structural polymorphism---there's nothing interesting about
writing these instances. The tedium of writing boilerplate polymorphism
is somewhat assuaged by the compiler's willingness to write some of them
for us.

Consider the \texttt{Eq} typeclass; while every type needs its own
implementation of \VERB|\NormalTok{(}\OperatorTok{==}\NormalTok{)}|,
these implementations are always of the form:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{Eq}\NormalTok{ a, }\DataTypeTok{Eq}\NormalTok{ b, }\DataTypeTok{Eq}\NormalTok{ c)}
      \OtherTok{=\textgreater{}} \DataTypeTok{Eq}\NormalTok{ (}\DataTypeTok{Foo}\NormalTok{ a b c) }\KeywordTok{where}
  \DataTypeTok{F0}       \OperatorTok{==} \DataTypeTok{F0}       \OtherTok{=} \DataTypeTok{True}
  \DataTypeTok{F1}\NormalTok{ a1    }\OperatorTok{==} \DataTypeTok{F1}\NormalTok{ a2    }\OtherTok{=}\NormalTok{ a1 }\OperatorTok{==}\NormalTok{ a2}
  \DataTypeTok{F2}\NormalTok{ b1 c1 }\OperatorTok{==} \DataTypeTok{F2}\NormalTok{ b2 c2 }\OtherTok{=}\NormalTok{ b1 }\OperatorTok{==}\NormalTok{ b2 }\OperatorTok{\&\&}\NormalTok{ c1 }\OperatorTok{==}\NormalTok{ c2}
\end{Highlighting}
\end{Shaded}

There's no creativity involved in writing an \texttt{Eq} instance, nor
should there be. The same data constructors are equal if and only if all
of their components are equal.

Structural polymorphism is mindless work to write, but needs to be done.
In the case of some of the standard Haskell typeclasses, GHC is capable
of writing these instances for you via the \VERB|\KeywordTok{deriving}|
machinery. Unfortunately, for custom typeclasses we're on our own,
without any direct support from the compiler.

As terrible as this situation appears, all hope is not lost. Using
\VERB|\DataTypeTok{GHC.Generics}|, we're capable of writing our own
machinery for helping GHC derive our typeclasses, all in regular Haskell
code.

\hypertarget{generic-representations}{%
\section{Generic Representations}\label{generic-representations}}

Recall that all types have a canonical representation as a
sum-of-products---that they can all be built from \texttt{Either}s of
\texttt{(,)}s. For example, \texttt{Maybe\ a}, which is defined as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Maybe}\NormalTok{ a}
  \OtherTok{=} \DataTypeTok{Just}\NormalTok{ a}
  \OperatorTok{|} \DataTypeTok{Nothing}
\end{Highlighting}
\end{Shaded}

\texttt{Maybe\ a} has a canonical sum-of-products form as
\texttt{Either\ ()\ a}. This can be proven via an isomorphism:

\href{Snip}{code/DeriveAnyClass.hs:toCanonical}
\href{Snip}{code/DeriveAnyClass.hs:fromCanonical}

\VERB|\NormalTok{toCanonical}| and \VERB|\NormalTok{fromCanonical}|
convert between \texttt{Maybe\ a} and \texttt{Either\ ()\ a} without
losing any information. This witnesses an isomorphism between the two
types.

Why is this an interesting fact? Well, if we have a small number of
primitive building blocks, we can write code that is generic over those
primitives. Combined with the ability to convert to and from canonical
representations, we have the workings for dealing with structural
polymorphism.

How can such a thing be possible? The secret is in the
\texttt{-XDeriveGeneric} extension, which will automatically derive an
instance of \texttt{Generic} for you:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Generic}\NormalTok{ a }\KeywordTok{where}
  \KeywordTok{type} \DataTypeTok{Rep}\OtherTok{ a ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type}  \annotate{1}
\OtherTok{  from ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Rep}\NormalTok{ a x  }\annotate{2}
\OtherTok{  to   ::} \DataTypeTok{Rep}\NormalTok{ a x }\OtherTok{{-}\textgreater{}}\NormalTok{ a  }\annotate{3}
\end{Highlighting}
\end{Shaded}

The associated type \VERB|\DataTypeTok{Rep}\NormalTok{ a}| at \ann{1}
corresponds to the canonical form of the type \texttt{a}. Notice however
the kinds; while \texttt{a} has kind \texttt{Type}, \texttt{Rep\ a} is
of kind \texttt{Type\ -\textgreater{}\ Type}. We will investigate why
this is the case in a moment.

The functions \VERB|\NormalTok{from}| and \VERB|\NormalTok{to}| at
\ann{2} and \ann{3} form the isomorphism between \texttt{a} and
\texttt{Rep\ a}. Somewhat confusingly, their implied directionality
might be the opposite of what you'd expect. \VERB|\NormalTok{to}|
converts \emph{to} the usual (type \VERB|\NormalTok{a}|) form, and
\VERB|\NormalTok{from}| converts \emph{from} the usual form.

Let's look at \texttt{Rep\ Bool} for inspiration about what this thing
might look like.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{Rep} \DataTypeTok{Bool}
\DataTypeTok{Rep} \DataTypeTok{Bool}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type}
\OtherTok{=} \DataTypeTok{D1}
\NormalTok{    (}\DataTypeTok{\textquotesingle{}MetaData} \StringTok{"Bool"} \StringTok{"GHC.Types"} \StringTok{"ghc{-}prim"} \DataTypeTok{\textquotesingle{}False}\NormalTok{)}
\NormalTok{    (}\DataTypeTok{C1}\NormalTok{ (}\DataTypeTok{\textquotesingle{}MetaCons} \StringTok{"False"} \DataTypeTok{\textquotesingle{}PrefixI} \DataTypeTok{\textquotesingle{}False}\NormalTok{) }\DataTypeTok{U1}
     \OperatorTok{:+:} \DataTypeTok{C1}\NormalTok{ (}\DataTypeTok{\textquotesingle{}MetaCons} \StringTok{"True"} \DataTypeTok{\textquotesingle{}PrefixI} \DataTypeTok{\textquotesingle{}False}\NormalTok{) }\DataTypeTok{U1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Quite a mouthful, but at it's heart the interesting parts of this are
the \texttt{(:+:)} and \texttt{U1} types. These correspond to the
canonical sum and canonical unit, respectively. Cutting out some of the
excess data for a second, we can see the gentle shape of \texttt{Bool}
peeking out.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{Rep} \DataTypeTok{Bool}
  \OtherTok{=} \OperatorTok{...}
\NormalTok{      ( }\OperatorTok{...} \DataTypeTok{U1}
    \OperatorTok{:+:} \OperatorTok{...} \DataTypeTok{U1}
\NormalTok{      )}
\end{Highlighting}
\end{Shaded}

Compare this against the definition of \texttt{Bool} itself.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Bool}
  \OtherTok{=} \DataTypeTok{False}
  \OperatorTok{|} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

The \texttt{(:+:)} type is the canonical analogue of the
\VERB|\OperatorTok{\VerbBar{}}| that separates data constructors from
one another. And because \VERB|\DataTypeTok{True}| and
\VERB|\DataTypeTok{False}| contain no information, each is isomorphic to
the unit type \VERB|\NormalTok{()}|. As a result, the canonical
representation of \VERB|\DataTypeTok{Bool}| is conceptually just
\texttt{Either\ ()\ ()}, or in its \texttt{GHC.Generics} form as
\texttt{...\ (...\ U1\ :+:\ ...\ U1)}.

With some idea of what's going on, let's look again at
\texttt{Rep\ Bool}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{Rep} \DataTypeTok{Bool}
\DataTypeTok{Rep} \DataTypeTok{Bool}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type}
\OtherTok{=} \DataTypeTok{D1}
\NormalTok{    (}\DataTypeTok{\textquotesingle{}MetaData} \StringTok{"Bool"} \StringTok{"GHC.Types"} \StringTok{"ghc{-}prim"} \DataTypeTok{\textquotesingle{}False}\NormalTok{)}
\NormalTok{    (}\DataTypeTok{C1}\NormalTok{ (}\DataTypeTok{\textquotesingle{}MetaCons} \StringTok{"False"} \DataTypeTok{\textquotesingle{}PrefixI} \DataTypeTok{\textquotesingle{}False}\NormalTok{) }\DataTypeTok{U1}
     \OperatorTok{:+:} \DataTypeTok{C1}\NormalTok{ (}\DataTypeTok{\textquotesingle{}MetaCons} \StringTok{"True"} \DataTypeTok{\textquotesingle{}PrefixI} \DataTypeTok{\textquotesingle{}False}\NormalTok{) }\DataTypeTok{U1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{D1} and \texttt{C1} types contain metadata about
\texttt{Bool}'s definition in source code as promoted
\texttt{-XDataKinds}. \texttt{D1} describes its \emph{type}---its name,
where it was defined, and whether or not it's a newtype.

\texttt{C1} describes a data constructor---its name, fixity definition,
and whether or not it has record selectors for its data.

Structural polymorphism that is interested in any of this information is
capable of extracting it statically from these data kinds, and code that
isn't can easily ignore it. In my experience, very rarely will you need
access to these things, but it's nice to have the option.

\hypertarget{deriving-structural-polymorphism}{%
\section{Deriving Structural
Polymorphism}\label{deriving-structural-polymorphism}}

Armed with the knowledge of \texttt{Rep}, we can write an illustrative
example of generically deriving \texttt{Eq}. Of course, it's unnecessary
because \texttt{Eq} is one of those classes the compiler can write for
us. Nevertheless, it's a good introduction to the topic, and we must
walk before we can run. We will look at more challenging classes
afterwards.

The approach to generically deriving structural polymorphism is
threefold:

\begin{itemize}
\tightlist
\item
  Define a typeclass to act as a carrier.

  \begin{itemize}
  \tightlist
  \item
    Provide inductive instances of the class for the generic
    constructors.
  \item
    Finally, write a helper function to map between the \texttt{Rep} and
    the desired type.
  \end{itemize}
\end{itemize}

We begin by defining our carrier typeclass. The carrier mirrors the
typeclass we'd like to derive, but is shaped to be able to give
instances for the \texttt{Rep} constructors.

A good convention is add a \VERB|\DataTypeTok{G}| prefix to the carrier
typeclass---if you want to derive \texttt{Eq} generically, call your
carrier typeclass \texttt{GEq}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{GEq}\NormalTok{ a }\KeywordTok{where}
\OtherTok{  geq ::}\NormalTok{ a x }\OtherTok{{-}\textgreater{}}\NormalTok{ a x }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\end{Highlighting}
\end{Shaded}

Our \texttt{GEq} class has a single method, \VERB|\NormalTok{geq}|,
whose signature closely matches
\VERB|\OtherTok{(==) ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}|.

Notice that the type parameter \texttt{a} to \texttt{GEq} has kind
\texttt{Type\ -\textgreater{}\ Type}. This is a quirk of
\texttt{GHC.Generics}, and allows the same \texttt{Rep} machinery when
dealing with higher-kinded classes. When writing carrier classes for
types of kind \texttt{Type}, we will always saturate \texttt{a} with a
dummy type \texttt{x} whose only purpose is to make the whole thing kind
check.

With our carrier defined, the next step is to provide instances for the
generic \texttt{Rep} constructors. A good approach when writing generic
instances is to work ``inside-out.'' Start with the innermost
constructors (\texttt{U1}, \texttt{V1}, and \texttt{K1},) as these are
the base cases of our structural induction.

In this case, \texttt{U1} is the simplest, so we will start there.
Recall that \texttt{U1} represents a data constructor with no
parameters, in which case it's just \texttt{()} with a different name.
Since \texttt{()} is always equal to itself, so too should \texttt{U1}
be.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{GEq} \DataTypeTok{U1} \KeywordTok{where}
\NormalTok{  geq }\DataTypeTok{U1} \DataTypeTok{U1} \OtherTok{=} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

Similarly for \texttt{V1} which corresponds to types that can't be
constructed. \texttt{V1} is the generic representation of
\texttt{Void}---the \texttt{Type} with no inhabitants. It might seem
silly to provide an \texttt{Eq} instance for such types, but it costs us
nothing. Consider instances over \texttt{V1} as being vacuous; if you
\emph{could} give me a value of \texttt{V1}, I claim that I could give
you back a function comparing it for equality. Since you \emph{can't}
actually construct a \texttt{V1}, then my claim can never be tested, and
so we might as well consider it true.

Strictly speaking, \texttt{V1} instances usually aren't necessary, but
we might as well provide one if we can.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{GEq} \DataTypeTok{V1} \KeywordTok{where}
\NormalTok{  geq \_ \_ }\OtherTok{=} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

The one other case we need to consider is what should happen for
concrete types inside of data constructors? Such things are denoted via
\texttt{K1}, and in this case, we want to fall back on an \texttt{Eq}
(\emph{not} \texttt{GEq}!) instance to compare the two. The analogous
non-generic behavior for this is how the \texttt{Eq} instance for
\texttt{Maybe\ a} is \texttt{Eq\ a\ =\textgreater{}\ Eq\ (Maybe\ a)};
most datatypes simply want to lift equality over their constituent
fields.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Eq}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{GEq}\NormalTok{ (}\DataTypeTok{K1}\NormalTok{ \_1 a) }\KeywordTok{where}
\NormalTok{  geq (}\DataTypeTok{K1}\NormalTok{ a) (}\DataTypeTok{K1}\NormalTok{ b) }\OtherTok{=}\NormalTok{ a }\OperatorTok{==}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

But why should we use an \texttt{Eq} constraint rather than
\texttt{GEq}? Well we're using \texttt{GEq} to help derive \texttt{Eq},
which implies \texttt{Eq} is the actual type we care about. If we were
to use a \texttt{GEq} constraint, we'd remove the ability for anyone to
write a non-generic instance of \texttt{Eq}!

With our base cases complete, we're ready to lift them over sums. Two
sums are equal if and only if they are the same data constructor (left
or right), and if their internal data is equal.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{GEq}\NormalTok{ a, }\DataTypeTok{GEq}\NormalTok{ b) }\OtherTok{=\textgreater{}} \DataTypeTok{GEq}\NormalTok{ (a }\OperatorTok{:+:}\NormalTok{ b) }\KeywordTok{where}
\NormalTok{  geq (}\DataTypeTok{L1}\NormalTok{ a1) (}\DataTypeTok{L1}\NormalTok{ a2) }\OtherTok{=}\NormalTok{ geq a1 a2}
\NormalTok{  geq (}\DataTypeTok{R1}\NormalTok{ b1) (}\DataTypeTok{R1}\NormalTok{ b2) }\OtherTok{=}\NormalTok{ geq b1 b2}
\NormalTok{  geq \_ \_             }\OtherTok{=} \DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

We will also want to provide \texttt{GEq} instances for products---two
pieces of data side-by-side. Products are represented with the
\texttt{(:*:)} type and data constructors.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{GEq}\NormalTok{ a, }\DataTypeTok{GEq}\NormalTok{ b) }\OtherTok{=\textgreater{}} \DataTypeTok{GEq}\NormalTok{ (a }\OperatorTok{:*:}\NormalTok{ b) }\KeywordTok{where}
\NormalTok{  geq (a1 }\OperatorTok{:*:}\NormalTok{ b1) (a2 }\OperatorTok{:*:}\NormalTok{ b2) }\OtherTok{=}\NormalTok{ geq a1 a2 }\OperatorTok{\&\&}\NormalTok{ geq b1 b2}
\end{Highlighting}
\end{Shaded}

Finally, we want to lift all of our \texttt{GEq} instances through the
\texttt{Rep}'s metadata constructors, since the names of things aren't
relevant for defining \texttt{Eq}. Fortunately, all of the various types
of metadata (\texttt{D1}, \texttt{C1} and \texttt{S1}) provided by
\texttt{GHC.Generics} are all type synonyms of \texttt{M1}. Because we
don't care about any metadata, we can simply provide a \texttt{M1}
instance and ignore it.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{GEq}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{GEq}\NormalTok{ (}\DataTypeTok{M1}\NormalTok{ \_x \_y a) }\KeywordTok{where}
\NormalTok{  geq (}\DataTypeTok{M1}\NormalTok{ a1) (}\DataTypeTok{M1}\NormalTok{ a2) }\OtherTok{=}\NormalTok{ geq a1 a2}
\end{Highlighting}
\end{Shaded}

This completes step two; we're now capable of getting \texttt{Eq}
instances for free. However, to convince ourselves that what we've done
so far works, we can write a function that performs our generic equality
test.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{genericEq ::}\NormalTok{ (}\DataTypeTok{Generic}\NormalTok{ a, }\DataTypeTok{GEq}\NormalTok{ (}\DataTypeTok{Rep}\NormalTok{ a)) }\OtherTok{=\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{genericEq a b }\OtherTok{=}\NormalTok{ geq (from a) (from b)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ genericEq }\DataTypeTok{True} \DataTypeTok{False}
\DataTypeTok{False}


\OperatorTok{\textgreater{}}\NormalTok{ genericEq }\StringTok{"ghc.generics"} \StringTok{"ghc.generics"}
\DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

\VERB|\NormalTok{genericEq}| is powerful step in the right direction. We
can define actual \texttt{Eq} instances in terms of it. Given our
\texttt{Foo} datatype from earlier:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Foo}\NormalTok{ a b c}
  \OtherTok{=} \DataTypeTok{F0}
  \OperatorTok{|} \DataTypeTok{F1}\NormalTok{ a}
  \OperatorTok{|} \DataTypeTok{F2}\NormalTok{ b c}
  \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Generic}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can give an \texttt{Eq} instance with very little effort.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{Eq}\NormalTok{ a, }\DataTypeTok{Eq}\NormalTok{ b, }\DataTypeTok{Eq}\NormalTok{ c) }\OtherTok{=\textgreater{}} \DataTypeTok{Eq}\NormalTok{ (}\DataTypeTok{Foo}\NormalTok{ a b c) }\KeywordTok{where}
\NormalTok{  (}\OperatorTok{==}\NormalTok{) }\OtherTok{=}\NormalTok{ genericEq}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Provide a generic instance for the `Ord` class.
\end{verbatim}

\begin{verbatim}
[code/DeriveAnyClass.hs:GOrd](Snip)
[code/DeriveAnyClass.hs:gordU1](Snip)
[code/DeriveAnyClass.hs:gordV1](Snip)
[code/DeriveAnyClass.hs:gordK1](Snip)
[code/DeriveAnyClass.hs:gordTimes](Snip)
[code/DeriveAnyClass.hs:gordPlus](Snip)
[code/DeriveAnyClass.hs:gordM1](Snip)
[code/DeriveAnyClass.hs:genericOrd](Snip)
\end{verbatim}

\begin{verbatim}
  Use `GHC.Generics` to implement the function `exNihilo :: Maybe
  a`{.haskell}. This function should give a value of `Just a` if `a` has exactly one
  data constructor which takes zero arguments. Otherwise, `exNihilo`{.haskell} should
  return `Nothing`{.haskell}.
\end{verbatim}

\begin{verbatim}
[code/DeriveAnyClass.hs:GExNihilo](Snip)
[code/DeriveAnyClass.hs:gexNihiloU1](Snip)
[code/DeriveAnyClass.hs:gexNihiloV1](Snip)
[code/DeriveAnyClass.hs:gexNihiloK1](Snip)
[code/DeriveAnyClass.hs:gexNihiloTimes](Snip)
[code/DeriveAnyClass.hs:gexNihiloPlus](Snip)
[code/DeriveAnyClass.hs:gexNihiloM1](Snip)
\end{verbatim}

This is about as good as we can do for classes we haven't defined
ourselves. However, for our own typeclasses we can go further and have
the compiler actually write that last piece of boilerplate for us too.
We'll get full access to the \VERB|\KeywordTok{deriving}| machinery.

To illustrate the point, let's define a new typeclass \texttt{MyEq}. For
all intents and purposes \texttt{MyEq} is exactly the same as
\texttt{Eq}, except that we've defined it ourselves.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{MyEq}\NormalTok{ a }\KeywordTok{where}
\OtherTok{  eq ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{  default eq  }\annotate{1}
\OtherTok{      ::}\NormalTok{ (}\DataTypeTok{Generic}\NormalTok{ a, }\DataTypeTok{GEq}\NormalTok{ (}\DataTypeTok{Rep}\NormalTok{ a))}
      \OtherTok{=\textgreater{}}\NormalTok{ a}
      \OtherTok{{-}\textgreater{}}\NormalTok{ a}
      \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{  eq a b }\OtherTok{=}\NormalTok{ geq (from a) (from b)}
\end{Highlighting}
\end{Shaded}

Using \texttt{-XDefaultSignatures}, at \ann{1} we can provide a default
implementation of \VERB|\NormalTok{eq}| in terms of
\VERB|\NormalTok{genericEq}|. \texttt{-XDefaultSignatures} is necessary
to provides the correct \texttt{GEq\ (Rep\ a)} context.

Finally, by enabling \texttt{-XDeriveAnyClass}, we can convince the
compiler to give us an instance of \texttt{MyEq} for free!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Foo}\NormalTok{ a b c}
  \OtherTok{=} \DataTypeTok{F0}
  \OperatorTok{|} \DataTypeTok{F1}\NormalTok{ a}
  \OperatorTok{|} \DataTypeTok{F2}\NormalTok{ b c}
  \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Generic}\NormalTok{, }\DataTypeTok{MyEq}\NormalTok{)  }\annotate{1}
\end{Highlighting}
\end{Shaded}

Notice how at \ann{1}, we simply ask for a derived instance of
\texttt{MyEq}, and the compiler happily gives it to us. We can fire up
the REPL to see how we did:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t eq}
\OtherTok{eq ::} \DataTypeTok{MyEq}\NormalTok{ a }\OtherTok{=\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}


\OperatorTok{\textgreater{}}\NormalTok{ eq }\DataTypeTok{F0} \DataTypeTok{F0}
\DataTypeTok{True}


\OperatorTok{\textgreater{}}\NormalTok{ eq (}\DataTypeTok{F1} \StringTok{"foo"}\NormalTok{) (}\DataTypeTok{F1} \StringTok{"foo"}\NormalTok{)}
\DataTypeTok{True}


\OperatorTok{\textgreater{}}\NormalTok{ eq }\DataTypeTok{F0}\NormalTok{ (}\DataTypeTok{F1} \StringTok{"hello"}\NormalTok{)}
\DataTypeTok{False}


\OperatorTok{\textgreater{}}\NormalTok{ eq (}\DataTypeTok{F1} \StringTok{"foo"}\NormalTok{) (}\DataTypeTok{F1} \StringTok{"bar"}\NormalTok{)}
\DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

\hypertarget{using-generic-metadata}{%
\section{Using Generic Metadata}\label{using-generic-metadata}}

JavaScript's lack of a proper type system is widely known. However, in
an attempt to add some degree of type-safety, its proponents recommend a
thing called JSON Schema. If you're unfamiliar with it, JSON Schema is,
in its own, words ``a vocabulary that allows you to annotate and
validate JSON documents.'' It's sort of like a type system, but
described in JSON itself.

For example, the following Haskell type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Person} \OtherTok{=} \DataTypeTok{Person}
\NormalTok{  \{}\OtherTok{ name        ::} \DataTypeTok{String}
\NormalTok{  ,}\OtherTok{ age         ::} \DataTypeTok{Int}
\NormalTok{  ,}\OtherTok{ phone       ::} \DataTypeTok{Maybe} \DataTypeTok{String}
\NormalTok{  ,}\OtherTok{ permissions ::}\NormalTok{ [}\DataTypeTok{Bool}\NormalTok{]}
\NormalTok{  \}}
  \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Generic}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\noindent would be described in JSON Schema as:

\begin{verbatim}
  { "title": "Person"
  , "type": "object"
  , "properties":
      { "name":  { "type": "string"  }
      , "age":   { "type": "integer" }
      , "phone": { "type": "string"  }
      , "permissions":
          { "type": "array", "items": { "type": "boolean" }}
      }
  , "required": ["name" , "age", "permissions"]
  }
\end{verbatim}

When sharing data between Haskell and JavaScript, providing JSON Schema
as a common format between the two languages seems like it might help
mitigate JavaScript's weak typing. But writing JSON Schema by hand is no
fun, and so we find ourselves with a motivating example of generating
code generically.

As always, we begin with a definition of the carrier typeclass. Such a
thing needs to produce a \texttt{Value} (\texttt{aeson}'s
({\textbf{???}}) representation of a JSON value.) However, we'll also
need to propagate information in order to fill the
\VERB|\ErrorTok{required}| property. As such, we decide on a single
method of type \texttt{Writer\ {[}Text{]}\ Value}. The
\texttt{{[}Text{]}} will be used to track the required properties, and
the \texttt{Value} is the schema we're building.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{GSchema}\NormalTok{ (}\OtherTok{a ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{) }\KeywordTok{where}
\OtherTok{  gschema ::} \DataTypeTok{Writer}\NormalTok{ [}\DataTypeTok{Text}\NormalTok{] }\DataTypeTok{Value}
\end{Highlighting}
\end{Shaded}

Notice that \VERB|\NormalTok{gschema}| doesn't reference the \texttt{a}
type parameter anywhere. While we \emph{could} use a \texttt{Proxy} to
drive the instance lookups the way we did for \texttt{HasPrintf}, a
cleaner interface is to enable \texttt{-XAllowAmbiguousTypes} and later
use \texttt{-XTypeApplications} to fill in the desired variable.

For our purposes, we will assume we only want to generate JSON Schema
for Haskell records. In fact, it will be an error to ask for a schema
for any sum-types, since it's not clear how to embed them into JSON.

Before diving in, we'll need some helper functions for manipulating JSON
objects. For example, we'll want to merge two of them by taking the
union of their properties.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mergeObjects ::} \DataTypeTok{Value} \OtherTok{{-}\textgreater{}} \DataTypeTok{Value} \OtherTok{{-}\textgreater{}} \DataTypeTok{Value}
\NormalTok{mergeObjects (}\DataTypeTok{Object}\NormalTok{ a) (}\DataTypeTok{Object}\NormalTok{ b) }\OtherTok{=} \DataTypeTok{Object} \OperatorTok{$}\NormalTok{ a }\OperatorTok{\textless{}\textgreater{}}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

We will also write a helper function that takes a
\texttt{KnownSymbol\ nm} and \VERB|\NormalTok{tell}|s the corresponding
term-level string.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{emitRequired}
\OtherTok{    ::} \KeywordTok{forall}\NormalTok{ nm}
     \OperatorTok{.} \DataTypeTok{KnownSymbol}\NormalTok{ nm}
    \OtherTok{=\textgreater{}} \DataTypeTok{Writer}\NormalTok{ [}\DataTypeTok{Text}\NormalTok{] ()}
\NormalTok{emitRequired }\OtherTok{=}\NormalTok{ tell }\OperatorTok{.} \FunctionTok{pure} \OperatorTok{.} \FunctionTok{pack} \OperatorTok{.}\NormalTok{ symbolVal }\OperatorTok{$} \DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{nm}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ runWriter (emitRequired }\OperatorTok{@}\StringTok{"required property"}\NormalTok{)}
\NormalTok{((),[}\StringTok{"required property"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\VERB|\NormalTok{symbolVal}| is a function that converts a
\texttt{Symbol} into a \texttt{String}. It comes from
\texttt{GHC.TypeLits}. For example:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t symbolVal}
\OtherTok{symbolVal ::} \DataTypeTok{KnownSymbol}\NormalTok{ n }\OtherTok{=\textgreater{}}\NormalTok{ proxy n }\OtherTok{{-}\textgreater{}} \DataTypeTok{String}


\OperatorTok{\textgreater{}}\NormalTok{ symbolVal (}\DataTypeTok{Proxy} \OperatorTok{@}\StringTok{"i am a symbol"}\NormalTok{)}
\StringTok{"i am a symbol"}
\end{Highlighting}
\end{Shaded}

The \texttt{KnownSymbol} stuff in \VERB|\NormalTok{symbolVal}|'s type is
simply a proof that GHC knows what \texttt{Symbol} we're talking about;
it will automatically generate the \texttt{KnownSymbol} instance for us,
so it's nothing we need to worry about.

Anyway, in JSON Schema, the boolean type \texttt{Bool} is represented
via \VERB|\ErrorTok{"boolean"}|. Along the same vein, integral types are
\VERB|\ErrorTok{"integer"}|, but all other numeric types are simply
\VERB|\ErrorTok{"number"}|. User types should be serialized with their
given name. This is a good opportunity to use a closed type family to
convert from Haskell type names to their JSON Schema counterparts.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \KeywordTok{family} \DataTypeTok{ToJSONType}\NormalTok{ (}\OtherTok{a ::} \DataTypeTok{Type}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{Symbol} \KeywordTok{where}
  \DataTypeTok{ToJSONType} \DataTypeTok{Int}     \OtherTok{=} \StringTok{"integer"}
  \DataTypeTok{ToJSONType} \DataTypeTok{Integer} \OtherTok{=} \StringTok{"integer"}
  \DataTypeTok{ToJSONType} \DataTypeTok{Float}   \OtherTok{=} \StringTok{"number"}
  \DataTypeTok{ToJSONType} \DataTypeTok{Double}  \OtherTok{=} \StringTok{"number"}
  \DataTypeTok{ToJSONType} \DataTypeTok{String}  \OtherTok{=} \StringTok{"string"}
  \DataTypeTok{ToJSONType} \DataTypeTok{Bool}    \OtherTok{=} \StringTok{"boolean"}
  \DataTypeTok{ToJSONType}\NormalTok{ [a]     }\OtherTok{=} \StringTok{"array"}
  \DataTypeTok{ToJSONType}\NormalTok{ a       }\OtherTok{=} \DataTypeTok{TypeName}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

Unfortunately, there is no straightforward means of getting the name of
a type as a symbol. We can use generic metadata to retrieve a type's
name.

\href{Snip}{code/JSONSchema.hs:RepName}
\href{Snip}{code/JSONSchema.hs:TypeName}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{ToJSONType} \DataTypeTok{Double}
\DataTypeTok{ToJSONType} \DataTypeTok{Double}\OtherTok{ ::} \DataTypeTok{Symbol}
\OtherTok{=} \StringTok{"number"}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{ToJSONType} \DataTypeTok{String}
\DataTypeTok{ToJSONType} \DataTypeTok{String}\OtherTok{ ::} \DataTypeTok{Symbol}
\OtherTok{=} \StringTok{"string"}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{ToJSONType}\NormalTok{ [}\DataTypeTok{Int}\NormalTok{]}
\DataTypeTok{ToJSONType}\NormalTok{ [}\DataTypeTok{Int}\NormalTok{]}\OtherTok{ ::} \DataTypeTok{Symbol}
\OtherTok{=} \StringTok{"array"}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{kind}\OperatorTok{!} \DataTypeTok{ToJSONType} \DataTypeTok{Person}
\DataTypeTok{ToJSONType} \DataTypeTok{Person}\OtherTok{ ::} \DataTypeTok{Symbol}
\OtherTok{=} \StringTok{"Person"}
\end{Highlighting}
\end{Shaded}

Something we'll find ourselves generating often are objects of the form
\VERB|\FunctionTok{\{}\DataTypeTok{"type"}\FunctionTok{:} \StringTok{"foo"}\FunctionTok{\}}|.
The function \VERB|\NormalTok{makeTypeObj}| is type-applicable, and will
use the \texttt{ToJSONType} of the applied type.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{makeTypeObj}
\OtherTok{    ::} \KeywordTok{forall}\NormalTok{ a}
     \OperatorTok{.} \DataTypeTok{KnownSymbol}\NormalTok{ (}\DataTypeTok{ToJSONType}\NormalTok{ a)}
    \OtherTok{=\textgreater{}} \DataTypeTok{Value}
\NormalTok{makeTypeObj }\OtherTok{=}\NormalTok{ object}
\NormalTok{  [ }\StringTok{"type"} \OperatorTok{.=}
      \DataTypeTok{String}\NormalTok{ (}\FunctionTok{pack} \OperatorTok{.}\NormalTok{ symbolVal }\OperatorTok{$} \DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{(}\DataTypeTok{ToJSONType}\NormalTok{ a))}
\NormalTok{  ]}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ makeTypeObj }\OperatorTok{@}\DataTypeTok{Int}
\DataTypeTok{Object}\NormalTok{ (fromList [(}\StringTok{"type"}\NormalTok{,}\DataTypeTok{String} \StringTok{"integer"}\NormalTok{)])}
\end{Highlighting}
\end{Shaded}

One last helper function we'll need before getting to the meat of the
\texttt{GHC.Generics} code is to be able to wrap an object with the name
of a property. This will be used to build the
\VERB|\ErrorTok{"properties"}| property in the JSON Schema document.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{makePropertyObj}
\OtherTok{    ::} \KeywordTok{forall}\NormalTok{ name}
     \OperatorTok{.}\NormalTok{ (}\DataTypeTok{KnownSymbol}\NormalTok{ name)}
    \OtherTok{=\textgreater{}} \DataTypeTok{Value} \OtherTok{{-}\textgreater{}} \DataTypeTok{Value}
\NormalTok{makePropertyObj v }\OtherTok{=}\NormalTok{ object}
\NormalTok{  [ }\FunctionTok{pack}\NormalTok{ (symbolVal }\OperatorTok{$} \DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{name) }\OperatorTok{.=}\NormalTok{ v}
\NormalTok{  ]}
\end{Highlighting}
\end{Shaded}

Like \VERB|\NormalTok{makeTypeObj}|, \VERB|\NormalTok{makePropertyObj}|
also is intended to be called with a type application. In this case, it
takes a \texttt{Symbol} corresponding to the name of the property to
emit. These \texttt{Symbol}s will come directly from the \texttt{Rep} of
the data-structure's record selectors.

In order to get access to the record name, it's insufficient to simply
define an instance of \texttt{GSchema} for \texttt{K1}. By the time we
get to \texttt{K1} we've lost access to the metadata---the metadata is
stored in an outer wrapper. Instead, we can do type-level pattern
matching on \texttt{M1\ S\ meta\ (K1\ \textbackslash{}\_\ a)}. The
\texttt{S} type is used as a parameter to \texttt{M1} to describe
\emph{record selector metadata}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{KnownSymbol}\NormalTok{ nm, }\DataTypeTok{KnownSymbol}\NormalTok{ (}\DataTypeTok{ToJSONType}\NormalTok{ a))}
    \OtherTok{=\textgreater{}} \DataTypeTok{GSchema}\NormalTok{ (}\DataTypeTok{M1} \DataTypeTok{S}\NormalTok{ (}\DataTypeTok{\textquotesingle{}MetaSel}\NormalTok{ (}\DataTypeTok{\textquotesingle{}Just}\NormalTok{ nm) \_1 \_2 \_3)}
\NormalTok{                     (}\DataTypeTok{K1}\NormalTok{ \_4 a)) }\KeywordTok{where}
\NormalTok{  gschema }\OtherTok{=} \KeywordTok{do}
\NormalTok{    emitRequired }\OperatorTok{@}\NormalTok{nm  }\annotate{1}
    \FunctionTok{pure} \OperatorTok{.}\NormalTok{ makePropertyObj }\OperatorTok{@}\NormalTok{nm  }\annotate{2}
         \OperatorTok{$}\NormalTok{ makeTypeObj }\OperatorTok{@}\NormalTok{a}
  \OtherTok{\{{-}\# INLINE gschema \#{-}\}}
\end{Highlighting}
\end{Shaded}

At \ann{1}, this instance says that the property \texttt{nm} is
required. It then builds and returns a property object.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \KeywordTok{import} \KeywordTok{qualified} \DataTypeTok{Data.ByteString.Lazy.Char8} \KeywordTok{as} \DataTypeTok{LC8}
\NormalTok{\{}
    \StringTok{"myproperty"}\OperatorTok{:}\NormalTok{ \{}
        \StringTok{"type"}\OperatorTok{:} \StringTok{"boolean"}
\NormalTok{    \}}
\NormalTok{\}}


\OperatorTok{\textgreater{}} \KeywordTok{import} \DataTypeTok{Data.Aeson.Encode.Pretty}\NormalTok{ (encodePretty)}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

There are other base cases of \texttt{M1\ ..\ K1} we still need to
handle, but we will build the rest of the machinery first. If we have a
product of fields, we need to merge them together.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{GSchema}\NormalTok{ f, }\DataTypeTok{GSchema}\NormalTok{ g)}
      \OtherTok{=\textgreater{}} \DataTypeTok{GSchema}\NormalTok{ (f }\OperatorTok{:*:}\NormalTok{ g) }\KeywordTok{where}
\NormalTok{  gschema }\OtherTok{=}
\NormalTok{    mergeObjects }\OperatorTok{\textless{}$\textgreater{}}\NormalTok{ gschema }\OperatorTok{@}\NormalTok{f}
                 \OperatorTok{\textless{}*\textgreater{}}\NormalTok{ gschema }\OperatorTok{@}\NormalTok{g}
  \OtherTok{\{{-}\# INLINE gschema \#{-}\}}
\end{Highlighting}
\end{Shaded}

For coproduct types, we will simply error out as the JSON Schema
documentation is conspicuously quiet about the encoding of sums.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}
\NormalTok{  (}\DataTypeTok{TypeError}\NormalTok{ (}\DataTypeTok{\textquotesingle{}Err.Text}
      \StringTok{"JSON Schema does not support sum types"}\NormalTok{))}
    \OtherTok{=\textgreater{}} \DataTypeTok{GSchema}\NormalTok{ (f }\OperatorTok{:+:}\NormalTok{ g) }\KeywordTok{where}
\NormalTok{  gschema }\OtherTok{=}
    \FunctionTok{error}
      \StringTok{"JSON Schema does not support sum types"}
  \OtherTok{\{{-}\# INLINE gschema \#{-}\}}
\end{Highlighting}
\end{Shaded}

Because sum-types are not allowed, information about data constructors
isn't interesting to us. We simply lift a \texttt{GSchema} instance
through \texttt{M1\ C} (metadata for data constructors.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{GSchema}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{GSchema}\NormalTok{ (}\DataTypeTok{M1} \DataTypeTok{C}\NormalTok{ \_1 a) }\KeywordTok{where}
\NormalTok{  gschema }\OtherTok{=}\NormalTok{ gschema }\OperatorTok{@}\NormalTok{a}
  \OtherTok{\{{-}\# INLINE gschema \#{-}\}}
\end{Highlighting}
\end{Shaded}

To close out our induction cases, we need an instance of
\texttt{GSchema} for \texttt{M1\ D}---type constructors. Here we have
access to the type's name, and all of its properties.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{GSchema}\NormalTok{ a, }\DataTypeTok{KnownSymbol}\NormalTok{ nm)}
    \OtherTok{=\textgreater{}} \DataTypeTok{GSchema}\NormalTok{ (}\DataTypeTok{M1} \DataTypeTok{D}\NormalTok{ (}\DataTypeTok{\textquotesingle{}MetaData}\NormalTok{ nm \_1 \_2 \_3) a) }\KeywordTok{where}
\NormalTok{  gschema }\OtherTok{=} \KeywordTok{do}
\NormalTok{    sch }\OtherTok{\textless{}{-}}\NormalTok{ gschema }\OperatorTok{@}\NormalTok{a}
    \FunctionTok{pure} \OperatorTok{$}\NormalTok{ object}
\NormalTok{      [ }\StringTok{"title"} \OperatorTok{.=}\NormalTok{ (}\DataTypeTok{String} \OperatorTok{.} \FunctionTok{pack} \OperatorTok{.}\NormalTok{ symbolVal }\OperatorTok{$} \DataTypeTok{Proxy} \OperatorTok{@}\NormalTok{nm)}
\NormalTok{      , }\StringTok{"type"}  \OperatorTok{.=} \DataTypeTok{String} \StringTok{"object"}
\NormalTok{      , }\StringTok{"properties"} \OperatorTok{.=}\NormalTok{ sch}
\NormalTok{      ]}
  \OtherTok{\{{-}\# INLINE gschema \#{-}\}}
\end{Highlighting}
\end{Shaded}

Finally, we need to run our \texttt{Writer\ {[}Text{]}} and transform
that into the list of required properties \VERB|\ErrorTok{"required"}|.
We'll use the opportunity to also act as our interface between
\texttt{a} and \texttt{Rep\ a}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{schema}
\OtherTok{    ::} \KeywordTok{forall}\NormalTok{ a}
     \OperatorTok{.}\NormalTok{ (}\DataTypeTok{GSchema}\NormalTok{ (}\DataTypeTok{Rep}\NormalTok{ a), }\DataTypeTok{Generic}\NormalTok{ a)}
    \OtherTok{=\textgreater{}} \DataTypeTok{Value}
\NormalTok{schema }\OtherTok{=}
  \KeywordTok{let}\NormalTok{ (v, reqs) }\OtherTok{=}\NormalTok{ runWriter }\OperatorTok{$}\NormalTok{ gschema }\OperatorTok{@}\NormalTok{(}\DataTypeTok{Rep}\NormalTok{ a)}
   \KeywordTok{in}\NormalTok{ mergeObjects v }\OperatorTok{$}\NormalTok{ object}
\NormalTok{        [ }\StringTok{"required"} \OperatorTok{.=}
            \DataTypeTok{Array}\NormalTok{ (fromList }\OperatorTok{$} \DataTypeTok{String} \OperatorTok{\textless{}$\textgreater{}}\NormalTok{ reqs)}
\NormalTok{        ]}
\OtherTok{\{{-}\# INLINE schema \#{-}\}}
\end{Highlighting}
\end{Shaded}

\VERB|\NormalTok{schema}| already works quite well. It will dump out a
JSON Schema for our \texttt{Person} type, though the encoding won't work
correctly with optional values, lists or strings. Each of these
corresponds to a different base case of \texttt{M1\ ..\ K1}, and so we
can provide some overlapping instances to clear them up.

The easiest case is that of \texttt{Maybe\ a}, which we'd like to
describe as a field of \texttt{a}, though without calling
\VERB|\NormalTok{emitRequired}|.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \OtherTok{\{{-}\# OVERLAPPING \#{-}\}}
\NormalTok{  ( }\DataTypeTok{KnownSymbol}\NormalTok{ nm}
\NormalTok{  , }\DataTypeTok{KnownSymbol}\NormalTok{ (}\DataTypeTok{ToJSONType}\NormalTok{ a)}
\NormalTok{  )}
    \OtherTok{=\textgreater{}} \DataTypeTok{GSchema}\NormalTok{ (}\DataTypeTok{M1} \DataTypeTok{S}\NormalTok{ (}\DataTypeTok{\textquotesingle{}MetaSel}\NormalTok{ (}\DataTypeTok{\textquotesingle{}Just}\NormalTok{ nm) \_1 \_2 \_3)}
\NormalTok{                     (}\DataTypeTok{K1}\NormalTok{ \_4 (}\DataTypeTok{Maybe}\NormalTok{ a))) }\KeywordTok{where}
\NormalTok{  gschema }\OtherTok{=} \FunctionTok{pure}
          \OperatorTok{.}\NormalTok{ makePropertyObj }\OperatorTok{@}\NormalTok{nm}
          \OperatorTok{$}\NormalTok{ makeTypeObj }\OperatorTok{@}\NormalTok{a}
  \OtherTok{\{{-}\# INLINE gschema \#{-}\}}
\end{Highlighting}
\end{Shaded}

This instance is identical to \texttt{K1\ \textbackslash{}\_\ a} except
for the omission of \VERB|\NormalTok{emitRequired}|.

Lists are serialized oddly in JSON Schema; their type is
\VERB|\ErrorTok{"array"}|, but the descriptor object comes with an extra
property \VERB|\ErrorTok{"items"}| which \emph{also} contains a
\VERB|\ErrorTok{"type"}| property:

\begin{verbatim}
{ "type": "array", "items": { "type": "boolean" }}
\end{verbatim}

We can implement this with an overlapping instance which targets
\texttt{K1\ \textbackslash{}\_\ {[}a{]}}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \OtherTok{\{{-}\# OVERLAPPING \#{-}\}}
\NormalTok{  ( }\DataTypeTok{KnownSymbol}\NormalTok{ nm}
\NormalTok{  , }\DataTypeTok{KnownSymbol}\NormalTok{ (}\DataTypeTok{ToJSONType}\NormalTok{ [a])}
\NormalTok{  , }\DataTypeTok{KnownSymbol}\NormalTok{ (}\DataTypeTok{ToJSONType}\NormalTok{ a)}
\NormalTok{  )}
    \OtherTok{=\textgreater{}} \DataTypeTok{GSchema}\NormalTok{ (}\DataTypeTok{M1} \DataTypeTok{S}\NormalTok{ (}\DataTypeTok{\textquotesingle{}MetaSel}\NormalTok{ (}\DataTypeTok{\textquotesingle{}Just}\NormalTok{ nm) \_1 \_2 \_3)}
\NormalTok{                     (}\DataTypeTok{K1}\NormalTok{ \_4 [a])) }\KeywordTok{where}
\NormalTok{  gschema }\OtherTok{=} \KeywordTok{do}
\NormalTok{    emitRequired }\OperatorTok{@}\NormalTok{nm}
    \KeywordTok{let}\NormalTok{ innerType }\OtherTok{=}\NormalTok{ object}
\NormalTok{          [ }\StringTok{"items"} \OperatorTok{.=}\NormalTok{ makeTypeObj }\OperatorTok{@}\NormalTok{a}
\NormalTok{          ]}
    \FunctionTok{pure} \OperatorTok{.}\NormalTok{ makePropertyObj }\OperatorTok{@}\NormalTok{nm}
         \OperatorTok{.}\NormalTok{ mergeObjects innerType}
         \OperatorTok{$}\NormalTok{ makeTypeObj }\OperatorTok{@}\NormalTok{[a]}
  \OtherTok{\{{-}\# INLINE gschema \#{-}\}}
\end{Highlighting}
\end{Shaded}

This works well, but because in Haskell, \texttt{String}s are simply
lists of \texttt{Char}s, our emitted JSON Schema treats \texttt{String}s
as arrays. The correct behavior for \texttt{String} is the same as the
default \texttt{K1\ \textbackslash{}\_\ a} case, so we add yet another
overlapping instance.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \OtherTok{\{{-}\# OVERLAPPING \#{-}\}} \DataTypeTok{KnownSymbol}\NormalTok{ nm}
    \OtherTok{=\textgreater{}} \DataTypeTok{GSchema}\NormalTok{ (}\DataTypeTok{M1} \DataTypeTok{S}\NormalTok{ (}\DataTypeTok{\textquotesingle{}MetaSel}\NormalTok{ (}\DataTypeTok{\textquotesingle{}Just}\NormalTok{ nm) \_1 \_2 \_3)}
\NormalTok{                     (}\DataTypeTok{K1}\NormalTok{ \_4 }\DataTypeTok{String}\NormalTok{)) }\KeywordTok{where}
\NormalTok{  gschema }\OtherTok{=} \KeywordTok{do}
\NormalTok{    emitRequired }\OperatorTok{@}\NormalTok{nm}
    \FunctionTok{pure} \OperatorTok{.}\NormalTok{ makePropertyObj }\OperatorTok{@}\NormalTok{nm}
         \OperatorTok{$}\NormalTok{ makeTypeObj }\OperatorTok{@}\DataTypeTok{String}
  \OtherTok{\{{-}\# INLINE gschema \#{-}\}}
\end{Highlighting}
\end{Shaded}

This instance overrides the behavior for \texttt{{[}a{]}}, which in
itself overrides the behavior for \texttt{a}. Programming with typeclass
instances is not always the most elegant experience.

And we're done. We've successfully used the metadata in
\texttt{GHC.Generics} to automatically marshall a description of our
Haskell datatypes into JSON Schema. We didn't need to resort to using
code generation---which would have complicated our compilation
pipeline---and we've written nothing but everday Haskell in order to
accomplish it.

We can admire our handiwork:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{@}\KeywordTok{import} \KeywordTok{qualified} \DataTypeTok{Data.ByteString.Lazy.Char8} \KeywordTok{as} \DataTypeTok{LC8}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

And, as expected, sum types fail to receive a schema with a helpful
error message.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ schema }\OperatorTok{@}\DataTypeTok{Bool}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

\hypertarget{performance}{%
\section{Performance}\label{performance}}

With all of the fantastic things we're capable of doing with
\texttt{GHC.Generics}, it's worth wondering whether or not we need to
pay a runtime cost to perform these marvels. After all, converting to
and from \texttt{Rep}s probably isn't free.

If there is indeed a hefty cost for using \texttt{GHC.Generics}, the
convenience to the programmer might not be worthwhile. After all, code
gets executed much more often than it gets written. Writing boilerplate
by hand is annoying and tedious, but at least it gives us some
understanding of what's going on under the hood. With
\texttt{GHC.Generics}, these things are certainly less clear.

There is good and bad news here. The good news is that usually adding
\VERB|\DataTypeTok{INLINE}| pragmas to each of your class' methods is
enough to optimize away all usage of \texttt{GHC.Generics} at
compile-time.

The bad news is that this is only \emph{usually} enough to optimize them
away. Since there is no separate compilation step when working with
\texttt{GHC.Generics}, it's quite a lot of work to actually determine
whether or not your generic code is being optimized away.

Thankfully, we have tools for convincing ourselves our performance isn't
being compromised. Enter the \texttt{inspection-testing}({\textbf{???}})
library. \texttt{inspection-testing} provides a plugin to GHC which
allows us to make assertions about our generated code. We can use it to
ensure GHC optimizes away all of our usages of \texttt{GHC.Generics},
and generates the exact same code that we would have written by hand.

We can use \texttt{inspection-testing} like so:

\begin{itemize}
\tightlist
\item
  Enable the
  \VERB|\CommentTok{\{{-}\textbackslash{}\# OPTIONS\textbackslash{}\_GHC {-}O {-}fplugin Test.Inspection.Plugin     \textbackslash{}\#{-}\}}|
  pragma.

  \begin{itemize}
  \tightlist
  \item
    Enable \texttt{-XTemplateHaskell}.
  \item
    Import \texttt{Test.Inspection}.
  \item
    Write some code that exercises the generic code path. Call it
    \VERB|\NormalTok{foo}|, for example.
  \item
    Add
    \VERB|\NormalTok{inspect \textbackslash{}}\OperatorTok{$}\NormalTok{ hasNoGenerics }\CharTok{\textquotesingle{}foo}|
    to your top level module.
  \end{itemize}
\end{itemize}

For example, if we wanted to show that the \VERB|\NormalTok{schema}|
function successfully optimized away all of its generics, we could add a
little test to our project like this:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{\{{-}\# LANGUAGE TemplateHaskell  \#{-}\}}
\OtherTok{\{{-}\# LANGUAGE TypeApplications \#{-}\}}
\OtherTok{\{{-}\# OPTIONS\_GHC {-}O {-}fplugin Test.Inspection.Plugin \#{-}\}}

\KeywordTok{module} \DataTypeTok{InspectionTesting} \KeywordTok{where}

\KeywordTok{import} \DataTypeTok{Data.Aeson}
\KeywordTok{import} \DataTypeTok{JSONSchema}
\KeywordTok{import} \DataTypeTok{Test.Inspection}

\OtherTok{mySchema ::} \DataTypeTok{Value}
\NormalTok{mySchema }\OtherTok{=}\NormalTok{ schema }\OperatorTok{@}\DataTypeTok{Person}

\NormalTok{inspect }\OperatorTok{$}\NormalTok{ hasNoGenerics }\CharTok{\textquotesingle{}mySchema}
\end{Highlighting}
\end{Shaded}

Easy as that. Now in the course of compiling your module, if your
generic code has any runtime overhead, GHC will refuse to continue.
Unfortunately for us, \texttt{inspection-testing} isn't magic and can't
guarantee our implementation is as good as a hand-written example, but
at least it can prove the generic representations don't exist at
runtime.

In order to prove two implementations (eg. one written generically and
one written by hand) \emph{are} equal, you can use
\texttt{inspection-testing}'s
\VERB|\NormalTok{(}\OperatorTok{===}\NormalTok{)}| combinator.
\VERB|\NormalTok{(}\OperatorTok{===}\NormalTok{)}| causes a compile-time
error if the actual generate Core isn't identical. This is often
impractical to do for complicate usages of \texttt{GHC.Generics}, but
it's comforting to know that it's possible in principle.

There is a particularly egregious case that GHC is unable to optimize,
however. It's described colloquially as ``functions that are too
polymorphic.'' But what does it mean to be \emph{too polymorphic}?

This class of problems sets in when GHC requires knowing about the
functor/applicative/monad laws in order to perform the inlining, but the
type itself is polymorphic. That is to say, a generic function that
produces a \texttt{forall\ m.\ m\ a} will perform poorly, but
\texttt{Maybe\ a} is fine. A good rule of thumb is that if you have a
polymorphic higher-kinded type, your performance is going to go into the
toolies.

\hypertarget{kan-extensions}{%
\section{Kan Extensions}\label{kan-extensions}}

On the grasping hand, there is still good news to be found. Reclaiming
our performance from the clutches of too-polymorphic generic code isn't
a challenging exercise. The secret is to rewrite our types in terms of
kan extensions.

\begin{itemize}
\tightlist
\item
  Rather than \texttt{forall\ f.\ Functor\ f\ =\textgreater{}\ f\ a},
  instead use \texttt{forall\ f.\ \ \ \ \ Yoneda\ f\ a}

  \begin{itemize}
  \tightlist
  \item
    Instead of
    \texttt{forall\ f.\ Applicative\ f\ =\textgreater{}\ f\ a}, use
    \texttt{forall\ f.\ \ \ Curried\ (Yoneda\ f)\ (Yoneda\ f)\ a}
  \item
    Instead of \texttt{forall\ f.\ Monad\ f\ =\textgreater{}\ f\ a}, use
    \texttt{forall\ f.\ Codensity\ f\ a}
  \end{itemize}
\end{itemize}

These types \texttt{Yoneda}, \texttt{Curried} and \texttt{Codensity} all
come from the \texttt{kan-extensions}({\textbf{???}}) package. We'll
talk more about these transformations in a moment.

In essence, the trick here is to write our ``too polymorphic'' code in a
form more amenable to GHC's inlining abilities, and then transform it
back into the desired form at the very end. \texttt{Yoneda},
\texttt{Curried} and \texttt{Codensity} are tools that can help with
this transformation.

Consider the definition of \texttt{Yoneda}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{Yoneda}\NormalTok{ f a }\OtherTok{=} \DataTypeTok{Yoneda}
\NormalTok{  \{}\OtherTok{ runYoneda ::} \KeywordTok{forall}\NormalTok{ b}\OperatorTok{.}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}
\NormalTok{  \}}
\end{Highlighting}
\end{Shaded}

When we ask GHCi about the type of \VERB|\NormalTok{runYoneda}|, an
interesting similarity to \VERB|\FunctionTok{fmap}| emerges:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t runYoneda}
\OtherTok{runYoneda ::} \DataTypeTok{Yoneda}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\FunctionTok{flip} \FunctionTok{fmap}
\FunctionTok{flip}\OtherTok{ fmap ::} \DataTypeTok{Functor}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}
\end{Highlighting}
\end{Shaded}

\texttt{Codensity}---our transformation for polymorphic \texttt{Monad}ic
code---also bears a similar resemblance.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t runCodensity}
\OtherTok{runCodensity ::} \DataTypeTok{Codensity}\NormalTok{ m a }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ m b) }\OtherTok{{-}\textgreater{}}\NormalTok{ m b}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t (}\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{)}
\OtherTok{(\textgreater{}\textgreater{}=) ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ m a }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ m b) }\OtherTok{{-}\textgreater{}}\NormalTok{ m b}
\end{Highlighting}
\end{Shaded}

And \texttt{Curried} which we used to transform polymorphic
\texttt{Applicative} code also shows this pattern, although it's a
little trickier to see.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t runCurried }\OperatorTok{@}\NormalTok{(}\DataTypeTok{Yoneda}\NormalTok{ \_) }\OperatorTok{@}\NormalTok{(}\DataTypeTok{Yoneda}\NormalTok{ \_)}
\NormalTok{runCurried }\OperatorTok{@}\NormalTok{(}\DataTypeTok{Yoneda}\NormalTok{ \_) }\OperatorTok{@}\NormalTok{(}\DataTypeTok{Yoneda}\NormalTok{ \_)}
\OtherTok{  ::} \DataTypeTok{Curried}\NormalTok{ (}\DataTypeTok{Yoneda}\NormalTok{ \_1) (}\DataTypeTok{Yoneda}\NormalTok{ \_2) a}
     \OtherTok{{-}\textgreater{}} \DataTypeTok{Yoneda}\NormalTok{ \_1 (a }\OtherTok{{-}\textgreater{}}\NormalTok{ r) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Yoneda}\NormalTok{ \_2 r}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\FunctionTok{flip}\NormalTok{ (}\OperatorTok{\textless{}*\textgreater{}}\NormalTok{)}
\FunctionTok{flip}\OtherTok{ (\textless{}*\textgreater{}) ::} \DataTypeTok{Applicative}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}
\end{Highlighting}
\end{Shaded}

This is not an accident. The \texttt{Functor} instance for
\texttt{Yoneda} is particularly enlightening:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Functor}\NormalTok{ (}\DataTypeTok{Yoneda}\NormalTok{ f) }\KeywordTok{where}
  \FunctionTok{fmap}\NormalTok{ f (}\DataTypeTok{Yoneda}\NormalTok{ y) }\OtherTok{=} \DataTypeTok{Yoneda}\NormalTok{ (\textbackslash{}k }\OtherTok{{-}\textgreater{}}\NormalTok{ y (k }\OperatorTok{.}\NormalTok{ f))}
\end{Highlighting}
\end{Shaded}

Note the lack of a \texttt{Functor\ f} constraint on this instance!
\texttt{Yoneda\ f} is a \texttt{Functor} \emph{even when} \texttt{f}
\emph{isn't.} In essence, \texttt{Yoneda\ f} gives us a instance of
\texttt{Functor} for free. Any type of kind
\texttt{Type\ -\textgreater{}\ Type} is eligible. There's lots of
interesting category theory behind all of this, but it's not important
to us.

But how does \texttt{Yoneda} work? Keep in mind the functor law that
\VERB|\FunctionTok{fmap}\NormalTok{ f }\OperatorTok{.} \FunctionTok{fmap}\NormalTok{ g }\OtherTok{=} \FunctionTok{fmap}\NormalTok{ (f }\OperatorTok{.}\NormalTok{ g)}|.
The implementation of \texttt{Yoneda}'s \texttt{Functor} instance abuses
this fact. All it's doing is accumulating all of the functions we'd like
to \VERB|\FunctionTok{fmap}| so that it can perform them all at once.

As interesting as all of this is, the question remains: how does
\texttt{Yoneda} help GHC optimize our programs? GHC's failure to inline
``too polymorphic'' functions is due to it being unable to perform the
functor/etc. laws while inlining polymorphic code. But
\texttt{Yoneda\ f} is a functor even when \texttt{f} isn't---exactly by
implementing the \texttt{Functor} laws by hand. \texttt{Yoneda}'s
\texttt{Functor} instance can't possibly depend on \texttt{f}. That
means \texttt{Yoneda\ f} is never ``too polymorphic,'' and as a result,
acts as a fantastic carrier for our optimization tricks.

Finally, the functions
\VERB|\OtherTok{liftYoneda ::} \DataTypeTok{Functor}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Yoneda}\NormalTok{ f a}|
and
\VERB|\OtherTok{lowerYoneda ::} \DataTypeTok{Yoneda}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f a}|
witness an isomorphism between \texttt{Yoneda\ f\ a} and \texttt{f\ a}.
Whenever your generic code needs to do something in \texttt{f}, it
should use \VERB|\NormalTok{liftYoneda}|, and the final interface to
your generic code should make a call to \VERB|\NormalTok{lowerYoneda}|
to hide it as an implementation detail.

This argument holds exactly when replacing \texttt{Functor} with
\texttt{Applicative} or \texttt{Monad}, and \texttt{Yoneda} with
\texttt{Curried} or \texttt{Codensity} respectively.

\hypertarget{indexed-monads}{%
\chapter{Indexed Monads}\label{indexed-monads}}

\hypertarget{definition-and-necessary-machinery}{%
\section{Definition and Necessary
Machinery}\label{definition-and-necessary-machinery}}

Indexed monads are a generalization of monads that allow us to enforce
pre- and post-conditions on monadic actions. They're a great tool for
describing \emph{protocols} and \emph{contracts} at the type-level.
Despite these great uses, indexed monads have historically been hampered
by issues of ergonomics, making this technique less popular than it
might otherwise be.

In this chapter, we will look at how we can statically enforce resource
allocation linearity. We will build a monad which tracks files that are
open and requires them to be closed exactly once. Failure to adhere to
these principles will result in the program not compiling.

To begin with, we can look at the definition of \texttt{IxMonad}, the
typeclass which gives us access to such things. We'll be using the
definition from the \texttt{indexed} ({\textbf{???}}) package.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{IxApplicative}\NormalTok{ m }\OtherTok{=\textgreater{}} \DataTypeTok{IxMonad}\NormalTok{ m }\KeywordTok{where}
\OtherTok{  ibind ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ m j k b) }\OtherTok{{-}\textgreater{}}\NormalTok{ m i j a }\OtherTok{{-}\textgreater{}}\NormalTok{ m i k b}
\end{Highlighting}
\end{Shaded}

\VERB|\NormalTok{ibind}| here is the ``enriched'' version of
\VERB|\NormalTok{(}\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{)}|,
although note that it's had its first two arguments swapped. In addition
to the usual \texttt{m}, \texttt{a} and \texttt{b} type variables we're
familiar with when working with monads, \VERB|\NormalTok{ibind}| has an
additional three. These other type variables correspond to the ``state''
of the monad at different times.

An indexed monadic action \VERB|\NormalTok{m i j a}| is one that
produces an \texttt{a}, with precondition \texttt{i} and post-condition
\texttt{j}. \VERB|\NormalTok{ibind}| works by matching up the
post-condition of an action \texttt{m\ i\ j} with the precondition of
another \texttt{m\ j\ k}. In doing so, the intermediary condition
\texttt{j} is eliminated, giving us the precondition from the first
action and the post-condition from the second (\texttt{m\ i\ k}).

The \texttt{indexed} package provides the \texttt{IxMonad} typeclass,
but doesn't actually give us any instances for it. Most of the time we
simply want to lift an underlying monad to have this enriched indexed
structure---so we can define a type to help with that.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{Ix}\NormalTok{ m i j a }\OtherTok{=} \DataTypeTok{Ix}
\NormalTok{  \{}\OtherTok{ unsafeRunIx ::}\NormalTok{ m a}
\NormalTok{  \}}
  \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Functor}\NormalTok{, }\DataTypeTok{Applicative}\NormalTok{, }\DataTypeTok{Monad}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Make sure \texttt{Ix} is defined as a \VERB|\KeywordTok{newtype}| rather
than a \VERB|\KeywordTok{data}|.

The aggressive proliferation of type parameters in \texttt{Ix} might be
self-evident to some, but deserves to be explained.

\begin{itemize}
\tightlist
\item
  \texttt{m}---the underlying monad we want to lift into an indexed
  monad.

  \begin{itemize}
  \tightlist
  \item
    \texttt{i}---preconditions on the monadic action.
  \item
    \texttt{j}---post-conditions on the monadic action.
  \item
    \texttt{a}---the type we're producing at the end of the day.
  \end{itemize}
\end{itemize}

Indexed monads have their own indexed-version of the standard typeclass
hierarchy, so we will need to provide instances of all of them for
\texttt{Ix}. The first two can be implemented in terms of their
\texttt{Prelude} definitions, since their types don't conflict.

\href{Snip}{code/IxMonad.hs:IxFunctor}
\href{Snip}{code/IxMonad.hs:IxPointed}

Applicatives, however, require some special treatment. We notice that
since all of our type variables except for \texttt{m} and \texttt{a} are
phantom, we should be able to \VERB|\NormalTok{coerce}| the usual
\texttt{Applicative} function into the right shape. The construction,
however, is a little more involved due to needing to capture all of the
variables.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Applicative}\NormalTok{ m }\OtherTok{=\textgreater{}} \DataTypeTok{IxApplicative}\NormalTok{ (}\DataTypeTok{Ix}\NormalTok{ m) }\KeywordTok{where}
\NormalTok{  iap}
\OtherTok{      ::} \KeywordTok{forall}\NormalTok{ i j k a b  }\annotate{1}
       \OperatorTok{.} \DataTypeTok{Ix}\NormalTok{ m i j (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b)}
      \OtherTok{{-}\textgreater{}} \DataTypeTok{Ix}\NormalTok{ m j k a}
      \OtherTok{{-}\textgreater{}} \DataTypeTok{Ix}\NormalTok{ m i k b}
\NormalTok{  iap }\OtherTok{=}\NormalTok{ coerce }\OperatorTok{$}\NormalTok{ (}\OperatorTok{\textless{}*\textgreater{}}\NormalTok{) }\OperatorTok{@}\NormalTok{m }\OperatorTok{@}\NormalTok{a }\OperatorTok{@}\NormalTok{b  }\annotate{2}
\end{Highlighting}
\end{Shaded}

The type signature at \ann{1} requires enabling the
\texttt{-XInstanceSigs} extension, in order to use
\texttt{-XScopedTypeVariables} to capture the \texttt{a} and \texttt{b}
variables. Once we have them,
\VERB|\NormalTok{(}\OperatorTok{\textless{}*\textgreater{}}\NormalTok{)}|
is trivially coerced at \ann{2}.

Our instance of \texttt{IxMonad} uses the same technique:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}} \DataTypeTok{IxMonad}\NormalTok{ (}\DataTypeTok{Ix}\NormalTok{ m) }\KeywordTok{where}
\NormalTok{  ibind}
\OtherTok{      ::} \KeywordTok{forall}\NormalTok{ i j k a b}
       \OperatorTok{.}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Ix}\NormalTok{ m j k b)}
      \OtherTok{{-}\textgreater{}} \DataTypeTok{Ix}\NormalTok{ m i j a}
      \OtherTok{{-}\textgreater{}} \DataTypeTok{Ix}\NormalTok{ m i k b}
\NormalTok{  ibind }\OtherTok{=}\NormalTok{ coerce }\OperatorTok{$}\NormalTok{ (}\OperatorTok{=\textless{}\textless{}}\NormalTok{) }\OperatorTok{@}\NormalTok{m }\OperatorTok{@}\NormalTok{a }\OperatorTok{@}\NormalTok{b}
\end{Highlighting}
\end{Shaded}

Finally, with all of this machinery out of the way, we have a working
\texttt{IxMonad} to play with. But working directly in terms of
\VERB|\NormalTok{ibind}| seems tedious. After all,
\VERB|\KeywordTok{do}|-notation was invented for a reason.

Historically, here we were faced with a hard decision between two bad
alternatives---write all of our indexed monad code in terms of
\VERB|\NormalTok{ibind}| directly, or replace
\VERB|\KeywordTok{do}|-notation with something amenable to
\texttt{IxMonad} via the \texttt{-XRebindableSyntax}. However, the
latter option infects an entire module, which meant we were unable to
use regular monadic \VERB|\KeywordTok{do}| blocks anywhere in the same
file.

If you're unfamiliar with the \texttt{-XRebindableSyntax} extension, it
causes fundamental Haskell syntax to be desugared in terms of
identifiers currently in scope. For example,
\VERB|\KeywordTok{do}|-notation is usually desugared in terms of
\VERB|\NormalTok{(}\OperatorTok{Prelude.\textgreater{}\textgreater{}=}\NormalTok{)}|---even
if that function isn't in scope (via \texttt{-XNoImplicitPrelude}.) In
contrast, \texttt{-XRebindableSyntax} will instead desugar
\VERB|\KeywordTok{do}|-notation into whatever
\VERB|\NormalTok{(}\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{)}|
function we have in scope. This extension is rarely used in the wild,
and its finer uses are outside the scope of this book.

The indexed monad situation today is thankfully much better. We now have
the \texttt{do-notation}({\textbf{???}}) package, which generalizes
\VERB|\KeywordTok{do}|-notation to work with monads and indexed monads
simultaneously. This behavior is enabled by adding the following lines
to the top of our module.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{\{{-}\# LANGUAGE RebindableSyntax \#{-}\}}
\KeywordTok{import} \DataTypeTok{Language.Haskell.DoNotation}
\KeywordTok{import} \DataTypeTok{Prelude} \KeywordTok{hiding}\NormalTok{ (}\DataTypeTok{Monad}\NormalTok{ (..), pure)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  The `do-notation` package replaces the definition of `pure`{.haskell}. If you're
  importing it into the file that defines `Ix`, make sure to use `pure`{.haskell}
  from `Prelude` when defining the `IxPointed` instance.
\end{verbatim}

With \texttt{do-notation} now enabled, we can witness the glory of what
we've accomplished. We can check the type of a
\VERB|\KeywordTok{do}|-block once without \texttt{-XRebindableSyntax},
and then once again with it enabled.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\KeywordTok{do}\NormalTok{ \{ }\FunctionTok{undefined}\NormalTok{; }\FunctionTok{undefined}\NormalTok{ \}}
\KeywordTok{do}\NormalTok{ \{ }\FunctionTok{undefined}\NormalTok{; }\FunctionTok{undefined}\NormalTok{ \}}\OtherTok{ ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ m b}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{set }\OperatorTok{{-}}\DataTypeTok{XRebindableSyntax}
\KeywordTok{do}\NormalTok{ \{ }\FunctionTok{undefined}\NormalTok{; }\FunctionTok{undefined}\NormalTok{ \}}\OtherTok{ ::} \DataTypeTok{IxMonad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ m i k2 b}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t }\KeywordTok{do}\NormalTok{ \{ }\FunctionTok{undefined}\NormalTok{; }\FunctionTok{undefined}\NormalTok{ \}}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

\hypertarget{linear-allocations}{%
\section{Linear Allocations}\label{linear-allocations}}

Now that we're capable of transforming monads into indexed monads, what
can we do with this?

One particularly compelling use-case of indexed monads is ensuring that
monadic actions occur in the right order. In this section, we will write
an \texttt{IxMonad} which allows you to open file handles, and requires
you to close each of them exactly one time. Anything else will refuse to
compile.

In order to implement such a thing, we'll need to track whether a file
handle is open or closed---and we'll need to do it at the type-level.
The dumbest possible thing that could work is to keep a type-level list
whose elements represent the open files. As we open files we can insert
into it, and as we close them we can delete from it. Elegant, no, but it
will get the job done.

We'll also need a means of generating unique keys for file handles. A
strictly increasing \texttt{Nat} will do the trick, which leads us to
this data definition:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{LinearState} \OtherTok{=} \DataTypeTok{LinearState}
\NormalTok{  \{}\OtherTok{ linearNextKey  ::} \DataTypeTok{Nat}
\NormalTok{  ,}\OtherTok{ linearOpenKeys ::}\NormalTok{ [}\DataTypeTok{Nat}\NormalTok{]}
\NormalTok{  \}}
\end{Highlighting}
\end{Shaded}

\texttt{LinearState} exists solely to be used as a data kind. It will
correspond to the ``index'' of our indexed monad. Any given monadic
operation will be parameterized by the \texttt{LinearState} going into
it and the \texttt{LinearState} coming out of it. We can show this
directly by writing a newtype around \texttt{Ix}, which specializes the
underlying monad, and the kinds of its indices.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{Linear}\NormalTok{ s (}\OtherTok{i ::} \DataTypeTok{LinearState}\NormalTok{)}
\NormalTok{                 (}\OtherTok{j ::} \DataTypeTok{LinearState}\NormalTok{) a }\OtherTok{=} \DataTypeTok{Linear}
\NormalTok{  \{}\OtherTok{ unsafeRunLinear ::} \DataTypeTok{Ix} \DataTypeTok{IO}\NormalTok{ i j a}
\NormalTok{  \}}
  \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{IxFunctor}\NormalTok{, }\DataTypeTok{IxPointed}\NormalTok{, }\DataTypeTok{IxApplicative}\NormalTok{, }\DataTypeTok{IxMonad}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{s} type parameter here is to be used with the ST trick
(Chapter~\ref{sec:ST} trick) to prevent file handles from leaking out of
the \texttt{Linear} context.

\VERB|\NormalTok{unsafeRunLinear}| is unsafe in two ways---it lets us
run arbitrary \texttt{Linear} computations, including incomplete ones in
which we haven't yet closed all of our file handles. Additionally, it
doesn't existentialize \texttt{s}, meaning file handles can leak out of
it. We'll write a safer alternative later.

We can make \texttt{Linear} a little more usable by introducing
\VERB|\NormalTok{openFile}|.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{openFile}
\OtherTok{    ::} \DataTypeTok{FilePath}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{IOMode}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Linear}\NormalTok{ s (}\DataTypeTok{\textquotesingle{}LinearState}\NormalTok{ next open)  }\annotate{1}
\NormalTok{                (}\DataTypeTok{\textquotesingle{}LinearState}
\NormalTok{                    (next }\OperatorTok{TL.+} \DecValTok{1}\NormalTok{)  }\annotate{2}
\NormalTok{                    (next }\CharTok{\textquotesingle{}: open))  {-}{-} ! 3}
\NormalTok{                (}\DataTypeTok{Handle}\NormalTok{ s next)}
\NormalTok{openFile }\OtherTok{=}\NormalTok{ coerce SIO.openFile}
\end{Highlighting}
\end{Shaded}

\VERB|\NormalTok{openFile}|'s term-level implementation merely lifts
\VERB|\NormalTok{System.IO.openFile}|. What's interesting about it is
its type signature. At \ann{1}, we say this function can be used for any
\texttt{next} and \texttt{open}. However, the post-condition of
\VERB|\NormalTok{openFile}| is that \texttt{next} is incremented
(\ann{2}), and that we insert \texttt{next} into the open set (\ann{3}).

\VERB|\NormalTok{openFile}| returns a lifted \texttt{Handle} whose
identifier is \texttt{next}. The \texttt{Handle} itself is tied to the
\texttt{Linear} via the ST-trick (the \texttt{s} parameter.)

The \texttt{Handle} type itself isn't very interesting either, it's
simply a wrapper around \texttt{System.IO.Handle} with the two phantom
types specified by \texttt{openFile}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{Handle}\NormalTok{ s key }\OtherTok{=} \DataTypeTok{Handle}
\NormalTok{  \{}\OtherTok{ unsafeGetHandle ::} \DataTypeTok{SIO.Handle}
\NormalTok{  \}}
\end{Highlighting}
\end{Shaded}

In order to define \VERB|\NormalTok{closeFile}|, we'll first need
machinery to determine whether or not a \texttt{Handle} is already in
the open set. This turns out to be quite a straight-forward FCF.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{IsOpen}\NormalTok{ (}\OtherTok{key ::}\NormalTok{ k) (}\OtherTok{ts ::}\NormalTok{ [k])}
  \OtherTok{=} \DataTypeTok{IsJust} \OperatorTok{=\textless{}\textless{}} \DataTypeTok{Find}\NormalTok{ (}\DataTypeTok{TyEq}\NormalTok{ key) ts}
\end{Highlighting}
\end{Shaded}

Additionally, we'll need an FCF to compute the result of removing a
handle from the open set.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{Close}\NormalTok{ (}\OtherTok{key ::}\NormalTok{ k) (}\OtherTok{ts ::}\NormalTok{ [k])}
  \OtherTok{=} \DataTypeTok{Filter}\NormalTok{ (}\DataTypeTok{Not} \OperatorTok{\textless{}=\textless{}} \DataTypeTok{TyEq}\NormalTok{ key) ts}
\end{Highlighting}
\end{Shaded}

The definition of \VERB|\NormalTok{closeFile}| is rather uninteresting.
It must ensure a file is already open, and then remove it from the
indexed state's open set.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{closeFile}
\OtherTok{    ::} \DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{IsOpen}\NormalTok{ key open) }\OperatorTok{\textasciitilde{}} \DataTypeTok{\textquotesingle{}True}
    \OtherTok{=\textgreater{}} \DataTypeTok{Handle}\NormalTok{ s key}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Linear}\NormalTok{ s (}\DataTypeTok{\textquotesingle{}LinearState}\NormalTok{ next open)}
\NormalTok{                (}\DataTypeTok{\textquotesingle{}LinearState}\NormalTok{ next (}\DataTypeTok{Eval}\NormalTok{ (}\DataTypeTok{Close}\NormalTok{ key open)))}
\NormalTok{                ()}
\NormalTok{closeFile }\OtherTok{=}\NormalTok{ coerce SIO.hClose}
\end{Highlighting}
\end{Shaded}

Since we increment \texttt{next} in \VERB|\NormalTok{openFile}|, should
we decrement it here? The answer is no---\texttt{next} is used solely to
generate a unique \texttt{Nat} for newly opened handles. If it were
decremented as handles were closed it would be pretty trivial to get two
\texttt{Handle}s with the same \texttt{key}. The type system would get
confused pretty quick if such a thing were to occur.

We're now in a position to write a safe version of
\VERB|\NormalTok{unsafeRunLinear}|. It's safe to run a \texttt{Linear}
if its final state has no open files, assuming it had no open files to
begin with. We start the next id counter at \texttt{0}, and can rely on
the ST-trick to prevent these \texttt{Handle}s from leaking out.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{runLinear}
\OtherTok{    ::}\NormalTok{ ( }\KeywordTok{forall}\NormalTok{ s}
       \OperatorTok{.} \DataTypeTok{Linear}\NormalTok{ s (}\DataTypeTok{\textquotesingle{}LinearState} \DecValTok{0} \CharTok{\textquotesingle{}[])}
\NormalTok{                  (}\DataTypeTok{\textquotesingle{}LinearState}\NormalTok{ n }\CharTok{\textquotesingle{}[]) a}
\NormalTok{       )}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ a}
\NormalTok{runLinear }\OtherTok{=}\NormalTok{ coerce}
\end{Highlighting}
\end{Shaded}

Let's convince ourselves that everything works. The happy path is one
where we close our file after we're done with it.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \KeywordTok{let}\NormalTok{ etcPasswd }\OtherTok{=}\NormalTok{ openFile }\StringTok{"/etc/passwd"} \DataTypeTok{ReadMode}
\NormalTok{runLinear (etcPasswd }\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ closeFile)}\OtherTok{ ::} \DataTypeTok{IO}\NormalTok{ ()}


\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t runLinear (etcPasswd }\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ closeFile)}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

No problems. What if we don't close our file?

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{@}\NormalTok{let etcPasswd }\OtherTok{=}\NormalTok{ openFile }\StringTok{"/etc/passwd"} \DataTypeTok{ReadMode}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

This results in a disgusting type error, which could be cleaned up using
the techniques described Chapter~\ref{sec:type} errors.

What if we try to close a file more than once?

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{@}\NormalTok{let etcPasswd }\OtherTok{=}\NormalTok{ openFile }\StringTok{"/etc/passwd"} \DataTypeTok{ReadMode}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

This also rightfully fails to compile. The final thing we should test is
what happens if we attempt to return a \texttt{Handle} from a
\texttt{Linear} block.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{@}\NormalTok{let etcPasswd }\OtherTok{=}\NormalTok{ openFile }\StringTok{"/etc/passwd"} \DataTypeTok{ReadMode}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

As expected, here the ST-trick saves our bacon.

This is a good place to stop. Indexed monads are a great solution to
enforcing invariants on the \emph{ordering} of monadic actions. Because
they're slightly hampered by their syntactic limitations, and as such
probably shouldn't be the first tool you reach for.

\hypertarget{dependent-types}{%
\chapter{Dependent Types}\label{dependent-types}}

Dependent types are types which depend on the result of \emph{runtime
values.} This is an odd thing. In Haskell, traditionally terms and types
on different sides of the phase barrier; terms exist only at runtime,
and types only at compile-time.

Proponents of dynamic typing are likely less phased by the idea of
dependent types---their typing mechanisms, if they have any at all, must
exist at runtime. But as we will see, we don't need to give up type
safety in order to work with dependent types.

The field of dependent types is fast-growing, and any attempt to
describe it definitively is doomed to fail. Professor and
GHC-contributor Richard Eisenberg is actively working on bringing
first-class dependent types to Haskell, though his projections estimate
it to not be available for a few years.

In the meantime, we have no recourse but to abuse language features in
order to gain an approximation of dependent types, content with the
knowledge that the process will only get easier as time goes on. While
the \emph{techniques} in this section will likely be deprecated sooner
than later, the \emph{ideas} will carry on.

It's also a good culmination of ideas already presented in this book.
The motivated reader can use this section as a test of their
understanding of many disparate pieces of the type system, including
rank-\emph{n} types, GADTs, type families, and data kinds, among others.

\hypertarget{overview}{%
\section{Overview}\label{overview}}

Dependent types in Haskell can be approximated via singletons, which are
to be understood as an isomorphism between terms and types.

Consider the unit type \texttt{()}, whose only inhabitant is the unit
value \VERB|\NormalTok{()}|. This type has an interesting property; if
you know a value's type is unit, you know what the value must be. The
type \texttt{()} is a singleton, because it only has a single term.
Furthermore, because of this one-to-one representation, we can think
about the unit type as being able to cross the term--type divide at
will.

Singleton types are just this idea taken to the extreme; for every
inhabitant of a type, we create a singleton type capable of bridging the
term--type divide. The singleton allows us to move between terms to
types and vice versa. As a result, we are capable of moving types to
terms, using them in regular term-level Haskell computations, and then
lifting them back into types.

Notice that data kinds already give us type-level representations of
terms; recall that \texttt{\textquotesingle{}True} is the promoted data
constructor of \VERB|\DataTypeTok{True}|.

\hypertarget{ad-hoc-implementation}{%
\section{Ad-Hoc Implementation}\label{ad-hoc-implementation}}

To wet our whistles, let's first look at a simple implementation of
singletons. We begin with the singletons themselves.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SBool}\NormalTok{ (}\OtherTok{b ::} \DataTypeTok{Bool}\NormalTok{) }\KeywordTok{where}
  \DataTypeTok{STrue}\OtherTok{  ::} \DataTypeTok{SBool} \DataTypeTok{\textquotesingle{}True}
  \DataTypeTok{SFalse}\OtherTok{ ::} \DataTypeTok{SBool} \DataTypeTok{\textquotesingle{}False}
\end{Highlighting}
\end{Shaded}

The data constructors \VERB|\DataTypeTok{STrue}| and
\VERB|\DataTypeTok{SFalse}| act as our bridge between the term and
type-levels. Both are terms, but are the sole inhabitants of their
types. We thus have isomorphisms \texttt{STrue} ≅
\texttt{\textquotesingle{}True} and \texttt{SFalse} ≅
\texttt{\textquotesingle{}False}. The next step is to find an
isomorphism between \texttt{Bool} ≅ \texttt{SBool\ b}. This is easy in
one direction.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{fromSBool ::} \DataTypeTok{SBool}\NormalTok{ b }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{fromSBool }\DataTypeTok{STrue}  \OtherTok{=} \DataTypeTok{True}
\NormalTok{fromSBool }\DataTypeTok{SFalse} \OtherTok{=} \DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

The converse however is trickier. Because
\texttt{SBool\ \textquotesingle{}True} is a different type than
\texttt{SBool\ \textquotesingle{}False}, we are unable to directly write
the other side of the isomorphism. Instead, we introduce an existential
wrapper \texttt{SomeSBool} and eliminator.

\href{Snip}{code/AdHocSingletons.hs:SomeSBool}
\href{Snip}{code/AdHocSingletons.hs:withSomeSBool}

\VERB|\NormalTok{toSBool}| can now be written in terms of
\texttt{SomeSBool}.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{toSBool ::} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{SomeSBool}
\NormalTok{toSBool }\DataTypeTok{True}  \OtherTok{=} \DataTypeTok{SomeSBool} \DataTypeTok{STrue}
\NormalTok{toSBool }\DataTypeTok{False} \OtherTok{=} \DataTypeTok{SomeSBool} \DataTypeTok{SFalse}
\end{Highlighting}
\end{Shaded}

It makes intuitive sense that \VERB|\NormalTok{toSBool}| would need to
return an existential type, as there is no guarantee its arguments are
known at compile-time. Perhaps the \texttt{Bool} being singletonized
came from the user, or across the network. We can convince ourselves
that \VERB|\NormalTok{fromSBool}| and \VERB|\NormalTok{toSBool}| behave
sanely.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ withSomeSBool (toSBool }\DataTypeTok{True}\NormalTok{)  fromSBool}
\DataTypeTok{True}


\OperatorTok{\textgreater{}}\NormalTok{ withSomeSBool (toSBool }\DataTypeTok{False}\NormalTok{) fromSBool}
\DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

As an example of the usefulness of singletons, we will build a monad
stack which can conditionally log messages. These messages will only be
for debugging, and thus should be disabled for production builds. While
one approach to this problem is to simply branch at runtime depending on
whether logging is enabled, this carries with it a performance impact.
Instead, we can conditionally choose our monad stack depending on a
runtime value.

We begin with a typeclass indexed over \texttt{Bool}. It has an
associated type family to select the correct monad stack, as well as a
few methods for working with the stack.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Monad}\NormalTok{ (}\DataTypeTok{LoggingMonad}\NormalTok{ b)}
      \OtherTok{=\textgreater{}} \DataTypeTok{MonadLogging}\NormalTok{ (}\OtherTok{b ::} \DataTypeTok{Bool}\NormalTok{) }\KeywordTok{where}
  \KeywordTok{type} \DataTypeTok{LoggingMonad}\NormalTok{ b }\OtherTok{=}\NormalTok{ (}\OtherTok{r ::} \DataTypeTok{Type} \OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{)  }\annotate{1}
         \OperatorTok{|}\NormalTok{ r }\OtherTok{{-}\textgreater{}}\NormalTok{ b  }\annotate{2}
\OtherTok{  logMsg ::} \DataTypeTok{String} \OtherTok{{-}\textgreater{}} \DataTypeTok{LoggingMonad}\NormalTok{ b ()}
\OtherTok{  runLogging ::} \DataTypeTok{LoggingMonad}\NormalTok{ b a }\OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

The
\VERB|\OperatorTok{\VerbBar{}}\NormalTok{ r }\OtherTok{{-}\textgreater{}}\NormalTok{ b}|
notation at \ann{2} is known as a type family dependency and acts as an
injectivity annotation. In other words, it tells Haskell that if it
knows \texttt{LoggingMonad\ b} it can infer \texttt{b}. The
\texttt{\textquotesingle{}False} case is uninteresting, as it ignores
any attempts to log messages.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{MonadLogging} \DataTypeTok{\textquotesingle{}False} \KeywordTok{where}
  \KeywordTok{type} \DataTypeTok{LoggingMonad} \DataTypeTok{\textquotesingle{}False} \OtherTok{=} \DataTypeTok{IO}
\NormalTok{  logMsg \_ }\OtherTok{=} \FunctionTok{pure}\NormalTok{ ()}
\NormalTok{  runLogging }\OtherTok{=} \FunctionTok{id}
\end{Highlighting}
\end{Shaded}

However, in the case of \texttt{\textquotesingle{}True}, we'd like to
introduce a \texttt{WriterT\ {[}String{]}} transformer over the monad
stack. Running a \texttt{LoggingMonad\ \textquotesingle{}True} should
print out all of its logged messages after running the program.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{MonadLogging} \DataTypeTok{\textquotesingle{}True} \KeywordTok{where}
  \KeywordTok{type} \DataTypeTok{LoggingMonad} \DataTypeTok{\textquotesingle{}True} \OtherTok{=} \DataTypeTok{WriterT}\NormalTok{ [}\DataTypeTok{String}\NormalTok{] }\DataTypeTok{IO}
\NormalTok{  logMsg s }\OtherTok{=}\NormalTok{ tell [s]}
\NormalTok{  runLogging m }\OtherTok{=} \KeywordTok{do}
\NormalTok{    (a, w) }\OtherTok{\textless{}{-}}\NormalTok{ runWriterT m}
\NormalTok{    for\_ w }\FunctionTok{putStrLn}
    \FunctionTok{pure}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

With this machinery in place, we are capable of writing a program that
logs messages. When invoked in
\texttt{LoggingMonad\ \textquotesingle{}False} it should have no side
effects, but when run in \texttt{LoggingMonad\ \textquotesingle{}True}
it will print \VERB|\StringTok{"hello world"}|.

\href{Snip}{code/AdHocSingletons.hs:program}
\href{Snip}{code/AdHocSingletons.hs:badMain}

This function reads a \texttt{Bool} from stdin, and lifts it into a
singleton at \ann{1}. The resulting existential type \texttt{b} is bound
at \ann{2} and type-applied at \ann{3} in order to tell Haskell which
monad stack it should use to run \VERB|\NormalTok{program}|.

Unfortunately, \VERB|\NormalTok{main}| fails to compile.

\begin{verbatim}
<interactive>:87:5: error:
    • No instance for (MonadLogging b)
        arising from a use of ‘runLogging’
\end{verbatim}

The problem is that typeclasses are implemented in GHC as implicitly
passed variables. By \ann{3}, GHC doesn't know the type of \texttt{b},
and thus can't find the appropriate \texttt{MonadLogging}
dictionary---even though \texttt{MonadLogging} is total and
theoretically GHC should be able to determine this.

We can help GHC along by writing a function that can deliver
dictionaries for any constraint that is total over \texttt{Bool}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dict}
\OtherTok{  ::}\NormalTok{ ( c }\DataTypeTok{\textquotesingle{}True}  \annotate{1}
\NormalTok{     , c }\DataTypeTok{\textquotesingle{}False}
\NormalTok{     )}
  \OtherTok{=\textgreater{}} \DataTypeTok{SBool}\NormalTok{ b  }\annotate{2}
  \OtherTok{{-}\textgreater{}} \DataTypeTok{Dict}\NormalTok{ (c b)}
\NormalTok{dict }\DataTypeTok{STrue}  \OtherTok{=} \DataTypeTok{Dict}  \annotate{3}
\NormalTok{dict }\DataTypeTok{SFalse} \OtherTok{=} \DataTypeTok{Dict}
\end{Highlighting}
\end{Shaded}

\VERB|\NormalTok{dict}| works by requiring some
\texttt{Bool\ -\textgreater{}\ Constraint} to be satisfied for both
\texttt{\textquotesingle{}True} and \texttt{\textquotesingle{}False}
(\ann{1}). It then takes a singleton (\ann{2}) and uses that to deliver
the appropriate \texttt{Dict\ (c\ b)} by branching at \ann{3}. The fact
that both branches simply return \VERB|\DataTypeTok{Dict}| might be
confusing---but remember that GHC infers different types for them due to
the type-equality implicit in the GADT match. \VERB|\NormalTok{dict}|
can be invoked with a \texttt{Bool\ -\textgreater{}\ Constraint}
type-application to select the desired constraint.

Finally, we can write a working \VERB|\NormalTok{main}| which acquires
the correct typeclass dictionary using the singleton it lifted.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{main ::} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{main bool }\OtherTok{=} \KeywordTok{do}
\NormalTok{  withSomeSBool (toSBool bool) }\OperatorTok{$}\NormalTok{ \textbackslash{}(}\OtherTok{sb ::} \DataTypeTok{SBool}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}
    \KeywordTok{case}\NormalTok{ dict }\OperatorTok{@}\DataTypeTok{MonadLogging}\NormalTok{ sb }\KeywordTok{of}
      \DataTypeTok{Dict} \OtherTok{{-}\textgreater{}}\NormalTok{ runLogging }\OperatorTok{@}\NormalTok{b program}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ main }\DataTypeTok{True}
\NormalTok{hello world}


\OperatorTok{\textgreater{}}\NormalTok{ main }\DataTypeTok{False}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

Here we have provided an isomorphism \texttt{Bool} ≅ \texttt{SBool\ a}
and from \texttt{SBool\ a} ≅ \texttt{a\ ::\ Bool}. Because isomorphisms
are transitive, this means we have the desired correspondence between
terms and types as witnessed by \texttt{Bool} ≅ \texttt{a\ ::\ Bool}.

\hypertarget{generalized-machinery}{%
\section{Generalized Machinery}\label{generalized-machinery}}

While the \texttt{SBool} approach works well enough for lifting
\texttt{Bool}s, it's not immediately evident how to generalize the
pattern to be ergonomic when working with many different types.

We begin with a poly-kinded open data family, which is responsible for
indexing the equivalents of \texttt{SBool}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \KeywordTok{family} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{a ::}\NormalTok{ k)}
\end{Highlighting}
\end{Shaded}

\texttt{SomeSing} and its eliminator carry over as before.

\href{Snip}{code/Singletons.hs:SomeSing}
\href{Snip}{code/Singletons.hs:withSomeSing}

However, it is more ergonomic to package together
\VERB|\NormalTok{toSing}| and \VERB|\NormalTok{fromSing}| into a
typeclass rather than be independent functions.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{SingKind}\NormalTok{ k }\KeywordTok{where}
  \KeywordTok{type} \DataTypeTok{Demote}\NormalTok{ k }\OtherTok{=}\NormalTok{ r }\OperatorTok{|}\NormalTok{ r }\OtherTok{{-}\textgreater{}}\NormalTok{ k }\annotate{1}
\OtherTok{  toSing ::} \DataTypeTok{Demote}\NormalTok{ k }\OtherTok{{-}\textgreater{}} \DataTypeTok{SomeSing}\NormalTok{ k}
\OtherTok{  fromSing ::} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{a ::}\NormalTok{ k) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Demote}\NormalTok{ k  }\annotate{2}
\end{Highlighting}
\end{Shaded}

Notice that at \ann{2}, the type variable \texttt{k} is used \emph{both
as a type and as a kind.} This requires the \texttt{-XTypeInType}
language extension, which removes the distinction between types and
kinds. Additionally, it makes the type \texttt{Type} an inhabitant of
\texttt{Type} (which is now the same thing as \texttt{Type} itself!)
Mathematician readers will likely fear the unsoundities resulting from
this change---but Richard Eisenberg, the author of this feature, assures
us these paradoxes are not observable in Haskell.

The associated type family \texttt{Demote\ k} (\ann{1}) is an
implementation detail. It is almost always equal to \texttt{k}, except
in cases when GHC already provides a type literal (for \texttt{Nat} and
\texttt{Symbol}.) A type family dependency is added to \texttt{Demote},
allowing GHC to infer \texttt{k} from \texttt{Demote\ k}.

Instances of \texttt{Sing} and \texttt{SingKind} are trivially provided
for \texttt{Bool}.

\href{Snip}{code/Singletons.hs:SingBool}
\href{Snip}{code/Singletons.hs:SingKindBool}

This machinery is enough to recover our previous round-trip examples.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}}\NormalTok{ withSomeSing (toSing }\DataTypeTok{True}\NormalTok{) fromSing}
\DataTypeTok{True}


\OperatorTok{\textgreater{}}\NormalTok{ withSomeSing (toSing }\DataTypeTok{False}\NormalTok{) fromSing}
\DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

Because singletons are the unique inhabitant of their types, at the
term-level they are isomorphic with \texttt{()}. Therefore, we expect to
be able to get this unique inhabitant, in the same way we can always
conjure a \texttt{()} out of thin air.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{SingI}\NormalTok{ (}\OtherTok{a ::}\NormalTok{ k) }\KeywordTok{where}
\OtherTok{  sing ::} \DataTypeTok{Sing}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

Instances of \texttt{SingI} are predictably uninteresting.

\href{Snip}{code/Singletons.hs:SingITrue}
\href{Snip}{code/Singletons.hs:SingIFalse}

The \VERB|\NormalTok{sing}| function can be used with
\texttt{-XTypeApplications} in order to retrieve the desired singleton.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textgreater{}} \OperatorTok{:}\NormalTok{t sing }\OperatorTok{@}\DataTypeTok{\textquotesingle{}True}
\DataTypeTok{Leaving} \DataTypeTok{GHCi}\OperatorTok{.}
\end{Highlighting}
\end{Shaded}

Singletons can also be provided for more interesting types. For example,
if we have singletons for \texttt{a}, we can build singletons for
\texttt{Maybe\ a}.

\href{Snip}{code/Singletons.hs:SingMaybe}
\href{Snip}{code/Singletons.hs:SingIJust}
\href{Snip}{code/Singletons.hs:SingINothing}
\href{Snip}{code/Singletons.hs:SingKindMaybe}

Besides some relatively tricky wrapping of existentials, there is
nothing new or interesting in this code. If a given data constructor is
built out of other pieces of data, its singletons are built out of the
analogous singletons, and its data kinds out of the analogous promoted
data constructors.

To get a feel for this transformation, we can also build singletons for
lists.

\href{Snip}{code/Singletons.hs:SingList}
\href{Snip}{code/Singletons.hs:SingKindList}

\begin{verbatim}
Provide instances of `SingI` for lists.
\end{verbatim}

\begin{verbatim}
[code/Singletons.hs:SingINil](Snip)
[code/Singletons.hs:SingICons](Snip)
\end{verbatim}

\hypertarget{the-singletons-package}{%
\section{The Singletons Package}\label{the-singletons-package}}

The construction of singletons is entirely mechanical. The
\texttt{singletons} ({\textbf{???}}) package provides TemplateHaskell
capable of writing singletons for us (as well as automatically promoting
term-level functions.)

By enabling \texttt{-XTemplateHaskell} and the other slew of extensions
listed above, \texttt{singletons} is capable of generating singletons
for us. Data definitions can be wrapped in the definitions quasiquoter
\VERB|\NormalTok{[d\VerbBar{} ... \VerbBar{}]}|, and run via the
\VERB|\NormalTok{singletons}| function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{singletons [d|}
\NormalTok{  data TimeOfDay}
\NormalTok{    = Morning}
\NormalTok{    | Afternoon}
\NormalTok{    | Evening}
\NormalTok{    | Night}
\NormalTok{    deriving (Eq, Ord, Show)}
\NormalTok{  |]}
\end{Highlighting}
\end{Shaded}

The resulting splice will be completely equivalent to our hand-rolled
code above, including instances for \texttt{Sing}, \texttt{SingKind} and
\texttt{SingI}. In addition, if the definitions have \texttt{Eq}
instances, \texttt{singletons} will also generate \texttt{SDecide}
instances for them.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{SDecide}\NormalTok{ k }\KeywordTok{where}
\OtherTok{  (\%\textasciitilde{}) ::} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{a ::}\NormalTok{ k)}
       \OtherTok{{-}\textgreater{}} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{b ::}\NormalTok{ k)}
       \OtherTok{{-}\textgreater{}} \DataTypeTok{Decision}\NormalTok{ (a }\OperatorTok{:\textasciitilde{}:}\NormalTok{ b)}
\end{Highlighting}
\end{Shaded}

\texttt{SDecide} is nominal equality for singletons; if two
\texttt{Sing}s of the same kind are equal, \texttt{SDecide} allows us to
use that fact. Recall the definition of
\texttt{a\ :\textasciitilde{}:\ b}, which is only constructable if
\texttt{a\ \textasciitilde{}\ b}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{ a }\OperatorTok{:\textasciitilde{}:}\NormalTok{ b }\KeywordTok{where}
  \DataTypeTok{Refl}\OtherTok{ ::}\NormalTok{ a }\OperatorTok{:\textasciitilde{}:}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

\texttt{Decision} is defined as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Decision}\NormalTok{ a}
  \OtherTok{=} \DataTypeTok{Proved}\NormalTok{ a}
  \OperatorTok{|} \DataTypeTok{Disproved}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Void}\NormalTok{)  }\annotate{1}
\end{Highlighting}
\end{Shaded}

The type \texttt{a\ -\textgreater{}\ Void} at \ann{1} is the
Curry--Howard encoding of logical false---because \texttt{Void} is
uninhabited, it can't be constructed. Thus, a function that produces
\texttt{Void} must not be callable, since it can't ever produce a
\texttt{Void}; and the only way a function isn't callable is if its
domain is also uninhabited.

A ``free'' instance of \texttt{SDecide} can be given for all types with
well-behaving \texttt{Eq} instances by ``cheating'' with our equality
proofs. The desired \texttt{a\ \textasciitilde{}\ b} proof can be
generated via \VERB|\NormalTok{unsafeCoerce}|, which is safe due to our
term-level equality check.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{Eq}\NormalTok{ (}\DataTypeTok{Demote}\NormalTok{ k), }\DataTypeTok{SingKind}\NormalTok{ k)}
      \OtherTok{=\textgreater{}} \DataTypeTok{SDecide}\NormalTok{ k }\KeywordTok{where}
\NormalTok{  a }\OperatorTok{\%\textasciitilde{}}\NormalTok{ b }\OtherTok{=}
    \KeywordTok{if}\NormalTok{ fromSing a }\OperatorTok{==}\NormalTok{ fromSing b}
       \KeywordTok{then} \DataTypeTok{Proved} \OperatorTok{$}\NormalTok{ unsafeCoerce }\DataTypeTok{Refl}
       \KeywordTok{else} \DataTypeTok{Disproved} \OperatorTok{$} \FunctionTok{const} \FunctionTok{undefined}
\end{Highlighting}
\end{Shaded}

This instance doesn't actually exist in \texttt{singletons}, but it's a
nice demonstration of the old motto ``if it's too hard at the
type-level, do it at the term-level.''

Of course, real instances can be provided as well.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{SDecide} \DataTypeTok{Bool} \KeywordTok{where}
  \DataTypeTok{STrue}  \OperatorTok{\%\textasciitilde{}} \DataTypeTok{STrue}  \OtherTok{=} \DataTypeTok{Proved} \DataTypeTok{Refl}
  \DataTypeTok{SFalse} \OperatorTok{\%\textasciitilde{}} \DataTypeTok{SFalse} \OtherTok{=} \DataTypeTok{Proved} \DataTypeTok{Refl}
\NormalTok{  \_ }\OperatorTok{\%\textasciitilde{}}\NormalTok{ \_ }\OtherTok{=} \DataTypeTok{Disproved} \OperatorTok{$} \FunctionTok{const} \FunctionTok{undefined}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Give instances of `SDecide` for `Maybe`.
\end{verbatim}

\begin{verbatim}
[code/Singletons.hs:SDecideMaybe](Snip)
\end{verbatim}

\hypertarget{dependent-pairs}{%
\section{Dependent Pairs}\label{dependent-pairs}}

Sigma types also known as dependent pairs, generalize arbitrarily-deeply
nested \texttt{Either} types parameterized by a type. When viewed
through the lens of the Curry--Howard isomorphism, they correspond to
the existential quantifier \(\exists\).

What does this mean? Sigma types are the pair of an existential
singleton and \emph{a type indexed by that singleton.} Consider the
definition:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Sigma}\NormalTok{ (}\OtherTok{f ::}\NormalTok{ k }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{) }\KeywordTok{where}
  \DataTypeTok{Sigma}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Sigma}\NormalTok{ f}
\end{Highlighting}
\end{Shaded}

\texttt{Sigma} takes a singleton for an existential type \texttt{a} (of
kind \texttt{k}), and datatype \texttt{f\ a}. Notice that \texttt{f\ a}
is parameterized on the existential type \texttt{a}; as a result,
\texttt{Sigma\ f} might be any number of possible \texttt{f\ a}s.
However, \texttt{a} is not truly existential, as we have its singleton
to work with.

As usual, we can provide an eliminator for \texttt{Sigma}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{withSigma}
\OtherTok{    ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ (}\OtherTok{a ::}\NormalTok{ k)}\OperatorTok{.} \DataTypeTok{Sing}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ r)}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Sigma}\NormalTok{ f}
    \OtherTok{{-}\textgreater{}}\NormalTok{ r}
\NormalTok{withSigma c (}\DataTypeTok{Sigma}\NormalTok{ s f) }\OtherTok{=}\NormalTok{ c s f}
\end{Highlighting}
\end{Shaded}

But, using \texttt{SingI}, we can also provide an introduction for
\texttt{Sigma}. \VERB|\NormalTok{toSigma}| lifts an arbitrary
\texttt{f\ a} into a \texttt{Sigma\ f}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{toSigma}
\OtherTok{    ::} \DataTypeTok{SingI}\NormalTok{ a}
    \OtherTok{=\textgreater{}}\NormalTok{ f a}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Sigma}\NormalTok{ f}
\NormalTok{toSigma fa }\OtherTok{=} \DataTypeTok{Sigma}\NormalTok{ sing fa}
\end{Highlighting}
\end{Shaded}

The singleton inside \texttt{Sigma} can additionally be used to help
cast a \texttt{Sigma\ f} back into a \texttt{f\ a}; assuming the type
inside is the same one being requested. This is done via
\texttt{SDecide} to convince the type system such a cast is legal.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fromSigma}
\OtherTok{    ::} \KeywordTok{forall}\NormalTok{ k (}\OtherTok{a ::}\NormalTok{ k) (}\OtherTok{f ::}\NormalTok{ k }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{)}
     \OperatorTok{.}\NormalTok{ ( }\DataTypeTok{SingI}\NormalTok{ a}
\NormalTok{       , }\DataTypeTok{SDecide}\NormalTok{ k}
\NormalTok{       )}
    \OtherTok{=\textgreater{}} \DataTypeTok{Sigma}\NormalTok{ f}
    \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ (f a)}
\NormalTok{fromSigma (}\DataTypeTok{Sigma}\NormalTok{ s f) }\OtherTok{=}
  \KeywordTok{case}\NormalTok{ s }\OperatorTok{\%\textasciitilde{}}\NormalTok{ sing }\OperatorTok{@}\NormalTok{a }\KeywordTok{of}
    \DataTypeTok{Proved} \DataTypeTok{Refl} \OtherTok{{-}\textgreater{}} \DataTypeTok{Just}\NormalTok{ f  }\annotate{1}
    \DataTypeTok{Disproved}\NormalTok{ \_ }\OtherTok{{-}\textgreater{}} \DataTypeTok{Nothing}
\end{Highlighting}
\end{Shaded}

By pattern matching on \VERB|\DataTypeTok{Refl}| at \ann{1}, GHC learns
that \texttt{a\ \textasciitilde{}\ t}, where \texttt{t} is the
``existential'' type inside of the \texttt{Sigma}. With this equality in
hand, it's clearly safe to return the \texttt{f\ t} when asking for a
\texttt{f\ a}.

The \VERB|\NormalTok{dict}| function from our logging example can also
be generalized into a typeclass capable of providing total constraints
given a singleton.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Dict1}\NormalTok{ c (}\OtherTok{f ::}\NormalTok{ k }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{) }\KeywordTok{where}
\OtherTok{  dict1 ::} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{a ::}\NormalTok{ k) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Dict}\NormalTok{ (c (f a))}
\end{Highlighting}
\end{Shaded}

\texttt{c} has kind \texttt{Type\ -\textgreater{}\ Constraint} and
\texttt{f} has kind \texttt{k\ -\textgreater{}\ Type}. Since we have
\texttt{a} with kind \texttt{k} from the singleton, this chain of
constraints can be traversed to get a \texttt{Constraint}. Given a
singleton, \VERB|\NormalTok{dict1}| will provide the requested
dictionary, and it will fail at compile-time if the requested constraint
isn't total over \texttt{f}.

A \texttt{Dict1} instance can be used to lift \texttt{Eq} over
\texttt{Sigma}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ ( }\DataTypeTok{Dict1} \DataTypeTok{Eq}\NormalTok{ (}\OtherTok{f ::}\NormalTok{ k }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{)  }\annotate{1}
\NormalTok{         , }\DataTypeTok{SDecide}\NormalTok{ k}
\NormalTok{         ) }\OtherTok{=\textgreater{}} \DataTypeTok{Eq}\NormalTok{ (}\DataTypeTok{Sigma}\NormalTok{ f) }\KeywordTok{where}
  \DataTypeTok{Sigma}\NormalTok{ sa fa }\OperatorTok{==} \DataTypeTok{Sigma}\NormalTok{ sb fb }\OtherTok{=}
    \KeywordTok{case}\NormalTok{ sa }\OperatorTok{\%\textasciitilde{}}\NormalTok{ sb }\KeywordTok{of}
      \DataTypeTok{Proved} \DataTypeTok{Refl} \OtherTok{{-}\textgreater{}}
        \KeywordTok{case}\NormalTok{ dict1 }\OperatorTok{@}\DataTypeTok{Eq} \OperatorTok{@}\NormalTok{f sa }\KeywordTok{of}
          \DataTypeTok{Dict} \OtherTok{{-}\textgreater{}}\NormalTok{ fa }\OperatorTok{==}\NormalTok{ fb}
      \DataTypeTok{Disproved}\NormalTok{ \_ }\OtherTok{{-}\textgreater{}} \DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

The kind signature at \ann{1} is required to associate \texttt{k} and
\texttt{f}.

\texttt{Dict1} can also be used to lift other instances, for example,
\texttt{Show}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ ( }\DataTypeTok{Dict1} \DataTypeTok{Show}\NormalTok{ (}\OtherTok{f ::}\NormalTok{ k }\OtherTok{{-}\textgreater{}} \DataTypeTok{Type}\NormalTok{)}
\NormalTok{         , }\DataTypeTok{Show}\NormalTok{ (}\DataTypeTok{Demote}\NormalTok{ k)}
\NormalTok{         , }\DataTypeTok{SingKind}\NormalTok{ k}
\NormalTok{         ) }\OtherTok{=\textgreater{}} \DataTypeTok{Show}\NormalTok{ (}\DataTypeTok{Sigma}\NormalTok{ f) }\KeywordTok{where}
  \FunctionTok{show}\NormalTok{ (}\DataTypeTok{Sigma}\NormalTok{ sa fa) }\OtherTok{=}
    \KeywordTok{case}\NormalTok{ dict1 }\OperatorTok{@}\DataTypeTok{Show} \OperatorTok{@}\NormalTok{f sa }\KeywordTok{of}
      \DataTypeTok{Dict} \OtherTok{{-}\textgreater{}} \FunctionTok{mconcat}
\NormalTok{        [ }\StringTok{"Sigma "}
\NormalTok{        , }\FunctionTok{show} \OperatorTok{$}\NormalTok{ fromSing sa}
\NormalTok{        , }\StringTok{" ("}
\NormalTok{        , }\FunctionTok{show}\NormalTok{ fa}
\NormalTok{        , }\StringTok{")"}
\NormalTok{        ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Provide an instance of `Ord` for `Sigma` by comparing the
`f`s if the singletons are equal, comparing the singletons at the term-level
otherwise.
\end{verbatim}

\begin{verbatim}
[code/Sigma.hs:OrdSigma](Snip)
\end{verbatim}

\hypertarget{structured-logging}{%
\subsection{Structured Logging}\label{structured-logging}}

As an example of what good are singletons, consider the common use-case
from dynamically-typed languages. Often, protocols will attempt ad-hoc
type-safety by taking two parameters: the first being a string
describing the type of the second.

This is a clear use for dependent types; the type of the second argument
depends on the value of the first. In particular, it is a \texttt{Sigma}
type, because once we know the type of the second parameter, the first
is no longer of interest to us.

To demonstrate the technique, consider the case of structured logging.
When we have information we'd like to log, rather than emitting it as a
string, we can instead log a datastructure. The resulting log can then
be interpreted as a string, or it can be mined for more structured data.

For this example, we will assume we have two sorts of data we'd like to
be able to log: strings and JSON. The approach can be generalized to add
more types later, and the compiler's warnings will drive us.

While an existentialized GADT approach might suffice---where we stuff
proofs of each typeclass into the datatype---it requires us to know all
of our desired dictionaries in advance. Such an approach isn't
particularly extensible, since it requires us to anticipate everything
we might like to do with our log.

Instead, we can pack this structured data into a \texttt{Sigma}, and use
the \texttt{Dict1} class to retrieve dictionaries as we need them.

We can begin by writing an enum describing which sort of data we want to
log.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{singletons [d|}
\NormalTok{  data LogType}
\NormalTok{    = JsonMsg}
\NormalTok{    | TextMsg}
\NormalTok{    deriving (Eq, Ord, Show)}
\NormalTok{  |]}
\end{Highlighting}
\end{Shaded}

An open data family \texttt{LogMsg} of kind
\texttt{LogType\ -\textgreater{}\ Type} can then be defined.
\texttt{LogMsg} is indexed by \texttt{LogType}, meaning we can build a
\texttt{Sigma} around it.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \KeywordTok{family} \DataTypeTok{LogMsg}\NormalTok{ (}\OtherTok{msg ::} \DataTypeTok{LogType}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

For every inhabitant of \texttt{LogType}, we add a
\VERB|\KeywordTok{data} \KeywordTok{instance}| for \texttt{LogMsg},
corresponding to the data we'd like to store in that case.

\href{Snip}{code/Sigma.hs:LogMsgPayloadJson}
\href{Snip}{code/Sigma.hs:LogMsgPayloadText}

And a \texttt{Dict1} instance can be provided.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ ( c (}\DataTypeTok{LogMsg} \DataTypeTok{\textquotesingle{}JsonMsg}\NormalTok{)}
\NormalTok{         , c (}\DataTypeTok{LogMsg} \DataTypeTok{\textquotesingle{}TextMsg}\NormalTok{)}
\NormalTok{         ) }\OtherTok{=\textgreater{}} \DataTypeTok{Dict1}\NormalTok{ c }\DataTypeTok{LogMsg} \KeywordTok{where}
\NormalTok{  dict1 }\DataTypeTok{SJsonMsg} \OtherTok{=} \DataTypeTok{Dict}
\NormalTok{  dict1 }\DataTypeTok{STextMsg} \OtherTok{=} \DataTypeTok{Dict}
\end{Highlighting}
\end{Shaded}

Now, given a list of log messages (possibly generated via
\texttt{WriterT\ {[}Sigma\ LogMsg{]}} or something similar), we can
operate over them. For example, perhaps we want to just render them to
text:

\href{Snip}{code/Sigma.hs:logs} \href{Snip}{code/Sigma.hs:showLogs}

\begin{Shaded}
\begin{Highlighting}[]

\end{Highlighting}
\end{Shaded}

But this approach of structured logging also affords us more interesting
opportunities for dealing with data. For example, we can filter it,
looking only for the JSON entries.

\href{Snip}{code/Sigma.hs:catSigmas} \href{Snip}{code/Sigma.hs:jsonLogs}

\begin{Shaded}
\begin{Highlighting}[]

\end{Highlighting}
\end{Shaded}

\hypertarget{glossary.}{%
\chapter{Glossary\{.\}}\label{glossary.}}

\noindent include({[}{[}{[}{[}{[}glossary.tex{]}{]}{]}{]}{]})

\hypertarget{solutions.}{%
\chapter{Solutions\{.\}}\label{solutions.}}

\hypertarget{bibliography}{%
\chapter{Bibliography}\label{bibliography}}

\hypertarget{bib-inspection-testing}{}
{[}inspection-testing{]}

Joachim Breitner. https://github.com/nomeata/inspection-testing

\hypertarget{bib-singletons}{}
{[}singletons{]}

Richard Eisenberg. https://github.com/goldfirere/singletons

\hypertarget{bib-contravariant}{}
{[}contravariant{]}

Ed Kmett. https://github.com/ekmett/contravariant

\hypertarget{bib-indexed}{}
{[}indexed{]}

Ed Kmett. https://github.com/reinerp/indexed

\hypertarget{bib-invariant}{}
{[}invariant{]}

Ed Kmett. https://github.com/ekmett/invariant

\hypertarget{bib-kan-extensions}{}
{[}kan-extensions{]}

Ed Kmett. https://github.com/ekmett/kan-extensions

\hypertarget{bib-do-notation}{}
{[}do-notation{]}

Sandy Maguire. https://github.com/isovector/do-notation

\hypertarget{bib-one-hole}{}
{[}one-hole{]}

Conor McBride. ``The Derivative of a Regular Type is its Type of
One-Hole Contexts.'' http://strictlypositive.org/diff.pdf

\hypertarget{bib-aeson}{}
{[}aeson{]}

Brian O'Sullivan. https://github.com/bos/aeson

\hypertarget{bib-fcf}{}
{[}fcf{]}

Li-yao Xia. https://github.com/Lysxia/first-class-families

\hypertarget{bib-servant}{}
{[}servant{]}

Zalora South East Asia Pte Ltd.~
https://github.com/haskell-servant/servant

\hypertarget{about-the-author.}{%
\chapter{About the Author\{.\}}\label{about-the-author.}}

Sandy might best be described somewhere between independent researcher
and voluntarily-unemployed bum. At the ripe old age of 27, he decided to
quit his highly-lucrative engineering job and to focus more on living
than on grinding for the man. It's what you might call a work in
progress.

In his now-copious spare time, he builds clocks, writes software
libraries, designs video games, and plays lots of music. He maintains a
blog about programming in Haskell at reasonablypolymorphic.com.

Some things he's done in past lives include being an early engineer at
Formation, building blazingly-fast compilers at Google, and accidentally
making Facebook a lot of money. Despite being retired, he might be
interested in helping you with any of these things too, so get in touch.

He holds a Bachelors Degree in Honors Software Engineering from the
University of Waterloo, which is a fantastic school that he'd recommend
you too attend.

Originally he comes from very northern Canada, but has since lived in
eleven cities throughout four different countries. Currently he lives in
Ottawa, Canada.

Want to talk? His email is sandy@sandymaguire.me.

\hypertarget{quantified-constraints}{%
\chapter{Quantified Constraints}\label{quantified-constraints}}

Consider the \texttt{mtl} class \texttt{MonadTrans}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{MonadTrans}\NormalTok{ t }\KeywordTok{where}
\OtherTok{  lift ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ m a }\OtherTok{{-}\textgreater{}}\NormalTok{ t m a}
\end{Highlighting}
\end{Shaded}

The idea is that \texttt{MonadTrans} is the underlying interface for all
monad transformers \texttt{t} --- that, given a value in any monad
\texttt{m}, we can \texttt{lift} it into a value in \texttt{t\ m}. On
first blush this sounds adequate, but it's missing an important
postcondition that we'd expect from a true monad transformer: that
\texttt{t\ m} is a monad!

To clarify this intuition, consider a contrived little program that is
polymorphic in \texttt{t}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{getHead ::} \DataTypeTok{MonadTrans}\NormalTok{ t }\OtherTok{=\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ t }\DataTypeTok{Maybe}\NormalTok{ a}
\NormalTok{getHead as }\OtherTok{=} \KeywordTok{do}
\NormalTok{  x }\OtherTok{\textless{}{-}}\NormalTok{ lift }\OperatorTok{$}\NormalTok{ listToMaybe as}
  \FunctionTok{pure}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

What does this program do when given the input \texttt{{[}1,\ 2,\ 3{]}}?
Trick question --- it doesn't even compile! Instead, GHC complains that
there is no \texttt{Monad\ (t\ Maybe)} instance. Which is obviously
crazy to us humans, because \texttt{t} is a monad transformer, and
\texttt{Maybe} is a monad. This is the same issue as above, that
\texttt{MonadTrans\ t} doesn't capture the fact that \texttt{t} lifts
entire monad instances.

An unsatisfying solution to this problem is to slightly modify the type
signature of \texttt{isEmpty}, adding a \texttt{Monad\ (t\ m)}
constraint:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{getHead ::}\NormalTok{ (}\DataTypeTok{Monad}\NormalTok{ (t m), }\DataTypeTok{MonadTrans}\NormalTok{ t) }\OtherTok{=\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ t }\DataTypeTok{Maybe}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

It certainly \emph{works}, but it's inelegant. You might think instead
that we could patch the \texttt{MonadTrans} class to try and add the
necessary evidence:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{MonadTrans}\NormalTok{ t }\KeywordTok{where}
\OtherTok{  lift ::}\NormalTok{ (}\DataTypeTok{Monad}\NormalTok{ m, }\DataTypeTok{Monad}\NormalTok{ (t m)) }\OtherTok{=\textgreater{}}\NormalTok{ m a }\OtherTok{{-}\textgreater{}}\NormalTok{ t m a}
\end{Highlighting}
\end{Shaded}

\noindent but this is in the wrong place! Trying to put a
\texttt{Monad\ (t\ m)} constraint here means we can't call \texttt{lift}
unless we \emph{already} have a proof that \texttt{t\ m} forms a monad,
which is exactly the problem we're trying to solve. Instead, in
situations like these, where we'd like to derive evidence of a type from
the presence of a typeclass, we should add a \emph{superclass context.}
The obvious thing to try would be:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Monad}\NormalTok{ (t m) }\OtherTok{=\textgreater{}} \DataTypeTok{MonadTrans}\NormalTok{ t }\KeywordTok{where}
\OtherTok{  lift ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ m a }\OtherTok{{-}\textgreater{}}\NormalTok{ t m a}
\end{Highlighting}
\end{Shaded}

Such an attempt is reasonable, but flawed --- unfortunately \texttt{m}
isn't in scope here. And even if it were, we don't want to say that
\texttt{t\ m} is \emph{always} a monad --- merely that it's a monad
\emph{if and only if} \texttt{m} is a monad.

So what can we do? Enter \texttt{-XQuantifiedConstraints}, a language
extention which dramatically extends what sorts of \texttt{Constraint}s
we can talk about. Under \texttt{-XQuantifiedConstraints}, we gain the
ability to use \texttt{forall} quantifiers in \texttt{Constraint}s, as
well as the ability to use implication (\texttt{=\textgreater{}})
itself. We will take lots of time to explore both of these features, but
for now, let's see how this language extension can help with
\texttt{MonadTrans}. A correct definition of \texttt{MonadTrans} is the
following\footnote{As of 2021, the real \texttt{MonadTrans} class in
  \texttt{mtl} doesn't yet use \texttt{-XQuantifiedConstraints}, but
  this is due only to historical and political reasons.}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ m}\OperatorTok{.} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}} \DataTypeTok{Monad}\NormalTok{ (t m)) }\OtherTok{=\textgreater{}} \DataTypeTok{MonadTrans}\NormalTok{ t }\KeywordTok{where}
\OtherTok{  lift ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ m a }\OtherTok{{-}\textgreater{}}\NormalTok{ t m a}
\end{Highlighting}
\end{Shaded}

The default constraint language (that is, under
\texttt{-XNoQuantifiedConstraints}) allows us to talk about
\emph{particular} instances, but not \emph{families}{[}\^{}math-class{]}
of instances. That is, the defult constraint language is
\emph{first-order.} Quantified constraints changes that.

Our new defintion for \texttt{MonadTrans} has a
\texttt{forall\ m.\ Monad\ m\ =\textgreater{}\ Monad\ (t\ m)} superclass
constraint. What this means is that, if I want to give an instance an
instance of \texttt{MonadTrans} for some concrete type constructor
\texttt{T} (of kind
\texttt{(Type\ -\textgreater{}\ Type)\ -\textgreater{}\ Type\ -\textgreater{}\ Type}),
I must also give an instance of the form:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Monad}\NormalTok{ (}\DataTypeTok{T}\NormalTok{ m)}
\end{Highlighting}
\end{Shaded}

\noindent where \texttt{m} is a variable. It \emph{will not work} if I
instead give a series of instances for every possible \texttt{m}, for
example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Monad}\NormalTok{ (}\DataTypeTok{T} \DataTypeTok{Maybe}\NormalTok{)}
\KeywordTok{instance} \DataTypeTok{Monad}\NormalTok{ (}\DataTypeTok{T}\NormalTok{ [])}
\KeywordTok{instance} \DataTypeTok{Monad}\NormalTok{ (}\DataTypeTok{T}\NormalTok{ (}\DataTypeTok{Either}\NormalTok{ a))}
\OperatorTok{...}
\end{Highlighting}
\end{Shaded}

What's important about the superclass constraint
\texttt{forall\ m.\ Monad\ m\ =\textgreater{}\ Monad\ (t\ m)} is that we
must be able to find a \texttt{Monad\ (t\ m)} instance for \emph{any
possible choice of \texttt{m}}. The only way to do that is to let
\texttt{m} be a variable --- otherwise I could put on my adversarial hat
and define a new type. No longer would your collection of concrete
instances be complete.

Notice however, that I said our instance must be of the form:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Monad}\NormalTok{ (}\DataTypeTok{T}\NormalTok{ m)}
\end{Highlighting}
\end{Shaded}

\noindent rather than the more obvious:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}} \DataTypeTok{Monad}\NormalTok{ (}\DataTypeTok{T}\NormalTok{ m)}
\end{Highlighting}
\end{Shaded}

\begin{description}
\item[TODO]
awful upcoming paragraph
\end{description}

The distinction is that both \texttt{instance\ Monad\ (T\ m)} and
\texttt{instance\ Monad\ m\ =\textgreater{}\ Monad\ (T\ m)} (and even
\texttt{instance\ Applicative\ m\ =\textgreater{}\ Monad\ (T\ m)}!) are
allowed under the quantified constraint
\texttt{forall\ m.\ Monad\ m\ =\textgreater{}\ Monad\ (t\ m)}. The
quantified \texttt{Monad\ m\ =\textgreater{}} piece means that instances
are \emph{allowed} to require a \texttt{Monad\ m} (or anything implied
by such --- either \texttt{Functor} or \texttt{Applicative}), but they
are not \emph{required} to. Contrast this against the quantified
constraint \texttt{forall\ m.\ Monad\ (t\ m)} which states the instance
\emph{must} be \texttt{instance\ Monad\ (T\ m)} --- in which no instance
context is allowed!

\backmatter

\end{document}
